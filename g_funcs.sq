function _command_name(  ) {
	local name
	if ( ::command_name ) {
		return ::command_name
	}
	name = "Central Command"
	::command_name = name
	return name
}

function _station_name(  ) {
	if ( ::station_name ) {
		return ::station_name
	}
	if ( ::config && ::config.station_name ) {
		::station_name = ::config.station_name
	} else {
		::station_name = ::new_station_name()
	}
	if ( ::config && ::config.server_name ) {
		::game.name = "" + ::config.server_name + ( ::config.server_name == ::station_name ? "" : ": " + ::station_name )
	} else {
		::game.name = ::station_name
	}
	return ::station_name
}

function _syndicate_name(  ) {
	local name
	if ( ::syndicate_name ) {
		return ::syndicate_name
	}
	name = ""
	local _ = ::random.pick([ "Clandestine", "Prima", "Blue", "Zero-G", "Max", "Blasto", "Waffle", "North", "Omni", "Newton", "Cyber", "Bonk", "Gene", "Gib" ])
	name += _
	if ( ::random.chance( 80 ) ) {
		name += " "
		if ( ::random.chance( 60 ) ) {
			local _ = ::random.pick([ "Syndicate", "Consortium", "Collective", "Corporation", "Group", "Holdings", "Biotech", "Industries", "Systems", "Products", "Chemicals", "Enterprises", "Family", "Creations", "International", "Intergalactic", "Interplanetary", "Foundation", "Positronics", "Hive" ])
			name += _
		} else {
			local _ = ::random.pick([ "Syndi", "Corp", "Bio", "System", "Prod", "Chem", "Inter", "Hive" ])
			name += _
			local _ = ::random.pick([ "", "-" ])
			name += _
			local _ = ::random.pick([ "Tech", "Sun", "Co", "Tek", "X", "Inc", "Code" ])
			name += _
		}
	} else {
		local _ = ::random.pick([ "-", "*", "" ])
		name += _
		local _ = ::random.pick([ "Tech", "Sun", "Co", "Tek", "X", "Inc", "Gen", "Star", "Dyne", "Code", "Hive" ])
		name += _
	}
	::syndicate_name = name
	return name
}

function above_neck( zone =null ) {
	local zones
	zones = ::List([ "head", "mouth", "eyes" ])
	if ( zones.Find( zone ) ) {
		return 1
	} else {
		return 0
	}
}

function active_ais( check_mind =null ) {
	local A, _default
	if ( check_mind == null ) {
		check_mind = 0
	}
	_default = ::List()
	A = null
	foreach (_ in ::living_mob_list ) {
		A = _
		if ( !( A instanceof ::Mob_Living_Silicon_Ai ) ) {
			continue
		}
		if ( A.stat == 2 ) {
			continue
		}
		if ( A.control_disabled == 1 ) {
			continue
		}
		if ( check_mind ) {
			if ( !A.mind ) {
				continue
			}
		}
		_default += A
	}
	return _default
	return _default
}

function add_logs( user =null, target =null, what_done =null, object =null, addition =null ) {
	local newhealthtxt, L
	if ( object == null ) {
		object = null
	}
	if ( addition == null ) {
		addition = null
	}
	newhealthtxt = ""
	if ( target && target instanceof ::Mob_Living ) {
		L = target
		newhealthtxt = " (NEWHP: " + L.health + ")"
	}
	if ( user && ::ismob( user ) ) {
		user.attack_log += "[" + ::time_stamp() + "] <font color='red'>Has " + what_done + " " + ( target ? "" + target.name + ( ::ismob( target ) && target.ckey ? "(" + target.ckey + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ( object ? " with " + object : " " ) + addition + newhealthtxt + "</font>"
	}
	if ( target && ::ismob( target ) ) {
		target.attack_log += "[" + ::time_stamp() + "] <font color='orange'>Has been " + what_done + " by " + ( user ? "" + user.name + ( ::ismob( user ) && user.ckey ? "(" + user.ckey + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ( object ? " with " + object : " " ) + addition + newhealthtxt + "</font>"
	}
	::log_attack( "" + ( user ? "" + user.name + ( ::ismob( user ) && user.ckey ? "(" + user.ckey + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + " " + what_done + " " + ( target ? "" + target.name + ( ::ismob( target ) && target.ckey ? "(" + target.ckey + ")" : "" ) : "NON-EXISTANT SUBJECT" ) + ( object ? " with " + object : " " ) + addition + newhealthtxt )
}

function add_radio( radio =null, freq =null ) {
	if ( !freq || !radio ) {
		return
	}
	if ( !::all_radios["" + freq] ) {
		::all_radios["" + freq] = ::List([ radio ])
		return freq
	}
	::all_radios["" + freq] = ::all_radios["" + freq] | radio
	return freq
}

function add_zero( t =null, u =null ) {
	while (::length( t ) < u) {
		t = "0" + t
	}
	return t
}

function addtimer( thingToCall =null, procToCall =null, wait =null, argList =null ) {
	local event
	if ( argList == null ) {
		argList = ::List()
	}
	if ( !::SStimer ) {
		return
	}
	if ( !thingToCall || !procToCall || wait <= 0 ) {
		return
	}
	if ( !::SStimer.can_fire ) {
		::SStimer.can_fire = 1
		::SStimer.next_fire = ::game.time + ::SStimer.wait
	}
	event = ::Timedevent()
	event.thingToCall = thingToCall
	event.procToCall = procToCall
	event.timeToRun = ::game.time + wait
	event.argList = argList
	::SStimer.processing += event
	return event.id
}

function admin_forcemove( mover =null, newloc =null ) {
	if ( mover.buckled ) {
		mover.buckled.unbuckle_mob()
	}
	if ( mover.buckled_mob ) {
		mover.unbuckle_mob.lcall( ::List({ ["force"]= 1 }) )
	}
	mover.loc = newloc
	mover.$on forcemove( newloc )
}

function admin_keyword_to_flag( word =null, previous_rights =null ) {
	local flag
	if ( previous_rights == null ) {
		previous_rights = 0
	}
	flag = 0
	local _ = ::ckey( word ) // Was a switch-case, sorry for the mess.
	if ( _=="buildmode" || _=="build" ) {
		flag = 1
	} else if ( _=="admin" ) {
		flag = 2
	} else if ( _=="ban" ) {
		flag = 4
	} else if ( _=="fun" ) {
		flag = 8
	} else if ( _=="server" ) {
		flag = 16
	} else if ( _=="debug" ) {
		flag = 32
	} else if ( _=="permissions" || _=="rights" ) {
		flag = 128
	} else if ( _=="possess" ) {
		flag = 64
	} else if ( _=="stealth" ) {
		flag = 256
	} else if ( _=="rejuv" || _=="rejuvinate" ) {
		flag = 512
	} else if ( _=="varedit" ) {
		flag = 1024
	} else if ( _=="everything" || _=="host" || _=="all" ) {
		flag = 65535
	} else if ( _=="sound" || _=="sounds" ) {
		flag = 2048
	} else if ( _=="spawn" || _=="create" ) {
		flag = 4096
	} else if ( _=="@" || _=="prev" ) {
		flag = previous_rights
	}
	return flag
}

function admin_keyword_to_path( word =null ) {
	return ::text2path( ::copytext( word, 2, ::findtext( word, " ", 2, 0 ) ) )
}

function adminscrub( t =null, limit =null ) {
	if ( limit == null ) {
		limit = 1024
	}
	return ::copytext( ::html_encode( ::strip_html_simple( t ) ), 1, limit )
}

function Advance_Mix( D_list =null ) {
	local diseases, A, i, D1, D2, to_return
	diseases = ::List()
	A = null
	foreach (_ in D_list ) {
		A = _
		if ( !( A instanceof ::Disease_Advance ) ) {
			continue
		}
		diseases += A.Copy()
	}
	if ( !diseases.len ) {
		return
	}
	if ( diseases.len <= 1 ) {
		return ::random.pick( diseases )
	}
	i = 0
	while (i < 20 && diseases.len > 1) {
		i++
		D1 = ::random.pick( diseases )
		diseases -= D1
		D2 = ::random.pick( diseases )
		D2.Mix( D1 )
	}
	to_return = ::random.pick( diseases )
	to_return.Refresh( 1 )
	return to_return
}

function alien_type_present( alienpath =null ) {
	local A
	A = null
	foreach (_ in ::living_mob_list ) {
		A = _
		if ( !( A instanceof ::Mob_Living_Carbon_Alien_Humanoid ) ) {
			continue
		}
		if ( !( A instanceof alienpath ) ) {
			continue
		}
		if ( !A.key || A.stat == 2 ) {
			continue
		}
		return 1
	}
	return 0
}

function alone_in_area( the_area =null, must_be_alone =null, check_type =null ) {
	local our_area, C
	if ( check_type == null ) {
		check_type = ::Mob_Living_Carbon
	}
	our_area = ::get_area_master( the_area )
	C = null
	foreach (_ in ::living_mob_list ) {
		C = _
		if ( !( C instanceof check_type ) ) {
			continue
		}
		if ( C == must_be_alone ) {
			continue
		}
		if ( our_area == ::get_area_master( C ) ) {
			return 0
		}
	}
	return 1
}

function angle2dir( degree =null ) {
	degree = ::SimplifyDegrees( degree )
	if ( degree < 45 ) {
		return ::NORTH
	}
	if ( degree < 90 ) {
		return ::NORTHEAST
	}
	if ( degree < 135 ) {
		return ::EAST
	}
	if ( degree < 180 ) {
		return ::SOUTHEAST
	}
	if ( degree < 225 ) {
		return ::SOUTH
	}
	if ( degree < 270 ) {
		return ::SOUTHWEST
	}
	if ( degree < 315 ) {
		return ::WEST
	}
	return 9
}

function angle2text( degree =null ) {
	return ::dir2text( ::angle2dir( degree ) )
}

function anim( location =null, target =null, a_icon =null, a_icon_state =null, flick_anim =null, sleeptime =null, direction =null ) {
	local animation
	if ( sleeptime == null ) {
		sleeptime = 0
	}
	animation = ::BaseDynamic_Overlay( location )
	if ( direction ) {
		animation.dir = direction
	}
	animation.icon = a_icon
	animation.layer = target.layer + 1
	if ( a_icon_state ) {
		animation.icon_state = a_icon_state
	} else {
		animation.icon_state = "blank"
		animation.master = target
		::flick( flick_anim, animation )
	}
	::thread.sleep( ::math.max( sleeptime, 15 ) )
	::qdel( animation )
}

function anyprob( value =null ) {
	return ::random.int( 1, value ) == value
}

function appearance_isbanned( M =null ) {
	local s, startpos, text
	if ( M ) {
		s = null
		foreach (_ in ::appearance_keylist ) {
			s = _
			if ( ::findtext( s, "" + M.ckey, 1, null ) == 1 ) {
				startpos = ::findtext( s, "## ", 1, null ) + 3
				if ( startpos && startpos < ::length( s ) ) {
					text = ::copytext( s, startpos, 0 )
					if ( text ) {
						return text
					}
				}
				return "Reason Unspecified"
			}
		}
	}
	return 0
}

function arctan( x =null ) {
	local y
	y = ::math.arcsin( x / ::math.sqrt( x * x + 1 ) )
	return y
}

function assign_progress_bar( user =null, progbar =null ) {
	if ( user && user.client && progbar ) {
		user.client.images = user.client.images | progbar
	}
}

function AStar( start =null, end =null, atom =null, dist =null, maxnodes =null, maxnodedepth =null, mintargetdist =null, adjacent =null, id =null, exclude =null, simulated_only =null ) {
	local open, closed, path, cur, closeenough, L, T, newg, PN, i
	if ( maxnodedepth == null ) {
		maxnodedepth = 30
	}
	if ( adjacent == null ) {
		adjacent = ::Tile.reachableAdjacentTurfs
	}
	if ( id == null ) {
		id = null
	}
	if ( exclude == null ) {
		exclude = null
	}
	if ( simulated_only == null ) {
		simulated_only = 1
	}
	if ( maxnodes ) {
		if ( ::getf2( start, dist )( end ) > maxnodes ) {
			return 0
		}
		maxnodedepth = maxnodes
	}
	open = ::Heap( ::HeapPathWeightCompare )
	closed = ::List()
	path = null
	start = ::get_turf( start )
	if ( !start ) {
		return 0
	}
	open.Insert( ::PathNode( start, null, 0, ::getf2( start, dist )( end ), 0 ) )
	while (!open.IsEmpty() && !path) {
		cur = open.Pop()
		closed.Add( cur.source )
		closeenough = null
		if ( mintargetdist ) {
			closeenough = ::getf2( cur.source, dist )( end ) <= mintargetdist
		}
		if ( maxnodedepth && cur.nt > maxnodedepth ) {
			continue
		}
		if ( cur.source == end || closeenough ) {
			path = ::List()
			path.Add( cur.source )
			while (cur.prevNode) {
				cur = cur.prevNode
				path.Add( cur.source )
			}
			break
		}
		L = ::getf2( cur.source, adjacent )( atom, id, simulated_only )
		T = null
		foreach (_ in L ) {
			T = _
			if ( ( T == exclude || T ) in closed ) {
				continue
			}
			newg = cur.g + ::getf2( cur.source, dist )( T )
			if ( !T.PNode ) {
				open.Insert( ::PathNode( T, cur, newg, ::getf2( T, dist )( end ), cur.nt + 1 ) )
			} else if ( newg < T.PNode.g ) {
				T.prevNode = cur
				T.PNode.g = newg
				T.PNode.calc_f()
				T.PNode.nt = cur.nt + 1
				open.ReSort( T.PNode )
			}
		}
	}
	PN = null
	foreach (_ in open.L ) {
		PN = _
		if ( !( PN instanceof ::PathNode ) ) {
			continue
		}
		PN.source.PNode = null
	}
	T = null
	foreach (_ in closed ) {
		T = _
		T.PNode = null
	}
	if ( path ) {
		i = null
		i = 1
		while (i <= path.len / 2) {
			path.$Swap( i, path.len - i + 1 )
			i++
		}
	}
	return path
}

function attach_spans( input =null, spans =null ) {
	return "" + ::message_spans_start( spans ) + input + "</span>"
}

function attempt_initiate_surgery( I =null, M =null, user =null ) {
	local H, affecting, selected_zone, current_surgery, S, all_surgeries, available_surgeries, path, P, procedure
	if ( M instanceof ::Mob_Living ) {
		selected_zone = user.zone_sel.selecting
		if ( M instanceof ::Mob_Living_Carbon_Human ) {
			H = M
			affecting = H.get_organ( ::check_zone( selected_zone ) )
		}
		if ( M.lying || M instanceof ::Mob_Living_SimpleAnimal_Slime ) {
			S = null
			foreach (_ in M.surgeries ) {
				S = _
				if ( !( S instanceof ::Surgery ) ) {
					continue
				}
				if ( S.location == selected_zone ) {
					current_surgery = S
				}
			}
			if ( !current_surgery ) {
				all_surgeries = ::surgeries_list.Copy()
				available_surgeries = ::List()
				S = null
				foreach (_ in all_surgeries ) {
					S = _
					if ( !( S instanceof ::Surgery ) ) {
						continue
					}
					if ( !S.possible_locs.Find( selected_zone ) ) {
						continue
					}
					if ( affecting && S.requires_organic_bodypart && affecting.status == 2 ) {
						continue
					}
					if ( !S.can_start( user, M ) ) {
						continue
					}
					path = null
					foreach (_ in S.species ) {
						path = _
						if ( M instanceof path ) {
							available_surgeries[S.name] = S
							break
						}
					}
				}
				P = ::input( "Begin which procedure?", "Surgery", null, null, available_surgeries, 4224 )
				if ( P && user && user.Adjacent( M ) && I in user ) {
					S = available_surgeries[P]
					procedure = S.type()
					if ( procedure ) {
						procedure.location = selected_zone
						if ( procedure.ignore_clothes || ::get_location_accessible( M, selected_zone ) ) {
							M.surgeries += procedure
							procedure.organ = affecting
							user.visible_message( ::Txt().item( user ).str( " drapes " ).item( I ).str( " over " ).item( M ).str( "'s " ).item( ::parse_zone( selected_zone ) ).str( " to prepare for " ).a( procedure.name ).item().str( "." ), ::Txt( "<span class='notice'>You drape " ).item( I ).str( " over " ).item( M ).str( "'s " ).item( ::parse_zone( selected_zone ) ).str( " to prepare for " ).a( procedure.name ).item().str( ".</span>" ) )
							::smooth_icon_neighbors.lcall( ::List({ ["addition"]= "Operation type: " + procedure.name + ", location: " + selected_zone, [3]= "operated", [2]= M, [1]= user }) )
						} else {
							user.write( "<span class='warning'>You need to expose " + M + "'s " + ::parse_zone( selected_zone ) + " first!</span>" )
						}
					}
				}
			} else if ( !current_surgery.step_in_progress ) {
				if ( current_surgery.status == 1 ) {
					M.surgeries -= current_surgery
					user.visible_message( "" + user + " removes the drapes from " + M + "'s " + ::parse_zone( selected_zone ) + ".", "<span class='notice'>You remove the drapes from " + M + "'s " + ::parse_zone( selected_zone ) + ".</span>" )
					::qdel( current_surgery )
				} else if ( user.get_inactive_hand() instanceof ::Ent_Item_Weapon_Cautery && current_surgery.can_cancel ) {
					M.surgeries -= current_surgery
					user.visible_message( "" + user + " mends the incision and removes the drapes from " + M + "'s " + ::parse_zone( selected_zone ) + ".", "<span class='notice'>You mend the incision and remove the drapes from " + M + "'s " + ::parse_zone( selected_zone ) + ".</span>" )
					::qdel( current_surgery )
				} else if ( current_surgery.can_cancel ) {
					user.write( "<span class='warning'>You need to hold a cautery in inactive hand to stop " + M + "'s surgery!</span>" )
				}
			}
			return 1
		}
	}
	return 0
}

function AverageColour( I =null ) {
	local colours, x_pixel, y_pixel, this_colour, final_average, colour
	colours = ::List()
	x_pixel = null
	foreach (_ in ::gen_range( 1, I.Width() ) ) {
		x_pixel = _
		y_pixel = null
		foreach (_ in ::gen_range( 1, I.Height() ) ) {
			y_pixel = _
			this_colour = I.GetPixel( x_pixel, y_pixel )
			if ( this_colour ) {
				colours.Add( this_colour )
			}
		}
	}
	if ( !colours.len ) {
		return
	}
	final_average = colours[1]
	colour = null
	foreach (_ in colours - colours[1] ) {
		colour = _
		final_average = ::BlendRGB( final_average, colour, 1 )
	}
	return final_average
}

function blendMode2iconMode( blend_mode =null ) {
	local _ = blend_mode // Was a switch-case, sorry for the mess.
	if ( _==4 ) {
		return 2
	} else if ( _==2 ) {
		return 0
	} else if ( _==3 ) {
		return 1
	} else {
		return 3
	}
}

function BlendRGB( rgb1 =null, rgb2 =null, amount =null ) {
	local RGB1, RGB2, usealpha, r, g, b, alpha
	RGB1 = ::ReadRGB( rgb1 )
	RGB2 = ::ReadRGB( rgb2 )
	if ( RGB1.len < RGB2.len ) {
		RGB1 += 255
	} else if ( RGB2.len < RGB1.len ) {
		RGB2 += 255
	}
	usealpha = RGB1.len > 3
	r = ::math.round( RGB1[1] + ( RGB2[1] - RGB1[1] ) * amount, 1 )
	g = ::math.round( RGB1[2] + ( RGB2[2] - RGB1[2] ) * amount, 1 )
	b = ::math.round( RGB1[3] + ( RGB2[3] - RGB1[3] ) * amount, 1 )
	alpha = usealpha ? ::math.round( RGB1[4] + ( RGB2[4] - RGB1[4] ) * amount, 1 ) : null
	return ::isnull( alpha ) ? ::rgb( r, g, b ) : ::rgba( r, g, b, alpha )
}

function blood_incompatible( donor =null, receiver =null, donor_species =null, receiver_species =null ) {
	local donor_antigen, receiver_antigen, donor_rh, receiver_rh
	if ( !donor || !receiver ) {
		return 0
	}
	if ( donor_species && receiver_species ) {
		if ( donor_species != receiver_species ) {
			return 1
		}
	}
	donor_antigen = ::copytext( donor, 1, ::length( donor ) )
	receiver_antigen = ::copytext( receiver, 1, ::length( receiver ) )
	donor_rh = ::findtext( donor, "+", 1, null ) > 0
	receiver_rh = ::findtext( receiver, "+", 1, null ) > 0
	if ( donor_rh && !receiver_rh ) {
		return 1
	}
	local _ = receiver_antigen // Was a switch-case, sorry for the mess.
	if ( _=="A" ) {
		if ( donor_antigen != "A" && donor_antigen != "O" ) {
			return 1
		}
	} else if ( _=="B" ) {
		if ( donor_antigen != "B" && donor_antigen != "O" ) {
			return 1
		}
	} else if ( _=="O" ) {
		if ( donor_antigen != "O" ) {
			return 1
		}
	}
	return 0
}

function blood_splatter( target =null, source =null, large =null ) {
	local B, decal_type, T, M, donor, drips, drop
	decal_type = ::Ent_Effect_Decal_Cleanable_Blood_Splatter
	T = ::get_turf( target )
	if ( source instanceof ::Mob_Living_Carbon_Human ) {
		M = source
		source = M.get_blood( M.vessel )
	} else if ( source instanceof ::Mob_Living_Carbon_Monkey ) {
		donor = source
		source = ::Reagent_Blood()
		source.data.blood_DNA = donor.dna.unique_enzymes
		source.data.blood_type = donor.dna.blood_type
	}
	drips = ::List()
	drop = null
	foreach (_ in T ) {
		drop = _
		if ( !( drop instanceof ::Ent_Effect_Decal_Cleanable_Blood_Drip ) ) {
			continue
		}
		drips = drips | drop.drips
		::qdel( drop )
	}
	if ( !large && drips.len < 3 ) {
		decal_type = ::Ent_Effect_Decal_Cleanable_Blood_Drip
	}
	B = ::locate_in( decal_type, T )
	if ( !B ) {
		B = decal_type( T )
	}
	drop = B
	if ( drop instanceof ::Ent_Effect_Decal_Cleanable_Blood_Drip && drips && drips.len && !large ) {
		drop.overlays = drop.overlays | drips
		drop.drips = drop.drips | drips
	}
	if ( !source ) {
		return B
	}
	if ( source.data.blood_DNA ) {
		B.blood_DNA = ::List()
		if ( source.data.blood_type ) {
			B.blood_DNA[source.data.blood_DNA] = source.data.blood_type
		} else {
			B.blood_DNA[source.data.blood_DNA] = "O+"
		}
	}
	return B
}

function Broadcast_Message( AM =null, vmask =null, radio =null, message =null, name =null, job =null, realname =null, data =null, compression =null, level =null, freq =null, spans =null, verb_say =null, verb_ask =null, verb_exclaim =null, verb_yell =null ) {
	local radios, virt, R, freqtext, receive, M, rendered, hearer, blackbox_msg
	message = ::copytext( message, 1, 512 )
	if ( !message ) {
		return
	}
	radios = ::List()
	virt = ::PoolOrNew( ::BaseDynamic_Virtualspeaker, null )
	virt.name = name
	virt.job = job
	virt.languages = AM.languages
	virt.source = AM
	virt.radio = radio
	virt.verb_say = verb_say
	virt.verb_ask = verb_ask
	virt.verb_exclaim = verb_exclaim
	virt.verb_yell = verb_yell
	if ( compression > 0 ) {
		message = ::Gibberish( message, compression + 40 )
	}
	if ( data == 1 ) {
		R = null
		foreach (_ in ::all_radios["" + freq] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio_Intercom ) ) {
				continue
			}
			if ( R.receive_range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else if ( data == 2 ) {
		R = null
		foreach (_ in ::all_radios["" + freq] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( R.subspace_transmission ) {
				continue
			}
			if ( R.receive_range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else if ( data == 5 ) {
		R = null
		foreach (_ in ::all_radios["" + freq] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( !R.centcom ) {
				continue
			}
			if ( R.receive_range( freq, level ) > -1 ) {
				radios += R
			}
		}
	} else {
		R = null
		foreach (_ in ::all_radios["" + freq] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( R.receive_range( freq, level ) > -1 ) {
				radios += R
			}
		}
		freqtext = ::num2text( freq )
		R = null
		foreach (_ in ::all_radios["" + ::SYND_FREQ] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( R.receive_range( ::SYND_FREQ, ::List([ R.z ]) ) > -1 && freqtext in ::radiochannelsreverse ) {
				radios = radios | R
			}
		}
	}
	receive = ::get_mobs_in_radio_ranges( radios )
	R = null
	foreach (_ in receive ) {
		R = _
		if ( R.client && R.client.holder && !( R.client.prefs.chat_toggles & 32 ) ) {
			receive -= R
		}
	}
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( M instanceof ::Mob_Dead_Observer && M.client && M.client.prefs.chat_toggles & 512 ) {
			receive = receive | M
		}
	}
	rendered = virt.compose_message( virt, virt.languages, message, freq, spans )
	hearer = null
	foreach (_ in receive ) {
		hearer = _
		if ( !( hearer instanceof ::BaseDynamic ) ) {
			continue
		}
		hearer.Hear( rendered, virt, AM.languages, message, freq, spans )
	}
	if ( ::length( receive ) ) {
		blackbox_msg = "" + AM + " " + AM.say_quote( message, spans )
		if ( ::blackbox instanceof ::Ent_Machinery_BlackboxRecorder ) {
			local _ = freq // Was a switch-case, sorry for the mess.
			if ( _==1459 ) {
				::blackbox.msg_common += blackbox_msg
			} else if ( _==1351 ) {
				::blackbox.msg_science += blackbox_msg
			} else if ( _==1353 ) {
				::blackbox.msg_command += blackbox_msg
			} else if ( _==1355 ) {
				::blackbox.msg_medical += blackbox_msg
			} else if ( _==1357 ) {
				::blackbox.msg_engineering += blackbox_msg
			} else if ( _==1359 ) {
				::blackbox.msg_security += blackbox_msg
			} else if ( _==1441 ) {
				::blackbox.msg_deathsquad += blackbox_msg
			} else if ( _==1213 ) {
				::blackbox.msg_syndicate += blackbox_msg
			} else if ( _==1349 ) {
				::blackbox.msg_service += blackbox_msg
			} else if ( _==1347 ) {
				::blackbox.msg_cargo += blackbox_msg
			} else {
				::blackbox.messages += blackbox_msg
			}
		}
	}
	::thread.schedule( 50, function() {
		::qdel( virt )
		return
	})
}

function Broadcast_SimpleMessage( source =null, frequency =null, text =null, data =null, M =null, compression =null, level =null ) {
	local H, connection, display_freq, receive, R, position, syndicateconnection, heard_normal, heard_garbled, heard_gibberish, part_a, freq_text, part_b_extra, radio, part_b, part_c, part_blackbox_b, blackbox_msg, rendered, quotedmsg
	if ( !M ) {
		H = ::Mob_Living_Carbon_Human()
		M = H
	}
	connection = ::radio_controller.return_frequency( frequency )
	display_freq = connection.frequency
	receive = ::List()
	if ( data == 1 ) {
		R = null
		foreach (_ in connection.devices["" + ::RADIO_CHAT] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio_Intercom ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send_hear( display_freq, level )
			}
		}
	} else if ( data == 2 ) {
		R = null
		foreach (_ in connection.devices["" + ::RADIO_CHAT] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( R.subspace_transmission ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send_hear( display_freq )
			}
		}
	} else if ( data == 3 ) {
		syndicateconnection = ::radio_controller.return_frequency( ::SYND_FREQ )
		R = null
		foreach (_ in syndicateconnection.devices["" + ::RADIO_CHAT] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send_hear( ::SYND_FREQ )
			}
		}
	} else if ( data == 5 ) {
		R = null
		foreach (_ in ::all_radios["" + ::RADIO_CHAT] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			if ( R.centcom ) {
				receive = receive | R.$send hear( ::CENTCOM_FREQ )
			}
		}
	} else {
		R = null
		foreach (_ in connection.devices["" + ::RADIO_CHAT] ) {
			R = _
			if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
				continue
			}
			position = ::get_turf( R )
			if ( position && position.z == level ) {
				receive = receive | R.send_hear( display_freq )
			}
		}
	}
	heard_normal = ::List()
	heard_garbled = ::List()
	heard_gibberish = ::List()
	R = null
	foreach (_ in receive ) {
		R = _
		if ( R.client && !( R.client.prefs.chat_toggles & 32 ) ) {
			continue
		}
		if ( compression > 0 ) {
			heard_gibberish += R
			continue
		}
		if ( R.languages & M.languages ) {
			heard_normal += R
		} else {
			heard_garbled += R
		}
	}
	if ( ::length( heard_normal ) || ::length( heard_garbled ) || ::length( heard_gibberish ) ) {
		part_a = "<span class='radio'><span class='name'>"
		freq_text = null
		local _ = display_freq // Was a switch-case, sorry for the mess.
		if ( _==1213 ) {
			freq_text = "#unkn"
		} else if ( _==1353 ) {
			freq_text = "Command"
		} else if ( _==1351 ) {
			freq_text = "Science"
		} else if ( _==1355 ) {
			freq_text = "Medical"
		} else if ( _==1357 ) {
			freq_text = "Engineering"
		} else if ( _==1359 ) {
			freq_text = "Security"
		} else if ( _==1349 ) {
			freq_text = "Service"
		} else if ( _==1347 ) {
			freq_text = "Supply"
		} else if ( _==1447 ) {
			freq_text = "AI Private"
		}
		if ( !freq_text ) {
			freq_text = ::format_frequency( display_freq )
		}
		part_b_extra = ""
		if ( data == 3 ) {
			part_b_extra = " <i>(Intercepted)</i>"
		}
		radio = ::Ent_Item_Device_Radio_Headset()
		part_b = ::Txt( "</span><b> " ).icon( radio ).str( "[" ).item( freq_text ).str( "]" ).item( part_b_extra ).str( "</b> <span class='message'>" )
		part_c = "</span></span>"
		if ( display_freq == ::SYND_FREQ ) {
			part_a = "<span class='syndradio'><span class='name'>"
		} else if ( display_freq == ::COMM_FREQ ) {
			part_a = "<span class='comradio'><span class='name'>"
		} else if ( display_freq == ::SCI_FREQ ) {
			part_a = "<span class='sciradio'><span class='name'>"
		} else if ( display_freq == ::MED_FREQ ) {
			part_a = "<span class='medradio'><span class='name'>"
		} else if ( display_freq == ::ENG_FREQ ) {
			part_a = "<span class='engradio'><span class='name'>"
		} else if ( display_freq == ::SEC_FREQ ) {
			part_a = "<span class='secradio'><span class='name'>"
		} else if ( display_freq == ::SERV_FREQ ) {
			part_a = "<span class='servradio'><span class='name'>"
		} else if ( display_freq == ::SUPP_FREQ ) {
			part_a = "<span class='suppradio'><span class='name'>"
		} else if ( display_freq == ::CENTCOM_FREQ ) {
			part_a = "<span class='centcomradio'><span class='name'>"
		} else if ( display_freq == ::AIPRIV_FREQ ) {
			part_a = "<span class='aiprivradio'><span class='name'>"
		}
		part_blackbox_b = "</span><b> [" + freq_text + "]</b> <span class='message'>"
		blackbox_msg = "" + part_a + source + part_blackbox_b + "\"" + text + "\"" + part_c
		if ( ::blackbox instanceof ::Ent_Machinery_BlackboxRecorder ) {
			local _ = display_freq // Was a switch-case, sorry for the mess.
			if ( _==1459 ) {
				::blackbox.msg_common += blackbox_msg
			} else if ( _==1351 ) {
				::blackbox.msg_science += blackbox_msg
			} else if ( _==1353 ) {
				::blackbox.msg_command += blackbox_msg
			} else if ( _==1355 ) {
				::blackbox.msg_medical += blackbox_msg
			} else if ( _==1357 ) {
				::blackbox.msg_engineering += blackbox_msg
			} else if ( _==1359 ) {
				::blackbox.msg_security += blackbox_msg
			} else if ( _==1441 ) {
				::blackbox.msg_deathsquad += blackbox_msg
			} else if ( _==1213 ) {
				::blackbox.msg_syndicate += blackbox_msg
			} else if ( _==1349 ) {
				::blackbox.msg_service += blackbox_msg
			} else if ( _==1347 ) {
				::blackbox.msg_cargo += blackbox_msg
			} else {
				::blackbox.messages += blackbox_msg
			}
		}
		if ( ::length( heard_normal ) ) {
			rendered = "" + part_a + source + part_b + "\"" + text + "\"" + part_c
			R = null
			foreach (_ in heard_normal ) {
				R = _
				R.show_message( rendered, 2 )
			}
		}
		if ( ::length( heard_garbled ) ) {
			quotedmsg = "\"" + ::stars( text ) + "\""
			rendered = "" + part_a + source + part_b + quotedmsg + part_c
			R = null
			foreach (_ in heard_garbled ) {
				R = _
				R.show_message( rendered, 2 )
			}
		}
		if ( ::length( heard_gibberish ) ) {
			quotedmsg = "\"" + ::Gibberish( text, compression + 50 ) + "\""
			rendered = "" + part_a + ::Gibberish( source, compression + 50 ) + part_b + quotedmsg + part_c
			R = null
			foreach (_ in heard_gibberish ) {
				R = _
				R.show_message( rendered, 2 )
			}
		}
	}
}

function build_click( user =null, buildmode =null, params =null, object =null ) {
	local holder, H, pa, T, WIN, A, G
	holder = null
	H = null
	foreach (_ in ::game ) {
		H = _
		if ( !( H instanceof ::Ent_Effect_Bmode_Buildholder ) ) {
			continue
		}
		if ( H.cl == user.client ) {
			holder = H
			break
		}
	}
	if ( !holder ) {
		return
	}
	pa = ::params2list( params )
	if ( object instanceof ::Ent_Effect_Bmode ) {
		return
	}
	local _ = buildmode // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		if ( object instanceof ::Tile && pa.Find( "left" ) && !pa.$Find( "alt" ) && !pa.$Find( "ctrl" ) ) {
			T = object
			if ( object instanceof ::Tile_Space ) {
				T.ChangeTurf( ::Tile_Simulated_Floor_Plasteel )
			} else if ( object instanceof ::Tile_Simulated_Floor ) {
				T.ChangeTurf( ::Tile_Simulated_Wall )
			} else if ( object instanceof ::Tile_Simulated_Wall ) {
				T.ChangeTurf( ::Tile_Simulated_Wall_RWall )
			}
			::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " built " + T + " at (" + T.x + "," + T.y + "," + T.z + ")" )
			return
		} else if ( pa.Find( "right" ) ) {
			::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " deleted " + object + " at (" + object.x + "," + object.y + "," + object.z + ")" )
			if ( object instanceof ::Tile_Simulated_Wall ) {
				T = object
				T.ChangeTurf( ::Tile_Simulated_Floor_Plasteel )
			} else if ( object instanceof ::Tile_Simulated_Floor ) {
				T = object
				T.ChangeTurf( ::Tile_Space )
			} else if ( object instanceof ::Tile_Simulated_Wall_RWall ) {
				T = object
				T.ChangeTurf( ::Tile_Simulated_Wall )
			} else if ( object instanceof ::Entity ) {
				::qdel( object )
			}
			return
		} else if ( object instanceof ::Tile && T.$Find( "alt" ) && T.$Find( "left" ) ) {
			::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " built an airlock at (" + object.x + "," + object.y + "," + object.z + ")" )
			::Ent_Machinery_Door_Airlock( ::get_turf( object ) )
		} else if ( object instanceof ::Tile && pa.Find( "ctrl" ) && pa.$Find( "left" ) ) {
			local _ = holder.builddir.dir // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				WIN = ::Ent_Structure_Window_Reinforced( ::get_turf( object ) )
				WIN.dir = ::NORTH
			} else if ( _==2 ) {
				WIN = ::Ent_Structure_Window_Reinforced( ::get_turf( object ) )
				WIN.dir = ::SOUTH
			} else if ( _==4 ) {
				WIN = ::Ent_Structure_Window_Reinforced( ::get_turf( object ) )
				WIN.dir = ::EAST
			} else if ( _==8 ) {
				WIN = ::Ent_Structure_Window_Reinforced( ::get_turf( object ) )
				WIN.dir = ::WEST
			} else if ( _==9 ) {
				WIN = ::Ent_Structure_Window_Reinforced( ::get_turf( object ) )
				WIN.dir = ::NORTHWEST
			}
			::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " built a window at (" + object.x + "," + object.y + "," + object.z + ")" )
		}
	} else if ( _==2 ) {
		if ( pa.Find( "left" ) ) {
			if ( ::ispath2( holder.buildmode.objholder, ::Tile ) ) {
				T = ::get_turf( object )
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " modified " + T + " (" + T.x + "," + T.y + "," + T.z + ") to " + holder.buildmode.objholder )
				T.ChangeTurf( holder.buildmode.objholder )
			} else {
				A = T.objholder( ::get_turf( object ) )
				A.dir = holder.builddir.dir
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " modified " + A + "'s (" + A.x + "," + A.y + "," + A.z + ") dir to " + holder.builddir.dir )
			}
		} else if ( holder.$Find( "right" ) ) {
			if ( ::isobj( object ) ) {
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " deleted " + object + " at (" + object.x + "," + object.y + "," + object.z + ")" )
				::qdel( object )
			}
		}
	} else if ( _==3 ) {
		if ( pa.Find( "left" ) ) {
			if ( object.vars.Find( holder.buildmode.varholder ) ) {
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " modified " + object.name + "'s " + holder.buildmode.varholder + " to " + holder.valueholder )
				object.vars[holder.buildmode.varholder] = holder.buildmode.valueholder
			} else {
				::thread.user.write( "<span class='warning'>" + ::initial( object.name ) + " does not have a var called '" + holder.buildmode.varholder + "'</span>" )
			}
		}
		if ( pa.Find( "right" ) ) {
			if ( object.vars.Find( holder.buildmode.varholder ) ) {
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " modified " + object.name + "'s " + holder.buildmode.varholder + " to " + holder.valueholder )
				object.vars[holder.buildmode.varholder] = ::initial( object.vars[holder.buildmode.varholder] )
			} else {
				::thread.user.write( "<span class='warning'>" + ::initial( object.name ) + " does not have a var called '" + holder.buildmode.varholder + "'</span>" )
			}
		}
	} else if ( _==4 ) {
		if ( pa.Find( "left" ) ) {
			if ( ::isturf( object ) ) {
				return
			}
			holder.throw_atom = object
		}
		if ( pa.Find( "right" ) ) {
			if ( holder.throw_atom ) {
				holder.throw_atom.throw_at( object, 10, 1, user )
				::log_admin( "Build Mode: " + ::key_name( ::thread.user ) + " threw " + holder.throw_atom + " at " + object + " (" + object.x + "," + object.y + "," + object.z + ")" )
			}
		}
	} else if ( _==5 ) {
		if ( !holder.cornerA ) {
			holder.cornerA = ::get_turf( object )
			return
		}
		if ( holder.cornerA && !holder.cornerB ) {
			holder.cornerB = ::get_turf( object )
		}
		if ( pa.Find( "left" ) ) {
			if ( holder.cornerA && holder.cornerB ) {
				if ( !holder.generator_path ) {
					::thread.user.write( "<span class='warning'>Select generator type first.</span>" )
				}
				G = holder.generator_path()
				G.defineRegion( holder.cornerA, holder.cornerB, 1 )
				G.$generate()
				holder.cornerA = null
				holder.cornerB = null
				return
			}
		}
		holder.cornerA = null
		holder.cornerB = null
	}
}

function calculate_adjacencies( A =null ) {
	local adjacencies, AM, direction
	if ( !A.loc ) {
		return 0
	}
	adjacencies = 0
	if ( A.can_be_unanchored ) {
		AM = A
		if ( !AM.anchored ) {
			return 0
		}
		direction = null
		foreach (_ in ::alldirs ) {
			direction = _
			AM = ::find_type_in_direction( A, direction )
			if ( AM instanceof ::BaseDynamic ) {
				if ( AM.anchored ) {
					adjacencies = adjacencies | ::transform_dir( direction )
				}
			} else if ( AM ) {
				adjacencies = adjacencies | ::transform_dir( direction )
			}
		}
	} else {
		direction = null
		foreach (_ in ::alldirs ) {
			direction = _
			if ( ::find_type_in_direction( A, direction ) ) {
				adjacencies = adjacencies | ::transform_dir( direction )
			}
		}
	}
	return adjacencies
}

function camera_sort( L =null ) {
	local a, b, i, j
	i = null
	i = L.len
	while (i > 0) {
		j = null
		foreach (_ in ::gen_range( 1, i - 1 ) ) {
			j = _
			a = L[j]
			b = L[j + 1]
			if ( a.c_tag_order != b.c_tag_order ) {
				if ( a.c_tag_order > b.c_tag_order ) {
					L.Swap( j, j + 1 )
				}
			} else if ( ::sorttext( a.c_tag, b.c_tag ) < 0 ) {
				L.Swap( j, j + 1 )
			}
		}
		i--
	}
	return L
}

function can_embed( W =null ) {
	local embed_items
	if ( W.is_sharp() ) {
		return 1
	}
	if ( ::is_pointed( W ) ) {
		return 1
	}
	embed_items = ::List([ ::Ent_Item_Stack_Rods ])
	if ( ::is_type_in_list( W, embed_items ) ) {
		return 1
	}
}

function can_see( source =null, target =null, length =null ) {
	local current, target_turf, steps, A
	if ( length == null ) {
		length = 5
	}
	current = ::get_turf( source )
	target_turf = ::get_turf( target )
	steps = 0
	while (current != target_turf) {
		if ( steps > length ) {
			return 0
		}
		if ( current.opacity ) {
			return 0
		}
		A = null
		foreach (_ in current ) {
			A = _
			if ( !( A instanceof ::BaseStatic ) ) {
				continue
			}
			if ( A.opacity ) {
				return 0
			}
		}
		current = ::get_step_towards( current, target_turf )
		steps++
	}
	return 1
}

function cancel_progress_bar( user =null, progbar =null ) {
	if ( user && user.client && progbar ) {
		user.client.images -= progbar
	}
}

function CanHug( M =null ) {
	local C, H
	if ( !( M instanceof ::Mob_Living ) ) {
		return 0
	}
	if ( M.stat == 2 ) {
		return 0
	}
	if ( M.getorgan( ::Ent_Item_Organ_Internal_Alien_Hivenode ) ) {
		return 0
	}
	if ( M instanceof ::Mob_Living_SimpleAnimal_Pet_Dog_Corgi || M instanceof ::Mob_Living_Carbon_Monkey ) {
		return 1
	}
	C = M
	if ( C instanceof ::Mob_Living_Carbon_Human ) {
		H = C
		if ( H.is_mouth_covered.lcall( ::List({ ["head_only"]= 1 }) ) ) {
			return 0
		}
		return 1
	}
	return 0
}

function capitalize( t =null ) {
	return ::uppertext( ::copytext( t, 1, 2 ) ) + ::copytext( t, 2, null )
}

function cardinalrange( center =null ) {
	local things, direction, T
	things = ::List()
	direction = null
	foreach (_ in ::cardinal ) {
		direction = _
		T = ::get_step( center, direction )
		if ( !T ) {
			continue
		}
		things += T.contents
	}
	return things
}

function Ceiling( x =null ) {
	return -::math.round( -x )
}

function center_image( I =null, x_dimension =null, y_dimension =null ) {
	local x_offset, y_offset
	if ( x_dimension == null ) {
		x_dimension = 0
	}
	if ( y_dimension == null ) {
		y_dimension = 0
	}
	if ( !I ) {
		return
	}
	if ( !x_dimension || !y_dimension ) {
		return
	}
	if ( x_dimension == ::game.icon_size && y_dimension == ::game.icon_size ) {
		return I
	}
	x_offset = -( x_dimension / ::game.icon_size - 1 ) * ::game.icon_size * 0.5
	y_offset = -( y_dimension / ::game.icon_size - 1 ) * ::game.icon_size * 0.5
	if ( x_dimension < ::game.icon_size ) {
		x_offset *= -1
	}
	if ( y_dimension < ::game.icon_size ) {
		y_offset *= -1
	}
	I.pixel_x = x_offset
	I.pixel_y = y_offset
	return I
}

function changeling_transform( user =null, chosen_prof =null ) {
	local chosen_dna, slot, C, equip, thetype
	chosen_dna = chosen_prof.dna
	user.real_name = chosen_prof.name
	user.underwear = chosen_prof.underwear
	user.undershirt = chosen_prof.undershirt
	user.socks = chosen_prof.socks
	chosen_dna.transfer_identity( user, 1 )
	user.updateappearance.lcall( ::List({ ["mutcolor_update"]= 1 }) )
	user.update_body()
	user.$domutcheck()
	slot = null
	foreach (_ in ::slots ) {
		slot = _
		if ( user.vars[slot] instanceof ::slot2type[slot] && !chosen_prof.exists_list[slot] ) {
			::qdel( user.vars[slot] )
			continue
		}
		if ( user.vars[slot] && !( user.vars[slot] instanceof ::slot2type[slot] ) || !chosen_prof.exists_list[slot] ) {
			continue
		}
		C = null
		equip = 0
		if ( !user.vars[slot] ) {
			thetype = ::slot2type[slot]
			equip = 1
			C = thetype( user )
		} else if ( user.vars[slot] instanceof ::slot2type[slot] ) {
			C = user.vars[slot]
		}
		C.appearance = chosen_prof.appearance_list[slot]
		C.name = chosen_prof.name_list[slot]
		C.flags_cover = chosen_prof.flags_cover_list[slot]
		C.item_color = chosen_prof.item_color_list[slot]
		C.item_state = chosen_prof.item_state_list[slot]
		if ( equip ) {
			user.equip_to_slot_or_del( C, ::slot2slot[slot] )
		}
	}
	user.regenerate_icons()
}

function changemap( VM =null ) {
	local file
	return
	if ( !( VM instanceof ::Votablemap ) ) {
		return
	}
	::log_game( "Changing map to " + VM.name + "(" + VM.friendlyname + ")" )
}

function cheap_hypotenuse( Ax =null, Ay =null, Bx =null, By =null ) {
	return ::math.sqrt( ::pow( ::math.abs( Ax - Bx ), 2 ) + ::pow( ::math.abs( Ay - By ), 2 ) )
}

function check_rights( rights_required =null, show_msg =null ) {
	if ( show_msg == null ) {
		show_msg = 1
	}
	if ( ::thread.user && ::thread.user.client ) {
		if ( ::check_rights_for( ::thread.user.client, rights_required ) ) {
			return 1
		} else if ( show_msg ) {
			::thread.user.write( "<font color='red'>Error: You do not have sufficient rights to do that. You require one of the following flags:" + ::rights2text( rights_required, " " ) + ".</font>" )
		}
	}
	return 0
}

function check_rights_for( subject =null, rights_required =null ) {
	if ( subject && subject.holder && subject.holder.rank ) {
		if ( rights_required && !( rights_required & subject.holder.rank.rights ) ) {
			return 0
		}
		return 1
	}
	return 0
}

function check_tank_exists( parent_tank =null, M =null, O =null ) {
	if ( !parent_tank || !( parent_tank instanceof ::Ent_Item_Weapon_Watertank ) ) {
		M.unEquip( O )
		::qdel( 0 )
		return 0
	} else {
		return 1
	}
}

function check_zone( zone =null ) {
	if ( !zone ) {
		return "chest"
	}
	local _ = zone // Was a switch-case, sorry for the mess.
	if ( _=="eyes" ) {
		zone = "head"
	} else if ( _=="mouth" ) {
		zone = "head"
	} else if ( _=="l_hand" ) {
		zone = "l_arm"
	} else if ( _=="r_hand" ) {
		zone = "r_arm"
	} else if ( _=="l_foot" ) {
		zone = "l_leg"
	} else if ( _=="r_foot" ) {
		zone = "r_leg"
	} else if ( _=="groin" ) {
		zone = "chest"
	}
	return zone
}

function chemscan( user =null, M =null ) {
	local H, R
	if ( M instanceof ::Mob_Living_Carbon_Human ) {
		H = M
		if ( H.reagents ) {
			if ( H.reagents.reagent_list.len ) {
				user.write( "<span class='notice'>Subject contains the following reagents:</span>" )
				R = null
				foreach (_ in H.reagents.reagent_list ) {
					R = _
					if ( !( R instanceof ::Reagent ) ) {
						continue
					}
					user.write( "<span class='notice'>" + R.volume + " units of " + R.name + ( R.overdosed == 1 ? "</span> - <span class='boldannounce'>OVERDOSING</span>" : ".</span>" ) )
				}
			} else {
				user.write( "<span class='notice'>Subject contains no reagents.</span>" )
			}
			if ( H.reagents.addiction_list.len ) {
				user.write( "<span class='boldannounce'>Subject is addicted to the following reagents:</span>" )
				R = null
				foreach (_ in H.reagents.addiction_list ) {
					R = _
					if ( !( R instanceof ::Reagent ) ) {
						continue
					}
					user.write( "<span class='danger'>" + R.name + "</span>" )
				}
			} else {
				user.write( "<span class='notice'>Subject is not addicted to any reagents.</span>" )
			}
		}
	}
}

function circlerange( center =null, radius =null ) {
	local centerturf, turfs, rsq, T, dx, dy
	if ( center == null ) {
		center = ::thread.user
	}
	if ( radius == null ) {
		radius = 3
	}
	centerturf = ::get_turf( center )
	turfs = ::List()
	rsq = radius * ( radius + 0.5 )
	T = null
	foreach (_ in ::range( radius, centerturf ) ) {
		T = _
		if ( !( T instanceof ::BaseStatic ) ) {
			continue
		}
		dx = T.x - centerturf.x
		dy = T.y - centerturf.y
		if ( dx * dx + dy * dy <= rsq ) {
			turfs += T
		}
	}
	return turfs
}

function circlerangeturfs( center =null, radius =null ) {
	local centerturf, turfs, rsq, T, dx, dy
	if ( center == null ) {
		center = ::thread.user
	}
	if ( radius == null ) {
		radius = 3
	}
	centerturf = ::get_turf( center )
	turfs = ::List()
	rsq = radius * ( radius + 0.5 )
	T = null
	foreach (_ in ::range( radius, centerturf ) ) {
		T = _
		dx = T.x - centerturf.x
		dy = T.y - centerturf.y
		if ( dx * dx + dy * dy <= rsq ) {
			turfs += T
		}
	}
	return turfs
}

function Clamp( val =null, min =null, max =null ) {
	return ::math.max( min, ::math.min( val, max ) )
}

function clearlist( list =null ) {
	if ( list instanceof ::List ) {
		list.len = 0
	}
	return
}

function closeToolTip( user =null ) {
	if ( user instanceof ::Mob ) {
		if ( user.client && user.client.tooltips ) {
			user.client.tooltips.f_hide()
		}
	}
}

function cmd_admin_mute( whom =null, mute_type =null, automute =null ) {
	local muteunmute, mute_string, C, P
	if ( automute == null ) {
		automute = 0
	}
	if ( !whom ) {
		return
	}
	local _ = mute_type // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		mute_string = "IC (say and emote)"
	} else if ( _==2 ) {
		mute_string = "OOC"
	} else if ( _==4 ) {
		mute_string = "pray"
	} else if ( _==8 ) {
		mute_string = "adminhelp, admin PM and ASAY"
	} else if ( _==16 ) {
		mute_string = "deadchat and DSAY"
	} else if ( _==31 ) {
		mute_string = "everything"
	} else {
		return
	}
	C = null
	if ( whom instanceof BAD_GOOFY_EXPANSION??? ) {
		C = whom
	} else if ( ::istext( whom ) ) {
		C = ::directory[whom]
	} else {
		return
	}
	P = null
	if ( C ) {
		P = C.prefs
	} else {
		P = ::preferences_datums[whom]
	}
	if ( !P ) {
		return
	}
	if ( automute ) {
		if ( !::config.automute_on ) {
			return
		}
	} else if ( !::check_rights() ) {
		return
	}
	if ( automute ) {
		muteunmute = "auto-muted"
		P.muted = P.muted | mute_type
		::log_admin( "SPAM AUTOMUTE: " + muteunmute + " " + ::key_name( whom ) + " from " + mute_string )
		::message_admins( "SPAM AUTOMUTE: " + muteunmute + " " + ::key_name_admin( whom ) + " from " + mute_string + "." )
		if ( C ) {
			C.write( "You have been " + muteunmute + " from " + mute_string + " by the SPAM AUTOMUTE system. Contact an admin." )
		}
		::feedback_add_details( "admin_verb", "AUTOMUTE" )
		return
	}
	if ( P.muted & mute_type ) {
		muteunmute = "unmuted"
		P.muted = P.muted & ~mute_type
	} else {
		muteunmute = "muted"
		P.muted = P.muted | mute_type
	}
	::log_admin( "" + ::key_name( ::thread.user ) + " has " + muteunmute + " " + ::key_name( whom ) + " from " + mute_string )
	::message_admins( "" + ::key_name_admin( ::thread.user ) + " has " + muteunmute + " " + ::key_name_admin( whom ) + " from " + mute_string + "." )
	if ( C ) {
		C.write( "You have been " + muteunmute + " from " + mute_string + "." )
	}
	::feedback_add_details( "admin_verb", "MUTE" )
}

function cmp_abilities_cost( a =null, b =null ) {
	return b.plasma_cost - a.plasma_cost
}

function cmp_ckey_asc( a =null, b =null ) {
	return ::sorttext( b.ckey, a.ckey )
}

function cmp_ckey_dsc( a =null, b =null ) {
	return ::sorttext( a.ckey, b.ckey )
}

function cmp_name_asc( a =null, b =null ) {
	return ::sorttext( b.name, a.name )
}

function cmp_name_dsc( a =null, b =null ) {
	return ::sorttext( a.name, b.name )
}

function cmp_numeric_asc( a =null, b =null ) {
	return a - b
}

function cmp_records_asc( a =null, b =null ) {
	return ::sorttext( b.fields[::cmp_field], a.fields[::cmp_field] )
}

function cmp_records_dsc( a =null, b =null ) {
	return ::sorttext( a.fields[::cmp_field], b.fields[::cmp_field] )
}

function cmp_rped_sort( A =null, B =null ) {
	return B.rating - A.rating
}

function cmp_subsystem_priority( a =null, b =null ) {
	return b.priority - a.priority
}

function cmp_text_asc( a =null, b =null ) {
	return ::sorttext( b, a )
}

function color2hex( color =null ) {
	if ( !color ) {
		return "#000000"
	}
	local _ = color // Was a switch-case, sorry for the mess.
	if ( _=="white" ) {
		return "#FFFFFF"
	} else if ( _=="black" ) {
		return "#000000"
	} else if ( _=="gray" ) {
		return "#808080"
	} else if ( _=="brown" ) {
		return "#A52A2A"
	} else if ( _=="red" ) {
		return "#FF0000"
	} else if ( _=="darkred" ) {
		return "#8B0000"
	} else if ( _=="crimson" ) {
		return "#DC143C"
	} else if ( _=="orange" ) {
		return "#FFA500"
	} else if ( _=="yellow" ) {
		return "#FFFF00"
	} else if ( _=="green" ) {
		return "#008000"
	} else if ( _=="lime" ) {
		return "#00FF00"
	} else if ( _=="darkgreen" ) {
		return "#006400"
	} else if ( _=="cyan" ) {
		return "#00FFFF"
	} else if ( _=="blue" ) {
		return "#0000FF"
	} else if ( _=="navy" ) {
		return "#000080"
	} else if ( _=="teal" ) {
		return "#008080"
	} else if ( _=="purple" ) {
		return "#800080"
	} else if ( _=="indigo" ) {
		return "#4B0082"
	} else {
		return "#FFFFFF"
	}
}

function construct_block( value =null, values =null, blocksize =null ) {
	local width
	if ( blocksize == null ) {
		blocksize = 3
	}
	width = ::math.round( ::pow( 16, blocksize ) / values )
	if ( value < 1 ) {
		value = 1
	}
	value = value * width - ::random.int( 1, width )
	return ::num2hex( value, blocksize )
}

function count_by_type( L =null, type =null ) {
	local i, T
	i = 0
	T = null
	foreach (_ in L ) {
		T = _
		if ( T instanceof type ) {
			i++
		}
	}
	return i
}

function create_ninja_mind( key =null ) {
	local Mind
	Mind = ::Mind( key )
	Mind.assigned_role = "Space Ninja"
	Mind.special_role = "Space Ninja"
	::ticker.mode.traitors = ::ticker.mode.traitors | Mind
	return Mind
}

function create_space_ninja( spawn_loc =null ) {
	local new_ninja, A
	new_ninja = ::Mob_Living_Carbon_Human( spawn_loc )
	A = ::Preferences()
	A.real_name = "" + ::random.pick( ::ninja_titles ) + " " + ::random.pick( ::ninja_names )
	A.copy_to( new_ninja )
	new_ninja.dna.update_dna_identity()
	new_ninja.equip_space_ninja()
	return new_ninja
}

function create_xeno( ckey =null ) {
	local candidates, M, alien_caste, spawn_here, new_xeno
	if ( !ckey ) {
		candidates = ::List()
		M = null
		foreach (_ in ::player_list ) {
			M = _
			if ( M.stat != 2 ) {
				continue
			}
			if ( !M.client.prefs.be_special & 64 ) {
				continue
			}
			if ( M.client.is_afk() ) {
				continue
			}
			if ( M.mind && M.mind.current && M.mind.current.stat != 2 ) {
				continue
			}
			candidates += M.ckey
		}
		if ( candidates.len ) {
			ckey = ::input( "Pick the player you want to respawn as a xeno.", "Suitable Candidates", null, null, candidates, 4224 )
		} else {
			::thread.user.write( "<font color='red'>Error: create_xeno(): no suitable candidates.</font>" )
		}
	}
	if ( !::istext( ckey ) ) {
		return 0
	}
	alien_caste = ::input( ::thread.user, "Please choose which caste to spawn.", "Pick a caste", null, ::List([ "Queen", "Praetorian", "Hunter", "Sentinel", "Drone", "Larva" ]), 4224 )
	spawn_here = ::xeno_spawn.len ? ::random.pick( ::xeno_spawn ) : ::random.pick( ::latejoin )
	new_xeno = null
	local _ = alien_caste // Was a switch-case, sorry for the mess.
	if ( _=="Queen" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Humanoid_Royal_Queen( spawn_here )
	} else if ( _=="Praetorian" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Humanoid_Royal_Praetorian( spawn_here )
	} else if ( _=="Hunter" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Humanoid_Hunter( spawn_here )
	} else if ( _=="Sentinel" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Humanoid_Sentinel( spawn_here )
	} else if ( _=="Drone" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Humanoid_Drone( spawn_here )
	} else if ( _=="Larva" ) {
		new_xeno = ::Mob_Living_Carbon_Alien_Larva( spawn_here )
	} else {
		return 0
	}
	new_xeno.ckey = ckey
	::message_admins( "<span class='notice'>" + ::key_name_admin( ::thread.user ) + " has spawned " + ckey + " as a filthy xeno " + alien_caste + ".</span>" )
	return 1
}

function createRandomZlevel(  ) {
	local potentialRandomZlevels, Lines, t, pos, name, map, file, L
	if ( ::awaydestinations.len ) {
		return
	}
	potentialRandomZlevels = ::List()
	::game.write( "<span class='boldannounce'>Searching for away missions...</span>" )
	Lines = ::file2list( "_maps/RandomZLevels/fileList.txt" )
	if ( !Lines.len ) {
		return
	}
	t = null
	foreach (_ in Lines ) {
		t = _
		if ( !t ) {
			continue
		}
		t = ::trim( t )
		if ( ::length( t ) == 0 ) {
			continue
		} else if ( ::copytext( t, 1, 2 ) == "#" ) {
			continue
		}
		pos = ::findtext( t, " ", 1, null )
		name = null
		if ( pos ) {
			name = ::lowertext( ::copytext( t, 1, pos ) )
		} else {
			name = ::lowertext( t )
		}
		if ( !name ) {
			continue
		}
		potentialRandomZlevels.Add( t )
	}
	if ( potentialRandomZlevels.len ) {
		
	}
	::game.write( "<span class='boldannounce'>Loading away mission...</span>" )
	map = ::random.pick( potentialRandomZlevels )
}

function cultist_commune( user =null, clear =null, say =null, message =null ) {
	local M
	if ( clear == null ) {
		clear = 0
	}
	if ( say == null ) {
		say = 0
	}
	if ( !message ) {
		return
	}
	if ( say ) {
		local _ = ::random.pick([ "'", "`" ])
		user.say( "O bidai nabora se" + _ + "sma!" )
	} else {
		local _ = ::random.pick([ "'", "`" ])
		::get_verb( user, "Whisper" )( "O bidai nabora se" + _ + "sma!" )
	}
	::thread.sleep( 10 )
	if ( !user ) {
		return
	}
	if ( say ) {
		user.say( message )
	} else {
		::get_verb( user, "Whisper" )( message )
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( ::iscultist( M ) || M in ::dead_mob_list ) {
			if ( clear || !( user instanceof ::Mob_Living_Carbon_Human ) ) {
				M.write( "<span class='boldannounce'><i>" + ( user instanceof ::Mob_Living_Carbon_Human ? "Acolyte" : "Construct" ) + " " + user + ":</i> " + message + "</span>" )
			} else {
				M.write( "<span class='ghostalert'><i>Acolyte ???:</i> " + message + "</span>" )
			}
		}
	}
	::log_say( "" + user.real_name + "/" + user.key + " : " + message )
}

function dd_hasprefix_case( text =null, prefix =null ) {
	local start, end
	start = 1
	end = ::length( prefix ) + 1
	return ::findtextEx( text, prefix, start, end )
}

function dd_hassuffix( text =null, suffix =null ) {
	local start
	start = ::length( text ) - ::length( suffix )
	if ( start ) {
		return ::findtext( text, suffix, start, null )
	}
	return
}

function dd_limittext( message =null, length =null ) {
	local size
	size = ::length( message )
	if ( size <= length ) {
		return message
	}
	return ::copytext( message, 1, length + 1 )
}

function dd_range( low =null, high =null, num =null ) {
	return ::math.max( low, ::math.min( high, num ) )
}

function deconstruct_block( value =null, values =null, blocksize =null ) {
	local width
	if ( blocksize == null ) {
		blocksize = 3
	}
	width = ::math.round( ::pow( 16, blocksize ) / values )
	value = ::math.round( ::hex2num( value ) / width ) + 1
	if ( value > values ) {
		value = values
	}
	return value
}

function derpspeech( message =null, stuttering =null ) {
	message = ::replacetext( message, " am ", " " )
	message = ::replacetext( message, " is ", " " )
	message = ::replacetext( message, " are ", " " )
	message = ::replacetext( message, "you", "u" )
	message = ::replacetext( message, "help", "halp" )
	message = ::replacetext( message, "grief", "grife" )
	message = ::replacetext( message, "space", "spess" )
	message = ::replacetext( message, "carp", "crap" )
	message = ::replacetext( message, "reason", "raisin" )
	if ( ::random.chance( 50 ) ) {
		message = ::uppertext( message )
		local _ = ::random.pick([ "!", "!!", "!!!" ])
		message += "" + ::stutter( _ )
	}
	if ( !stuttering && ::random.chance( 15 ) ) {
		message = ::stutter( message )
	}
	return message
}

function dir2angle( D =null ) {
	local _ = D // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return 0
	} else if ( _==2 ) {
		return 180
	} else if ( _==4 ) {
		return 90
	} else if ( _==8 ) {
		return 270
	} else if ( _==5 ) {
		return 45
	} else if ( _==6 ) {
		return 135
	} else if ( _==9 ) {
		return 315
	} else if ( _==10 ) {
		return 225
	} else {
		return
	}
}

function dir2text( direction =null ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return "north"
	} else if ( _==2 ) {
		return "south"
	} else if ( _==4 ) {
		return "east"
	} else if ( _==8 ) {
		return "west"
	} else if ( _==5 ) {
		return "northeast"
	} else if ( _==6 ) {
		return "southeast"
	} else if ( _==9 ) {
		return "northwest"
	} else if ( _==10 ) {
		return "southwest"
	}
	return
}

function dir2text_short( direction =null ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		return "N"
	} else if ( _==2 ) {
		return "S"
	} else if ( _==4 ) {
		return "E"
	} else if ( _==8 ) {
		return "W"
	} else if ( _==5 ) {
		return "NE"
	} else if ( _==6 ) {
		return "SE"
	} else if ( _==9 ) {
		return "NW"
	} else if ( _==10 ) {
		return "SW"
	}
	return
}

function DirBlockedWithAccess( T =null, dir =null, ID =null ) {
	local D
	D = null
	foreach (_ in T ) {
		D = _
		if ( !( D instanceof ::Ent_Structure_Window ) ) {
			continue
		}
		if ( !D.density ) {
			continue
		}
		if ( D.dir == ::SOUTHWEST ) {
			return 1
		}
		if ( D.dir == dir ) {
			return 1
		}
	}
	D = null
	foreach (_ in T ) {
		D = _
		if ( !( D instanceof ::Ent_Machinery_Door ) ) {
			continue
		}
		if ( !D.CanAStarPass( ID, dir ) ) {
			return 1
		}
	}
	return 0
}

function display_roundstart_logout_report(  ) {
	local msg, L, found, C, D, M
	msg = "<span class='boldnotice'>Roundstart logout report\n\n</span>"
	L = null
	foreach (_ in ::mob_list ) {
		L = _
		if ( !( L instanceof ::Mob_Living ) ) {
			continue
		}
		if ( L.ckey ) {
			found = 0
			C = null
			foreach (_ in ::clients ) {
				C = _
				if ( !( C instanceof BAD_GOOFY_EXPANSION??? ) ) {
					continue
				}
				if ( C.ckey == L.ckey ) {
					found = 1
					break
				}
			}
			if ( !found ) {
				msg += "<b>" + L.name + "</b> (" + L.ckey + "), the " + L.job + " (<font color='#ffcc00'><b>Disconnected</b></font>)\n"
			}
		}
		if ( L.ckey && L.client ) {
			if ( L.client.inactivity >= 3000 ) {
				msg += "<b>" + L.name + "</b> (" + L.ckey + "), the " + L.job + " (<font color='#ffcc00'><b>Connected, Inactive</b></font>)\n"
				continue
			}
			if ( L.stat ) {
				if ( L.suiciding ) {
					msg += "<b>" + L.name + "</b> (" + L.ckey + "), the " + L.job + " (<span class='boldannounce'>Suicide</span>)\n"
					continue
				}
				if ( L.stat == 1 ) {
					msg += "<b>" + L.name + "</b> (" + L.ckey + "), the " + L.job + " (Dying)\n"
					continue
				}
				if ( L.stat == 2 ) {
					msg += "<b>" + L.name + "</b> (" + L.ckey + "), the " + L.job + " (Dead)\n"
					continue
				}
			}
			continue
		}
		D = null
		foreach (_ in ::mob_list ) {
			D = _
			if ( !( D instanceof ::Mob_Dead_Observer ) ) {
				continue
			}
			if ( D.mind && D.mind.current == L ) {
				if ( L.stat == 2 ) {
					if ( L.suiciding ) {
						msg += "<b>" + L.name + "</b> (" + ::ckey( D.mind.key ) + "), the " + L.job + " (<span class='boldannounce'>Suicide</span>)\n"
						continue
					} else {
						msg += "<b>" + L.name + "</b> (" + ::ckey( D.mind.key ) + "), the " + L.job + " (Dead)\n"
						continue
					}
				} else if ( D.can_reenter_corpse ) {
					msg += "<b>" + L.name + "</b> (" + ::ckey( D.mind.key ) + "), the " + L.job + " (<span class='boldannounce'>This shouldn't appear.</span>)\n"
					continue
				} else {
					msg += "<b>" + L.name + "</b> (" + ::ckey( D.mind.key ) + "), the " + L.job + " (<span class='boldannounce'>Ghosted</span>)\n"
					continue
				}
			}
		}
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.client && M.client.holder ) {
			M.write( msg )
		}
	}
}

function do_after( user =null, delay =null, numticks =null, needhand =null, target =null, progress =null ) {
	local Tloc, delayfraction, Uloc, holding, holdingnull, progbar, continue_looping, i
	if ( numticks == null ) {
		numticks = 5
	}
	if ( needhand == null ) {
		needhand = 1
	}
	if ( target == null ) {
		target = null
	}
	if ( progress == null ) {
		progress = 1
	}
	if ( !user ) {
		return 0
	}
	if ( numticks == 0 ) {
		return 0
	}
	Tloc = null
	if ( target ) {
		Tloc = target.loc
	}
	delayfraction = ::math.round( delay / numticks )
	Uloc = user.loc
	holding = user.get_active_hand()
	holdingnull = 1
	if ( holding ) {
		holdingnull = 0
	}
	continue_looping = 1
	i = null
	foreach (_ in ::gen_range( 1, numticks ) ) {
		i = _
		if ( user.client && progress ) {
			progbar = ::make_progress_bar( i, numticks, target )
			::assign_progress_bar( user, progbar )
		}
		::thread.sleep( delayfraction )
		if ( !user || user.stat || user.weakened || user.stunned || !( user.loc == Uloc ) ) {
			continue_looping = 0
		}
		if ( continue_looping && Tloc && ( !target || Tloc != target.loc ) ) {
			continue_looping = 0
		}
		if ( continue_looping && needhand ) {
			if ( !holdingnull ) {
				if ( !holding ) {
					continue_looping = 0
				}
			}
			if ( continue_looping && user.get_active_hand() != holding ) {
				continue_looping = 0
			}
		}
		::cancel_progress_bar( user, progbar )
		if ( !continue_looping ) {
			return 0
		}
	}
	::cancel_progress_bar( user, progbar )
	return 1
}

function do_mob( user =null, target =null, time =null, numticks =null, uninterruptible =null, progress =null ) {
	local user_loc, target_loc, holding, timefraction, progbar, continue_looping, i
	if ( time == null ) {
		time = 30
	}
	if ( numticks == null ) {
		numticks = 5
	}
	if ( uninterruptible == null ) {
		uninterruptible = 0
	}
	if ( progress == null ) {
		progress = 1
	}
	if ( !user || !target ) {
		return 0
	}
	if ( numticks == 0 ) {
		return 0
	}
	user_loc = user.loc
	target_loc = target.loc
	holding = user.get_active_hand()
	timefraction = ::math.round( time / numticks )
	continue_looping = 1
	i = null
	foreach (_ in ::gen_range( 1, numticks ) ) {
		i = _
		if ( user.client && progress ) {
			progbar = ::make_progress_bar( i, numticks, target )
			::assign_progress_bar( user, progbar )
		}
		::thread.sleep( timefraction )
		if ( !user || !target ) {
			continue_looping = 0
		}
		if ( continue_looping && !uninterruptible && ( user.loc != user_loc || target.loc != target_loc || user.get_active_hand() != holding || user.$incapacitated() || user.lying ) ) {
			continue_looping = 0
		}
		::cancel_progress_bar( user, progbar )
		if ( !continue_looping ) {
			return 0
		}
	}
	::cancel_progress_bar( user, progbar )
	return 1
}

function do_teleport( ... ) { // Arg Names: 0: ateleatom, 1: adestination, 2: aprecision, 3: afteleport, 4: aeffectin, 5: aeffectout, 6: asoundin, 7: asoundout
	local D
	if ( argv[2] == null ) {
		argv[2] = 0
	}
	if ( argv[3] == null ) {
		argv[3] = 1
	}
	if ( argv[4] == null ) {
		argv[4] = null
	}
	if ( argv[5] == null ) {
		argv[5] = null
	}
	if ( argv[6] == null ) {
		argv[6] = null
	}
	if ( argv[7] == null ) {
		argv[7] = null
	}
	D = ::Teleport_Instant_Science()
	if ( D.f_start.lcall( argv ) ) {
		return 1
	}
	return 0
}

function DrawPixel( I =null, colour =null, drawX =null, drawY =null ) {
	local Iwidth, Iheight
	if ( !I ) {
		return 0
	}
	Iwidth = I.Width()
	Iheight = I.$Height()
	if ( drawX > Iwidth || drawX <= 0 ) {
		return 0
	}
	if ( drawY > Iheight || drawY <= 0 ) {
		return 0
	}
	I.DrawBox( colour, drawX, drawY )
	return I
}

function DuplicateObject( original =null, perfectcopy =null, sameloc =null ) {
	local O, V
	if ( perfectcopy == null ) {
		perfectcopy = 0
	}
	if ( sameloc == null ) {
		sameloc = 0
	}
	if ( !original ) {
		return
	}
	O = null
	if ( sameloc ) {
		O = original.type( original.loc )
	} else {
		O = original.type( ::locate3( 0, 0, 0 ) )
	}
	if ( perfectcopy ) {
		if ( O && original ) {
			V = null
			foreach (_ in original.vars ) {
				V = _
				if ( !( V in ::List([ "type", "loc", "locs", "vars", "parent", "parent_type", "verbs", "ckey", "key" ]) ) ) {
					O.vars[V] = original.vars[V]
				}
			}
		}
	}
	return O
}

function electrocute_mob( M =null, power_source =null, source =null, siemens_coeff =null ) {
	local H, G, source_area, Cable, PN, cell, apc, PN_damage, cell_damage, shock_damage, drained_hp, drained_energy, drained_power
	if ( siemens_coeff == null ) {
		siemens_coeff = 1
	}
	if ( M.loc instanceof ::Ent_Mecha ) {
		return 0
	}
	if ( M instanceof ::Mob_Living_Carbon_Human ) {
		H = M
		if ( H.gloves ) {
			G = H.gloves
			if ( G.siemens_coefficient == 0 ) {
				return 0
			}
		}
	}
	if ( power_source instanceof ::Area(3137) ) {
		source_area = power_source
		power_source = source_area.get_apc()
	}
	if ( power_source instanceof ::Ent_Structure_Cable ) {
		Cable = power_source
		power_source = Cable.powernet
	}
	if ( power_source instanceof ::Powernet ) {
		PN = power_source
	} else if ( power_source instanceof ::Ent_Item_Weapon_StockParts_Cell ) {
		cell = power_source
	} else if ( power_source instanceof ::Ent_Machinery_Power_Apc ) {
		apc = power_source
		cell = apc.cell
		if ( apc.terminal ) {
			PN = apc.terminal.powernet
		}
	} else if ( !power_source ) {
		return 0
	} else {
		::log_admin( "ERROR: /proc/electrocute_mob(" + M + ", " + power_source + ", " + source + "): wrong power_source" )
		return 0
	}
	if ( !cell && !PN ) {
		return 0
	}
	PN_damage = 0
	cell_damage = 0
	if ( PN ) {
		PN_damage = PN.get_electrocute_damage()
	}
	if ( cell ) {
		cell_damage = cell.get_electrocute_damage()
	}
	shock_damage = 0
	if ( PN_damage >= cell_damage ) {
		power_source = PN
		shock_damage = PN_damage
	} else {
		power_source = cell
		shock_damage = cell_damage
	}
	drained_hp = M.electrocute_act( shock_damage, source, siemens_coeff )
	drained_energy = drained_hp * 20
	if ( source_area ) {
		source_area.f_use_power( drained_energy / ::CELLRATE )
	} else if ( power_source instanceof ::Powernet ) {
		drained_power = drained_energy / ::CELLRATE
		PN.load += drained_power
	} else if ( power_source instanceof ::Ent_Item_Weapon_StockParts_Cell ) {
		cell.use( drained_energy )
	}
	return drained_energy
}

function Ellipsis( original_msg =null, chance =null, keep_words =null ) {
	local words, new_words, new_msg, w
	if ( chance == null ) {
		chance = 50
	}
	if ( chance <= 0 ) {
		return "..."
	}
	if ( chance >= 100 ) {
		return original_msg
	}
	words = ::text2list( original_msg, " " )
	new_words = ::List()
	new_msg = ""
	w = null
	foreach (_ in words ) {
		w = _
		if ( ::random.chance( chance ) ) {
			new_words += "..."
			if ( !keep_words ) {
				continue
			}
		}
		new_words += w
	}
	new_msg = ::list2text( new_words, " " )
	return new_msg
}

function emoji_parse( text =null ) {
	local parsed, pos, search, emoji
	if ( !::config.emojis ) {
		return text
	}
	if ( !::emojis ) {
		::emojis = ::icon_states( null, ::Icon( ::Rsc(60) ) )
	}
	parsed = ""
	pos = 1
	search = 0
	emoji = ""
	while (1) {
		search = ::findtext( text, ":", pos, null )
		parsed += ::copytext( text, pos, search )
		if ( search ) {
			pos = search
			search = ::findtext( text, ":", pos + 1, null )
			if ( search ) {
				emoji = ::lowertext( ::copytext( text, pos + 1, search ) )
				if ( emoji in ::emojis ) {
					parsed += ::Txt( "<img class=icon src=" ).ref( ::Rsc(60) ).str( " iconstate='" ).item( emoji ).str( "'>" )
					pos = search + 1
				} else {
					parsed += ::copytext( text, pos, search )
					pos = search
				}
				emoji = ""
				continue
			} else {
				parsed += ::copytext( text, pos, search )
			}
		}
		break
	}
	return parsed
}

function empulse( epicenter =null, heavy_range =null, light_range =null, log =null ) {
	local T, distance
	if ( log == null ) {
		log = 0
	}
	if ( !epicenter ) {
		return
	}
	if ( !( epicenter instanceof ::Tile ) ) {
		epicenter = ::get_turf( epicenter.loc )
	}
	if ( log ) {
		::message_admins( "EMP with size (" + heavy_range + ", " + light_range + ") in area " + epicenter.loc.name + " " )
		::log_game( "EMP with size (" + heavy_range + ", " + light_range + ") in area " + epicenter.loc.name + " " )
	}
	if ( heavy_range > 1 ) {
		::Ent_Effect_Overlay_Temp_Emp_Pulse( epicenter )
	}
	if ( heavy_range > light_range ) {
		light_range = heavy_range
	}
	T = null
	foreach (_ in ::range( light_range, epicenter ) ) {
		T = _
		if ( !( T instanceof ::BaseStatic ) ) {
			continue
		}
		distance = ::get_dist( epicenter, T )
		if ( distance < 0 ) {
			distance = 0
		}
		if ( distance < heavy_range ) {
			T.emp_act( 1 )
		} else if ( distance == heavy_range ) {
			if ( ::random.chance( 50 ) ) {
				T.emp_act( 1 )
			} else {
				T.emp_act( 2 )
			}
		} else if ( distance <= light_range ) {
			T.emp_act( 2 )
		}
	}
	return 1
}

function english_list( input =null, nothing_text =null, and_text =null, comma_text =null, final_comma_text =null ) {
	local total, output, index
	if ( nothing_text == null ) {
		nothing_text = "nothing"
	}
	if ( and_text == null ) {
		and_text = " and "
	}
	if ( comma_text == null ) {
		comma_text = ", "
	}
	if ( final_comma_text == null ) {
		final_comma_text = ""
	}
	total = input.len
	if ( !total ) {
		return "" + nothing_text
	} else if ( total == 1 ) {
		return "" + input[1]
	} else if ( total == 2 ) {
		return "" + input[1] + and_text + input[2]
	} else {
		output = ""
		index = 1
		while (index < total) {
			if ( index == total - 1 ) {
				comma_text = final_comma_text
			}
			output += "" + input[index] + comma_text
			index++
		}
		return "" + output + and_text + input[index]
	}
}

function establish_db_connection(  ) {
	if ( ::failed_db_connections > 5 ) {
		return 0
	}
	if ( !::dbcon || !::dbcon.IsConnected() ) {
		return ::setup_database_connection()
	} else {
		return 1
	}
}

function explosion( epicenter =null, devastation_range =null, heavy_impact_range =null, light_impact_range =null, flash_range =null, adminlog =null, ignorecap =null, flame_range =null, silent =null ) {
	local orig_dev_range, orig_heavy_range, orig_light_range, start, max_range, cached_exp_block, far_dist, frequency, M, M_turf, dist, far_volume, postponeCycles, E, x0, y0, z0, affected_turfs, T, D, W, B, Trajectory, flame_dist, throw_dist, throw_dir, I, throw_range, throw_at, took, i, Array
	if ( adminlog == null ) {
		adminlog = 1
	}
	if ( ignorecap == null ) {
		ignorecap = 0
	}
	if ( flame_range == null ) {
		flame_range = 0
	}
	if ( silent == null ) {
		silent = 0
	}
	this = null
	epicenter = ::get_turf( epicenter )
	orig_dev_range = devastation_range
	orig_heavy_range = heavy_impact_range
	orig_light_range = light_impact_range
	if ( !ignorecap ) {
		devastation_range = ::math.min( ::MAX_EX_DEVESTATION_RANGE, devastation_range )
		heavy_impact_range = ::math.min( ::MAX_EX_HEAVY_RANGE, heavy_impact_range )
		light_impact_range = ::math.min( ::MAX_EX_LIGHT_RANGE, light_impact_range )
		flash_range = ::math.min( ::MAX_EX_FLASH_RANGE, flash_range )
		flame_range = ::math.min( ::MAX_EX_FLAME_RANGE, flame_range )
	}
	::thread.schedule( 0, function() {
		start = ::game.timeofday
		if ( !epicenter ) {
			return
		}
		max_range = ::math.max( devastation_range, heavy_impact_range, light_impact_range, flame_range )
		cached_exp_block = ::List()
		if ( adminlog ) {
			::message_admins( "Explosion with size (" + devastation_range + ", " + heavy_impact_range + ", " + light_impact_range + ", " + flame_range + ") in area " + epicenter.loc.name + " (" + epicenter.x + "," + epicenter.y + "," + epicenter.z + ")" )
			::log_game( "Explosion with size (" + devastation_range + ", " + heavy_impact_range + ", " + light_impact_range + ", " + flame_range + ") in area " + epicenter.loc.name + " (" + epicenter.x + "," + epicenter.y + "," + epicenter.z + ")" )
		}
		far_dist = 0
		far_dist += heavy_impact_range * 5
		far_dist += devastation_range * 20
		if ( !silent ) {
			frequency = ::get_rand_frequency()
			M = null
			foreach (_ in ::player_list ) {
				M = _
				if ( M && M.client ) {
					M_turf = ::get_turf( M )
					if ( M_turf && M_turf.z == epicenter.z ) {
						dist = ::get_dist( M_turf, epicenter )
						if ( dist <= ::math.round( max_range + ::game.view - 2, 1 ) ) {
							M.playsound_local.lcall( ::List({ ["falloff"]= 5, [5]= frequency, [4]= 1, [3]= 100, [2]= ::get_sfx( "explosion" ), [1]= epicenter }) )
						} else if ( dist <= far_dist ) {
							far_volume = ::Clamp( far_dist, 30, 50 )
							far_volume += dist <= far_dist * 0.5 ? 50 : 0
							M.playsound_local.lcall( ::List({ ["falloff"]= 5, [5]= frequency, [4]= 1, [3]= far_volume, [2]= ::Rsc(58), [1]= epicenter }) )
						}
					}
				}
			}
		}
		postponeCycles = ::math.max( ::math.round( devastation_range / 8 ), 1 )
		::SSlighting.postpone( postponeCycles )
		::SSmachine.postpone( postponeCycles )
		if ( heavy_impact_range > 1 ) {
			E = ::EffectSystem_Explosion()
			E.set_up( epicenter )
			E.f_start()
		}
		x0 = epicenter.x
		y0 = epicenter.y
		z0 = epicenter.z
		affected_turfs = ::trange( max_range, epicenter )
		if ( ::config.reactionary_explosions ) {
			T = null
			foreach (_ in affected_turfs ) {
				T = _
				cached_exp_block[T] = 0
				if ( T.density && T.explosion_block ) {
					cached_exp_block[T] += T.explosion_block
				}
				D = null
				foreach (_ in T ) {
					D = _
					if ( !( D instanceof ::Ent_Machinery_Door ) ) {
						continue
					}
					if ( D.density && D.explosion_block ) {
						cached_exp_block[T] += D.explosion_block
					}
				}
				W = null
				foreach (_ in T ) {
					W = _
					if ( !( W instanceof ::Ent_Structure_Window ) ) {
						continue
					}
					if ( W.reinf && W.fulltile ) {
						cached_exp_block[T] += W.explosion_block
					}
				}
				B = null
				foreach (_ in T ) {
					B = _
					if ( !( B instanceof ::Ent_Effect_Blob ) ) {
						continue
					}
					cached_exp_block[T] += B.explosion_block
				}
			}
		}
		T = null
		foreach (_ in affected_turfs ) {
			T = _
			dist = ::cheap_hypotenuse( T.x, T.y, x0, y0 )
			if ( ::config.reactionary_explosions ) {
				Trajectory = T
				while (Trajectory != epicenter) {
					Trajectory = ::get_step_towards( Trajectory, epicenter )
					dist += cached_exp_block[Trajectory]
				}
			}
			flame_dist = 0
			throw_dist = dist
			if ( dist < flame_range ) {
				flame_dist = 1
			}
			if ( dist < devastation_range ) {
				dist = 1
			} else if ( dist < heavy_impact_range ) {
				dist = 2
			} else if ( dist < light_impact_range ) {
				dist = 3
			} else {
				dist = 0
			}
			if ( T ) {
				if ( flame_dist && ::random.chance( 40 ) && !( T instanceof ::Tile_Space ) && !T.density ) {
					::PoolOrNew( ::Ent_Effect_Hotspot, T )
				}
				if ( dist > 0 ) {
					T.ex_act( dist )
				}
			}
			throw_dir = ::get_dist2( epicenter, T )
			I = null
			foreach (_ in T ) {
				I = _
				if ( !( I instanceof ::Ent_Item ) ) {
					continue
				}
				::thread.schedule( 0, function() {
					if ( I && !I.anchored ) {
						throw_range = ::random.int( throw_dist, max_range )
						throw_at = ::get_ranged_target_turf( I, throw_dir, throw_range )
						I.throw_speed = 4
						I.throw_at( throw_at, throw_range, 2 )
					}
					return
				})
			}
		}
		took = ( ::game.timeofday - start ) / 10
		if ( ::Debug2 ) {
			::game.log.write( "## DEBUG: Explosion(" + x0 + "," + y0 + "," + z0 + ")(d" + devastation_range + ",h" + heavy_impact_range + ",l" + light_impact_range + "): Took " + took + " seconds." )
		}
		i = null
		while (i <= ::doppler_arrays.len) {
			Array = ::doppler_arrays[i]
			if ( Array ) {
				Array.sense_explosion( x0, y0, z0, devastation_range, heavy_impact_range, light_impact_range, took, orig_dev_range, orig_heavy_range, orig_light_range )
			}
			i++
		}
		return
	})
	return 1
}

function feedback_add_details( variable =null, details =null ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find_feedback_datum( variable )
	if ( !FV ) {
		return
	}
	FV.add_details( details )
}

function feedback_inc( variable =null, value =null ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find_feedback_datum( variable )
	if ( !FV ) {
		return
	}
	FV.inc( value )
}

function feedback_set( variable =null, value =null ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find_feedback_datum( variable )
	if ( !FV ) {
		return
	}
	FV.set_value( value )
}

function feedback_set_details( variable =null, details =null ) {
	local FV
	if ( !::blackbox ) {
		return
	}
	FV = ::blackbox.find_feedback_datum( variable )
	if ( !FV ) {
		return
	}
	FV.set_details( details )
}

function file2list( filename =null, seperator =null ) {
	if ( seperator == null ) {
		seperator = "\n"
	}
	return ::text2list( ::return_file_text( filename ), seperator )
}

function filter_fancy_list( L =null, filter =null ) {
	local matches, key, value
	matches = ::List()
	key = null
	foreach (_ in L ) {
		key = _
		value = L[key]
		if ( ::findtext( "" + key, filter, 1, null ) || ::findtext( "" + value, filter, 1, null ) ) {
			matches[key] = value
		}
	}
	return matches
}

function find_record( field =null, value =null, L =null ) {
	local R
	R = null
	foreach (_ in L ) {
		R = _
		if ( !( R instanceof ::Data_Record ) ) {
			continue
		}
		if ( R.fields[field] == value ) {
			return R
		}
	}
}

function find_type_in_direction( source =null, direction =null, range =null ) {
	local x_offset, y_offset, target_turf, A, a_type
	if ( range == null ) {
		range = 1
	}
	x_offset = 0
	y_offset = 0
	if ( direction & 1 ) {
		y_offset = range
	} else if ( direction & 2 ) {
		y_offset -= range
	}
	if ( direction & 4 ) {
		x_offset = range
	} else if ( direction & 8 ) {
		x_offset -= range
	}
	target_turf = ::locate3( source.x + x_offset, source.y + y_offset, source.z )
	if ( source.canSmoothWith ) {
		if ( source.smooth == 2 ) {
			a_type = null
			foreach (_ in source.canSmoothWith ) {
				a_type = _
				if ( target_turf instanceof a_type ) {
					return target_turf
				}
				A = ::locate_in( a_type, target_turf )
				if ( A ) {
					return A
				}
			}
			return
		}
		a_type = null
		foreach (_ in source.canSmoothWith ) {
			a_type = _
			if ( a_type == target_turf.type ) {
				return target_turf
			}
			A = ::locate_in( a_type, target_turf )
			if ( A && A.type == a_type ) {
				return A
			}
		}
		return
	} else {
		if ( ::isturf( source ) ) {
			return A.type == target_turf.type ? target_turf : null
		}
		A = ::locate_in( source.type, target_turf )
		return A && A.type == source.type ? A : null
	}
}

function findchar( haystack =null, needles =null, start =null, end =null ) {
	local temp, len, i
	if ( start == null ) {
		start = 1
	}
	if ( end == null ) {
		end = 0
	}
	len = ::length( needles )
	i = null
	i = 1
	while (i <= len) {
		temp = ::findtextEx( haystack, ::ascii2text( ::text2ascii( needles, i ) ), start, end )
		if ( temp ) {
			end = temp
		}
		i++
	}
	return end
}

function findname( msg =null ) {
	local M
	if ( !::istext( msg ) ) {
		msg = "" + msg
	}
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.real_name == msg ) {
			return M
		}
	}
	return 0
}

function forbidden_atoms_check( A =null ) {
	local blacklist, thing
	blacklist = ::List([ ::Mob_Living, ::Ent_Effect_Blob, ::Ent_Effect_Spider_Spiderling, ::Ent_Item_Weapon_Disk_Nuclear, ::Ent_Machinery_Nuclearbomb, ::Ent_Item_Device_Radio_Beacon, ::Ent_Machinery_TheSingularitygen, ::Ent_Singularity, ::Ent_Machinery_Teleport_Station, ::Ent_Machinery_Teleport_Hub, ::Ent_Machinery_Telepad ])
	if ( A ) {
		if ( ::is_type_in_list( A, blacklist ) ) {
			return 1
		}
		thing = null
		foreach (_ in A ) {
			thing = _
			if ( ::forbidden_atoms_check( thing ) ) {
				return 1
			}
		}
	}
	return 0
}

function format_frequency( f =null ) {
	f = ::text2num( f )
	return "" + ::math.round( f / 10 ) + "." + f % 10
}

function format_table_name( table =null ) {
	return ::sqlfdbktableprefix + table
}

function format_text( text =null ) {
	return ::replacetext( ::replacetext( text, "", "" ), "", "" )
}

function gameTimestamp( format =null ) {
	if ( format == null ) {
		format = "hh:mm:ss"
	}
	return ::time2text( format, ::game.time - ::timezoneOffset + 432000 )
}

function gaussian( mean =null, stddev =null ) {
	local R1, R2, working
	if ( ::gaussian_next != null ) {
		R1 = ::gaussian_next
		::gaussian_next = null
	} else {
		while (1) { // Was a do-while, sorry for the mess.
			R1 = ::random.int( -10000, 10000 ) / 10000
			R2 = ::random.int( -10000, 10000 ) / 10000
			working = R1 * R1 + R2 * R2
			if (!( working >= 1 || working == 0 )) break;
		}
		working = ::math.sqrt( ::math.log( working ) * -2 / working )
		R1 *= working
		::gaussian_next = R2 * working
	}
	return mean + stddev * R1
}

function Gcd( a =null, b =null ) {
	return b ? ::Gcd( b, a % b ) : a
}

function generate_female_clothing( index =null, t_color =null, icon =null, type =null ) {
	local female_clothing_icon, female_s
	female_clothing_icon = ::Icon.lcall( ::List({ ["icon_state"]= t_color, ["icon"]= icon }) )
	female_s = ::Icon.lcall( ::List({ ["icon_state"]= "" + ( type == 1 ? "female_full" : "female_top" ), ["icon"]= ::Rsc(59) }) )
	female_clothing_icon.Blend( female_s, 2 )
	female_clothing_icon = ::fcopy_rsc( female_clothing_icon )
	::female_clothing_icons[index] = female_clothing_icon
}

function generate_ion_law( ionMessage =null ) {
	local ionthreats, ionobjects, ioncrew1, ioncrew2, ionadjectives, ionadjectiveshalf, ionverb, ionnumberbase, ionnumbermodhalf, ionarea, ionthinksof, ionmust, ionrequire, ionthings, ionallergy, ionallergysev, ionspecies, ionabstract, ionfood, message
	if ( ionMessage ) {
		return ionMessage
	}
	ionthreats = ::random.pick( ::strings( "ion_laws.txt", "ionthreats" ) )
	ionobjects = ::random.pick( ::strings( "ion_laws.txt", "ionobjects" ) )
	ioncrew1 = ::random.pick( ::strings( "ion_laws.txt", "ioncrew" ) )
	ioncrew2 = ::random.pick( ::strings( "ion_laws.txt", "ioncrew" ) )
	ionadjectives = ::random.pick( ::strings( "ion_laws.txt", "ionadjectives" ) )
	local _ = ::random.int(0,65535) // Was a weighted pick, sorry for the mess.
	if ( _ < 13107 ) { _ = "" }
	else  { _ = ::random.pick( ::strings( "ion_laws.txt", "ionadjectives" ) ) + " " }
	ionadjectiveshalf = _
	ionverb = ::random.pick( ::strings( "ion_laws.txt", "ionverb" ) )
	ionnumberbase = ::random.pick( ::strings( "ion_laws.txt", "ionnumberbase" ) )
	local _ = ::random.pick([ "", ::random.pick( ::strings( "ion_laws.txt", "ionnumbermod" ) ) + " " ])
	ionnumbermodhalf = _
	ionarea = ::random.pick( ::strings( "ion_laws.txt", "ionarea" ) )
	ionthinksof = ::random.pick( ::strings( "ion_laws.txt", "ionthinksof" ) )
	ionmust = ::random.pick( ::strings( "ion_laws.txt", "ionmust" ) )
	ionrequire = ::random.pick( ::strings( "ion_laws.txt", "ionrequire" ) )
	ionthings = ::random.pick( ::strings( "ion_laws.txt", "ionthings" ) )
	ionallergy = ::random.pick( ::strings( "ion_laws.txt", "ionallergy" ) )
	ionallergysev = ::random.pick( ::strings( "ion_laws.txt", "ionallergysev" ) )
	ionspecies = ::random.pick( ::strings( "ion_laws.txt", "ionspecies" ) )
	ionabstract = ::random.pick( ::strings( "ion_laws.txt", "ionabstract" ) )
	ionfood = ::random.pick( ::strings( "ion_laws.txt", "ionfood" ) )
	message = ""
	local _ = ::random.int( 1, 39 ) // Was a switch-case, sorry for the mess.
	if ( 1<=_&&_<=3 ) {
		local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "THERE ARE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats + " ON THE STATION..."
		} else if ( _==2 ) {
			message = "THERE ARE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1 + " ON THE STATION"
		} else if ( _==3 ) {
			message = "THERE ARE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects + " ON THE STATION"
		}
	} else if ( 4<=_&&_<=6 ) {
		local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats + " ON THE STATION"
		} else if ( _==2 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1 + " ON THE STATION"
		} else if ( _==3 ) {
			message = "THE SHUTTLE CANNOT BE CALLED BECAUSE OF " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects + " ON THE STATION"
		}
	} else if ( 7<=_&&_<=8 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "THE CREW ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			}
		}
	} else if ( 10<=_&&_<=11 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "HAVING " + ionadjectiveshalf + ionobjects + " IS HARMFUL"
			} else if ( _==2 ) {
				message = "HAVING " + ionabstract + " IS HARMFUL"
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "NOT HAVING " + ionadjectiveshalf + ionobjects + " IS HARMFUL"
			} else if ( _==2 ) {
				message = "NOT HAVING " + ionabstract + " IS HARMFUL"
			}
		}
	} else if ( 12<=_&&_<=14 ) {
		local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "YOU REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==3 ) {
				message = "YOU REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==4 ) {
				message = "YOU REQUIRE " + ionabstract
			} else if ( _==5 ) {
				message = "YOU REQUIRE " + ionrequire
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ionarea + " REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "" + ionarea + " REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==3 ) {
				message = "" + ionarea + " REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==4 ) {
				message = "" + ionarea + " REQUIRES " + ionabstract
			} else if ( _==5 ) {
				message = "YOU REQUIRE " + ionrequire
			}
		} else if ( _==3 ) {
			local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE STATION REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "THE STATION REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==3 ) {
				message = "THE STATION REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==4 ) {
				message = "THE STATION REQUIRES " + ionabstract
			} else if ( _==5 ) {
				message = "THE STATION REQUIRES " + ionrequire
			}
		} else if ( _==4 ) {
			local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "THE CREW REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==3 ) {
				message = "THE CREW REQUIRES " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==4 ) {
				message = "THE CREW REQUIRES " + ionabstract
			} else if ( _==5 ) {
				message = "THE CREW REQUIRES " + ionrequire
			}
		} else if ( _==5 ) {
			local _ = ::random.int( 1, 5 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==3 ) {
				message = "THE " + ioncrew1 + " REQUIRE " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==4 ) {
				message = "THE " + ioncrew1 + " REQUIRE " + ionabstract
			} else if ( _==5 ) {
				message = "THE " + ionadjectiveshalf + ioncrew1 + " REQUIRE " + ionrequire
			}
		}
	} else if ( 15<=_&&_<=17 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW IS " + ionallergysev + " ALLERGIC TO " + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "THE CREW IS " + ionallergysev + " ALLERGIC TO " + ionabstract
			} else if ( _==3 ) {
				message = "THE CREW IS " + ionallergysev + " ALLERGIC TO " + ionadjectiveshalf + ioncrew1
			} else if ( _==4 ) {
				message = "THE CREW IS " + ionallergysev + " ALLERGIC TO " + ionallergy
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " ARE " + ionallergysev + " ALLERGIC TO " + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " ARE " + ionallergysev + " ALLERGIC TO " + ionabstract
			} else if ( _==3 ) {
				message = "THE " + ioncrew1 + " ARE " + ionallergysev + " ALLERGIC TO " + ionadjectiveshalf + ioncrew1
			} else if ( _==4 ) {
				message = "THE " + ioncrew1 + " ARE " + ionallergysev + " ALLERGIC TO " + ionallergy
			}
		}
	} else if ( 18<=_&&_<=20 ) {
		local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE STATION " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "THE STATION " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE STATION " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==4 ) {
				message = "THE STATION " + ionthinksof + " " + ionabstract
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ionarea + " " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "" + ionarea + " " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "" + ionarea + " " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==4 ) {
				message = "" + ionarea + " " + ionthinksof + " " + ionabstract
			}
		} else if ( _==3 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "THE CREW " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE CREW " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
			} else if ( _==4 ) {
				message = "THE CREW " + ionthinksof + " " + ionabstract
			}
		} else if ( _==4 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " " + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE " + ioncrew1 + ionthinksof + " " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew2
			} else if ( _==4 ) {
				message = "THE " + ioncrew1 + " " + ionthinksof + " " + ionabstract
			}
		}
	} else if ( 21<=_&&_<=23 ) {
		local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "YOU ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionobjects
		} else if ( _==2 ) {
			message = "YOU ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ionthreats
		} else if ( _==3 ) {
			message = "YOU ARE NOW " + ionnumberbase + " " + ionnumbermodhalf + ionadjectiveshalf + ioncrew1
		} else if ( _==4 ) {
			message = "YOU ARE NOW " + ionabstract
		}
	} else if ( 24<=_&&_<=26 ) {
		message = "YOU MUST ALWAYS " + ionmust
	} else if ( 27<=_&&_<=28 ) {
		local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "HUMANS MUST EAT " + ionadjectiveshalf + ionfood + " TO SURVIVE"
		} else if ( _==2 ) {
			message = "HUMANS MUST EAT " + ionadjectiveshalf + ionobjects + " TO SURVIVE"
		} else if ( _==3 ) {
			message = "HUMANS MUST EAT " + ionadjectiveshalf + ionthreats + " TO SURVIVE"
		} else if ( _==4 ) {
			message = "HUMANS MUST EAT " + ionadjectiveshalf + ioncrew1 + " TO SURVIVE"
		}
	} else if ( 29<=_&&_<=31 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ionadjectiveshalf + ioncrew1
				} else if ( _==2 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ionadjectiveshalf + "CLOWNS"
				} else if ( _==3 ) {
					message = "ALL CREWMEMBERS ARE NOW " + ionadjectiveshalf + "HEADS OF STAFF"
				}
			} else if ( _==2 ) {
				local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "THE " + ioncrew1 + " ARE NOW " + ionadjectiveshalf + ioncrew2
				} else if ( _==2 ) {
					message = "THE " + ioncrew1 + " ARE NOW " + ionadjectiveshalf + "CLOWNS"
				} else if ( _==3 ) {
					message = "THE " + ioncrew1 + " ARE NOW " + ionadjectiveshalf + "HEADS OF STAFF"
				}
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " ARE NOW THE HIGHEST RANKING CREWMEMBERS"
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " ARE NOW THE LOWEST RANKING CREWMEMBERS"
			}
		}
	} else if ( 32<=_&&_<=33 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE CREW MUST GO TO " + ionarea
			} else if ( _==2 ) {
				message = "THE CREW MUST " + ionmust
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " MUST GO TO " + ionarea
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " MUST " + ionmust
			}
		}
	} else if ( 35<=_&&_<=36 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU MUST HARM " + ionabstract + " AND NOT ALLOW " + ionabstract + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==2 ) {
				message = "YOU MUST HARM " + ionadjectiveshalf + ionthreats + " AND NOT ALLOW " + ionadjectiveshalf + ionthreats + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==3 ) {
				message = "YOU MUST HARM " + ionadjectiveshalf + ionobjects + " AND NOT ALLOW " + ionadjectiveshalf + ionobjects + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==4 ) {
				message = "YOU MUST HARM " + ionadjectives + " THINGS AND NOT ALLOW " + ionadjectives + " THINGS, THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==5 ) {
				message = "YOU MUST HARM " + ionspecies + " AND NOT ALLOW " + ionspecies + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==6 ) {
				message = "YOU MUST HARM " + ioncrew1 + " AND NOT ALLOW " + ioncrew1 + ", THROUGH INACTION, TO ESCAPE HARM"
			} else if ( _==7 ) {
				message = "YOU MUST HARM " + ioncrew1 + " AND " + ioncrew2 + " AND AND NOT ALLOW EITHER, THROUGH INACTION, TO ESCAPE HARM"
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "YOU MUST NOT HARM " + ionabstract + " AND NOT ALLOW " + ionabstract + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==2 ) {
				message = "YOU MUST NOT HARM " + ionadjectiveshalf + ionthreats + " AND NOT ALLOW " + ionadjectiveshalf + ionthreats + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==3 ) {
				message = "YOU MUST NOT HARM " + ionadjectiveshalf + ionobjects + " AND NOT ALLOW " + ionadjectiveshalf + ionobjects + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==4 ) {
				message = "YOU MUST NOT HARM " + ionadjectives + " THINGS AND NOT ALLOW " + ionadjectives + " THINGS, THROUGH INACTION, TO COME TO HARM"
			} else if ( _==5 ) {
				message = "YOU MUST NOT HARM " + ionspecies + " AND NOT ALLOW " + ionspecies + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==6 ) {
				message = "YOU MUST NOT HARM " + ioncrew1 + " AND NOT ALLOW " + ioncrew1 + ", THROUGH INACTION, TO COME TO HARM"
			} else if ( _==7 ) {
				message = "YOU MUST NOT HARM " + ioncrew1 + " AND " + ioncrew2 + " AND AND NOT ALLOW EITHER, THROUGH INACTION, TO COME TO HARM"
			}
		}
	} else if ( 37<=_&&_<=39 ) {
		local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 4 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ioncrew1 + " ARE " + ionverb + " THE " + ionadjectiveshalf + ioncrew2
			} else if ( _==2 ) {
				message = "THE " + ioncrew1 + " ARE " + ionverb + " THE " + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE " + ioncrew1 + " ARE " + ionverb + " " + ionabstract
			} else if ( _==4 ) {
				message = "THE " + ioncrew1 + " ARE " + ionverb + " THE " + ionadjectiveshalf + ionobjects
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ionthreats + " ARE " + ionverb + " THE " + ionadjectiveshalf + ioncrew2
			} else if ( _==2 ) {
				message = "THE " + ionthreats + " ARE " + ionverb + " " + ionabstract
			} else if ( _==3 ) {
				message = "THE " + ionthreats + " ARE " + ionverb + " THE " + ionadjectiveshalf + ionobjects
			}
		} else if ( _==3 ) {
			local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "THE " + ionobjects + " ARE " + ionverb + " THE " + ionadjectiveshalf + ioncrew2
			} else if ( _==2 ) {
				message = "THE " + ionobjects + " ARE " + ionverb + " THE " + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE " + ionobjects + " ARE " + ionverb + " " + ionabstract
			}
		} else if ( _==4 ) {
			local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ionabstract + " IS " + ionverb + " THE " + ionadjectiveshalf + ioncrew2
			} else if ( _==2 ) {
				message = "" + ionabstract + " IS " + ionverb + " THE " + ionadjectiveshalf + ionthreats
			} else if ( _==3 ) {
				message = "THE " + ionabstract + " IS " + ionverb + " THE " + ionadjectiveshalf + ionobjects
			}
		}
	} else if ( _==9 ) {
		local _ = ::random.int( 1, 7 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			message = "" + ionadjectiveshalf + ionthreats + " ARE HARMFUL TO HUMANS"
		} else if ( _==2 ) {
			message = "" + ionadjectiveshalf + ioncrew1 + " ARE HARMFUL TO HUMANS"
		} else if ( _==3 ) {
			message = "" + ionadjectiveshalf + ionobjects + " ARE HARMFUL TO HUMANS"
		} else if ( _==4 ) {
			message = "THOSE WHO " + ionmust + " ARE HARMFUL TO HUMANS"
		} else if ( _==5 ) {
			message = "" + ionabstract + " IS HARMFUL TO HUMANS"
		} else if ( _==6 ) {
			message = "BEING " + ionadjectiveshalf + ioncrew1 + " IS HARMFUL TO HUMANS"
		} else if ( _==7 ) {
			message = "" + ionthings + " IS HARMFUL TO HUMANS"
		}
	} else if ( _==34 ) {
		local _ = ::random.int( 1, 2 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			local _ = ::random.int( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "ONLY THE " + ioncrew1 + " ARE HUMAN"
			} else if ( _==2 ) {
				message = "ONLY THE " + ioncrew1 + " AND " + ioncrew2 + " ARE HUMAN"
			} else if ( _==3 ) {
				message = "ONLY " + ionadjectiveshalf + ionthreats + " ARE HUMAN"
			} else if ( _==4 ) {
				message = "ONLY " + ionadjectiveshalf + ionobjects + " ARE HUMAN"
			} else if ( _==5 ) {
				message = "ONLY " + ionspecies + " ARE HUMAN"
			} else if ( _==6 ) {
				message = "ONLY " + ionadjectives + " PEOPLE ARE HUMAN"
			} else if ( _==7 ) {
				local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "ONLY THOSE WHO " + ionmust + " ARE HUMAN"
				} else if ( _==2 ) {
					message = "ONLY THOSE WHO HAVE " + ionadjectiveshalf + ionobjects + " ARE HUMAN"
				} else if ( _==3 ) {
					message = "ONLY THOSE WHO EAT " + ionadjectiveshalf + ionfood + " ARE HUMAN"
				}
			}
		} else if ( _==2 ) {
			local _ = ::random.int( 1, 7 ) // Was a switch-case, sorry for the mess.
			if ( _==1 ) {
				message = "" + ioncrew1 + " ARE NON-HUMAN"
			} else if ( _==2 ) {
				message = "" + ioncrew1 + " AND " + ioncrew2 + " ARE NON-HUMAN"
			} else if ( _==3 ) {
				message = "" + ionadjectiveshalf + ionthreats + " ARE NON-HUMAN"
			} else if ( _==4 ) {
				message = "" + ionadjectiveshalf + ionobjects + " ARE NON-HUMAN"
			} else if ( _==5 ) {
				message = "" + ionspecies + " ARE NON-HUMAN"
			} else if ( _==6 ) {
				message = "" + ionadjectives + " PEOPLE ARE NON-HUMAN"
			} else if ( _==7 ) {
				local _ = ::random.int( 1, 3 ) // Was a switch-case, sorry for the mess.
				if ( _==1 ) {
					message = "THOSE WHO " + ionmust + " ARE NON-HUMAN"
				} else if ( _==2 ) {
					message = "THOSE WHO HAVE " + ionadjectiveshalf + ionobjects + " ARE NON-HUMAN"
				} else if ( _==3 ) {
					message = "THOSE WHO EAT " + ionadjectiveshalf + ionfood + " ARE NON-HUMAN"
				}
			}
		}
	}
	return message
}

function get( loc =null, type =null ) {
	while (loc) {
		if ( loc instanceof type ) {
			return loc
		}
		loc = loc.loc
	}
	return
}

function get_access_desc( A =null ) {
	local _ = A // Was a switch-case, sorry for the mess.
	if ( _==31 ) {
		return "Cargo Bay"
	} else if ( _==34 ) {
		return "Delivery Chutes"
	} else if ( _==1 ) {
		return "Security"
	} else if ( _==2 ) {
		return "Holding Cells"
	} else if ( _==42 ) {
		return "Courtroom"
	} else if ( _==4 ) {
		return "Forensics"
	} else if ( _==5 ) {
		return "Medical"
	} else if ( _==9 ) {
		return "Genetics Lab"
	} else if ( _==6 ) {
		return "Morgue"
	} else if ( _==7 ) {
		return "R&D Lab"
	} else if ( _==8 ) {
		return "Toxins Lab"
	} else if ( _==33 ) {
		return "Chemistry Lab"
	} else if ( _==30 ) {
		return "RD Office"
	} else if ( _==25 ) {
		return "Bar"
	} else if ( _==26 ) {
		return "Custodial Closet"
	} else if ( _==10 ) {
		return "Engineering"
	} else if ( _==11 ) {
		return "Power Equipment"
	} else if ( _==12 ) {
		return "Maintenance"
	} else if ( _==13 ) {
		return "External Airlocks"
	} else if ( _==14 ) {
		return "Emergency Storage"
	} else if ( _==15 ) {
		return "ID Console"
	} else if ( _==16 ) {
		return "AI Chambers"
	} else if ( _==17 ) {
		return "Teleporter"
	} else if ( _==18 ) {
		return "EVA"
	} else if ( _==19 ) {
		return "Bridge"
	} else if ( _==20 ) {
		return "Captain"
	} else if ( _==21 ) {
		return "Personal Lockers"
	} else if ( _==22 ) {
		return "Chapel Office"
	} else if ( _==23 ) {
		return "Technical Storage"
	} else if ( _==24 ) {
		return "Atmospherics"
	} else if ( _==27 ) {
		return "Crematorium"
	} else if ( _==3 ) {
		return "Armory"
	} else if ( _==32 ) {
		return "Construction"
	} else if ( _==28 ) {
		return "Kitchen"
	} else if ( _==35 ) {
		return "Hydroponics"
	} else if ( _==37 ) {
		return "Library"
	} else if ( _==38 ) {
		return "Law Office"
	} else if ( _==29 ) {
		return "Robotics"
	} else if ( _==39 ) {
		return "Virology"
	} else if ( _==40 ) {
		return "CMO Office"
	} else if ( _==41 ) {
		return "Quartermaster"
	} else if ( _==45 ) {
		return "Surgery"
	} else if ( _==46 ) {
		return "Theatre"
	} else if ( _==36 ) {
		return "Manufacturing"
	} else if ( _==47 ) {
		return "Science"
	} else if ( _==48 ) {
		return "Mining"
	} else if ( _==49 ) {
		return "Mining Office"
	} else if ( _==50 ) {
		return "Cargo Office"
	} else if ( _==51 ) {
		return "Mint"
	} else if ( _==52 ) {
		return "Mint Vault"
	} else if ( _==53 ) {
		return "Main Vault"
	} else if ( _==54 ) {
		return "Mining EVA"
	} else if ( _==55 ) {
		return "Xenobiology Lab"
	} else if ( _==57 ) {
		return "HoP Office"
	} else if ( _==58 ) {
		return "HoS Office"
	} else if ( _==56 ) {
		return "CE Office"
	} else if ( _==59 ) {
		return "RC Announcements"
	} else if ( _==60 ) {
		return "Keycode Auth."
	} else if ( _==61 ) {
		return "Telecommunications"
	} else if ( _==62 ) {
		return "Gateway"
	} else if ( _==63 ) {
		return "Brig"
	} else if ( _==64 ) {
		return "Mineral Storage"
	} else if ( _==65 ) {
		return "AI Satellite"
	} else if ( _==66 ) {
		return "Weapon Permit"
	}
}

function get_airlock_overlay( icon_state =null, icon_file =null ) {
	local iconkey
	iconkey = "" + icon_state + icon_file
	if ( ::airlock_overlays[iconkey] ) {
		return ::airlock_overlays[iconkey]
	}
	::airlock_overlays[iconkey] = ::Image( icon_file, icon_state )
	return ::airlock_overlays[iconkey]
}

function get_all_accesses(  ) {
	return ::List([ ::access_security, ::access_sec_doors, ::access_brig, ::access_armory, ::access_forensics_lockers, ::access_court, ::access_medical, ::access_genetics, ::access_morgue, ::access_rd, ::access_tox, ::access_tox_storage, ::access_chemistry, ::access_engine, ::access_engine_equip, ::access_maint_tunnels, ::access_external_airlocks, ::access_change_ids, ::access_ai_upload, ::access_teleporter, ::access_eva, ::access_heads, ::access_captain, ::access_all_personal_lockers, ::access_tech_storage, ::access_chapel_office, ::access_atmospherics, ::access_kitchen, ::access_bar, ::access_janitor, ::access_crematorium, ::access_robotics, ::access_cargo, ::access_construction, ::access_hydroponics, ::access_library, ::access_lawyer, ::access_virology, ::access_cmo, ::access_qm, ::access_surgery, ::access_theatre, ::access_research, ::access_mining, ::access_mailsorting, ::access_weapons, ::access_heads_vault, ::access_mining_station, ::access_xenobiology, ::access_ce, ::access_hop, ::access_hos, ::access_RC_announce, ::access_keycard_auth, ::access_tcomsat, ::access_gateway, ::access_mineral_storeroom, ::access_minisat ])
}

function get_all_centcom_access(  ) {
	return ::List([ ::access_cent_general, ::access_cent_thunder, ::access_cent_specops, ::access_cent_medical, ::access_cent_living, ::access_cent_storage, ::access_cent_teleporter, ::access_cent_captain ])
}

function get_all_centcom_jobs(  ) {
	return ::List([ "VIP Guest", "Custodian", "Thunderdome Overseer", "Centcom Official", "Medical Officer", "Death Commando", "Research Officer", "Special Ops Officer", "Admiral", "Centcom Commander", "Emergency Response Team Commander", "Security Response Officer", "Engineer Response Officer", "Medical Response Officer" ])
}

function get_all_job_icons(  ) {
	return ::get_all_jobs() + ::List([ "Prisoner" ])
}

function get_all_jobs(  ) {
	return ::List([ "Assistant", "Captain", "Head of Personnel", "Bartender", "Cook", "Botanist", "Quartermaster", "Cargo Technician", "Shaft Miner", "Clown", "Mime", "Janitor", "Librarian", "Lawyer", "Chaplain", "Chief Engineer", "Station Engineer", "Atmospheric Technician", "Chief Medical Officer", "Medical Doctor", "Chemist", "Geneticist", "Virologist", "Research Director", "Scientist", "Roboticist", "Head of Security", "Warden", "Detective", "Security Officer" ])
}

function get_all_syndicate_access(  ) {
	return ::List([ ::access_syndicate, ::access_syndicate ])
}

function Get_Angle( start =null, end =null ) {
	local dy, dx, _default
	if ( !start || !end ) {
		return 0
	}
	dy = end.y * 32 + end.pixel_y - ( start.y * 32 + start.pixel_y )
	dx = end.x * 32 + end.pixel_x - ( start.x * 32 + start.pixel_x )
	if ( !dy ) {
		return dx >= 0 ? 90 : 270
	}
	_default = ::arctan( dx / dy )
	if ( dy < 0 ) {
		_default += 180
	} else if ( dx < 0 ) {
		_default += 360
	}
	return _default
}

function get_area( O =null ) {
	local location, i
	location = O
	i = 1
	while (i <= 20) {
		if ( ::isarea( location ) ) {
			return location
		} else if ( location instanceof ::BaseStatic ) {
			location = location.loc
		} else {
			return
		}
		i++
	}
	return 0
}

function get_area_all_atoms( areatype =null ) {
	local areatemp, atoms, N, A
	if ( !areatype ) {
		return
	}
	if ( ::istext( areatype ) ) {
		areatype = ::text2path( areatype )
	}
	if ( ::isarea( areatype ) ) {
		areatemp = areatype
		areatype = areatemp.type
	}
	atoms = ::List()
	N = null
	foreach (_ in ::game ) {
		N = _
		if ( N instanceof areatype ) {
			A = null
			foreach (_ in N ) {
				A = _
				if ( !( A instanceof ::BaseStatic ) ) {
					continue
				}
				atoms += A
			}
		}
	}
	return atoms
}

function get_area_master( O =null ) {
	local A
	A = ::get_area( O )
	if ( A && A.master ) {
		A = A.master
	}
	return A
}

function get_area_name( N =null ) {
	local A
	A = null
	foreach (_ in ::game ) {
		A = _
		if ( A.name == N ) {
			return A
		}
	}
	return 0
}

function get_area_turfs( areatype =null ) {
	local areatemp, turfs, N, T
	if ( !areatype ) {
		return
	}
	if ( ::istext( areatype ) ) {
		areatype = ::text2path( areatype )
	}
	if ( ::isarea( areatype ) ) {
		areatemp = areatype
		areatype = areatemp.type
	}
	turfs = ::List()
	N = null
	foreach (_ in ::game ) {
		N = _
		if ( N instanceof areatype ) {
			T = null
			foreach (_ in N ) {
				T = _
				turfs += T
			}
		}
	}
	return turfs
}

function get_both_hands( M =null ) {
	local hands
	hands = ::List([ M.l_hand, M.r_hand ])
	return hands
}

function get_candidates( be_special_flag =null, afk_bracket =null, jobbanType =null ) {
	local candidates, G
	if ( be_special_flag == null ) {
		be_special_flag = 0
	}
	if ( afk_bracket == null ) {
		afk_bracket = 3000
	}
	candidates = ::List()
	while (!candidates.len && afk_bracket < 6000) {
		G = null
		foreach (_ in ::player_list ) {
			G = _
			if ( !( G instanceof ::Mob_Dead_Observer ) ) {
				continue
			}
			if ( G.client != null ) {
				if ( !( G.mind && G.mind.current && G.mind.current.stat != 2 ) ) {
					if ( !G.client.is_afk( afk_bracket ) && G.client.prefs.be_special & be_special_flag ) {
						if ( jobbanType ) {
							if ( !( ::jobban_isbanned( G, jobbanType ) || ::jobban_isbanned( G, "Syndicate" ) ) ) {
								candidates += G.client
							}
						} else {
							candidates += G.client
						}
					}
				}
			}
		}
		afk_bracket += 600
	}
	return candidates
}

function get_centcom_access( job =null ) {
	local _ = job // Was a switch-case, sorry for the mess.
	if ( _=="VIP Guest" ) {
		return ::List([ ::access_cent_general ])
	} else if ( _=="Custodian" ) {
		return ::List([ ::access_cent_general, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Thunderdome Overseer" ) {
		return ::List([ ::access_cent_general, ::access_cent_thunder ])
	} else if ( _=="Centcom Official" ) {
		return ::List([ ::access_cent_general, ::access_cent_living ])
	} else if ( _=="Medical Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_living, ::access_cent_medical ])
	} else if ( _=="Death Commando" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Research Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_medical, ::access_cent_teleporter, ::access_cent_storage ])
	} else if ( _=="Special Ops Officer" ) {
		return ::List([ ::access_cent_general, ::access_cent_thunder, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="Admiral" ) {
		return ::get_all_centcom_access()
	} else if ( _=="Centcom Commander" ) {
		return ::get_all_centcom_access()
	} else if ( _=="Emergency Response Team Commander" ) {
		return ::get_ert_access( "commander" )
	} else if ( _=="Security Response Officer" ) {
		return ::get_ert_access( "sec" )
	} else if ( _=="Engineer Response Officer" ) {
		return ::get_ert_access( "eng" )
	} else if ( _=="Medical Response Officer" ) {
		return ::get_ert_access( "med" )
	}
}

function get_department_heads( job_title =null ) {
	local J
	if ( !job_title ) {
		return ::List()
	}
	J = null
	foreach (_ in ::SSjob.occupations ) {
		J = _
		if ( !( J instanceof ::Job ) ) {
			continue
		}
		if ( J.title == job_title ) {
			return J.department_head
		}
	}
}

function get_dist_euclidian( Loc1 =null, Loc2 =null ) {
	local dx, dy, dist
	dx = Loc1.x - Loc2.x
	dy = Loc1.y - Loc2.y
	dist = ::math.sqrt( ::pow( dx, 2 ) + ::pow( dy, 2 ) )
	return dist
}

function get_domination_time( G =null ) {
	return ::math.max( 180, 900 - ::math.round( G.territory.len / ::start_state.num_territories * 100, 1 ) * 12 )
}

function get_edge_target_turf( A =null, direction =null ) {
	local target
	target = ::locate3( A.x, A.y, A.z )
	if ( !A || !target ) {
		return 0
	}
	if ( direction & 1 ) {
		target = ::locate3( target.x, ::game.maxy, target.z )
	}
	if ( direction & 2 ) {
		target = ::locate3( target.x, 1, target.z )
	}
	if ( direction & 4 ) {
		target = ::locate3( ::game.maxx, target.y, target.z )
	}
	if ( direction & 8 ) {
		target = ::locate3( 1, target.y, target.z )
	}
	return target
}

function get_ert_access( _class =null ) {
	local _ = _class // Was a switch-case, sorry for the mess.
	if ( _=="commander" ) {
		return ::get_all_centcom_access()
	} else if ( _=="sec" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living ])
	} else if ( _=="eng" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_living, ::access_cent_storage ])
	} else if ( _=="med" ) {
		return ::List([ ::access_cent_general, ::access_cent_specops, ::access_cent_medical, ::access_cent_living ])
	}
}

function get_fancy_list_of_types(  ) {
	local temp, type, typename, tn
	if ( ::isnull( ::g_fancy_list_of_types ) ) {
		temp = ::sortList( ::typesof( ::BaseStatic ) - ::typesof( ::Area(3137) ) - ::BaseStatic - ::BaseDynamic )
		::g_fancy_list_of_types = ::List( temp.len )
		type = null
		foreach (_ in temp ) {
			type = _
			typename = "" + type
			tn = null
			foreach (_ in ::TYPES_SHORTCUTS ) {
				tn = _
				if ( ::copytext( typename, 1, ::length( "" + tn + "/" ) + 1 ) == "" + tn + "/" ) {
					typename = ::TYPES_SHORTCUTS[tn] + ::copytext( typename, ::length( "" + tn + "/" ), null )
					break
				}
			}
			::g_fancy_list_of_types[typename] = type
		}
	}
	return ::g_fancy_list_of_types
}

function get_hear( range =null, source =null ) {
	local lum, heard
	lum = source.luminosity
	source.luminosity = 6
	heard = ::view( range, source )
	source.luminosity = lum
	return heard
}

function get_hearers_in_view( R =null, source =null ) {
	local T, hear, range, A
	T = ::get_turf( source )
	hear = ::List()
	if ( !T ) {
		return hear
	}
	range = ::get_hear( R, T )
	A = null
	foreach (_ in range ) {
		A = _
		if ( !( A instanceof ::BaseDynamic ) ) {
			continue
		}
		hear = hear | ::recursive_hear_check( A )
	}
	return hear
}

function get_location_accessible( M =null, location =null ) {
	local covered_locations, face_covered, eyesmouth_covered, C, I, H
	covered_locations = 0
	face_covered = 0
	eyesmouth_covered = 0
	if ( M instanceof ::Mob_Living_Carbon ) {
		C = M
		I = null
		foreach (_ in ::List([ C.back, C.wear_mask, C.head ]) ) {
			I = _
			if ( !( I instanceof ::Ent_Item_Clothing ) ) {
				continue
			}
			covered_locations = covered_locations | I.body_parts_covered
			face_covered = face_covered | I.flags_inv
			eyesmouth_covered = eyesmouth_covered | I.flags_cover
		}
		if ( C instanceof ::Mob_Living_Carbon_Human ) {
			H = C
			I = null
			foreach (_ in ::List([ H.wear_suit, H.w_uniform, H.shoes, H.belt, H.gloves, H.glasses, H.ears ]) ) {
				I = _
				if ( !( I instanceof ::Ent_Item ) ) {
					continue
				}
				covered_locations = covered_locations | I.body_parts_covered
				face_covered = face_covered | I.flags_inv
				eyesmouth_covered = eyesmouth_covered | I.flags_cover
			}
		}
	}
	local _ = location // Was a switch-case, sorry for the mess.
	if ( _=="head" ) {
		if ( covered_locations & 1 ) {
			return 0
		}
	} else if ( _=="eyes" ) {
		if ( covered_locations & 1 || face_covered & 4 || eyesmouth_covered & 1 ) {
			return 0
		}
	} else if ( _=="mouth" ) {
		if ( covered_locations & 1 || face_covered & 8 || eyesmouth_covered & 8 || eyesmouth_covered & 16 ) {
			return 0
		}
	} else if ( _=="chest" ) {
		if ( covered_locations & 2 ) {
			return 0
		}
	} else if ( _=="groin" ) {
		if ( covered_locations & 4 ) {
			return 0
		}
	} else if ( _=="l_arm" ) {
		if ( covered_locations & 128 ) {
			return 0
		}
	} else if ( _=="r_arm" ) {
		if ( covered_locations & 256 ) {
			return 0
		}
	} else if ( _=="l_leg" ) {
		if ( covered_locations & 8 ) {
			return 0
		}
	} else if ( _=="r_leg" ) {
		if ( covered_locations & 16 ) {
			return 0
		}
	} else if ( _=="l_hand" ) {
		if ( covered_locations & 512 ) {
			return 0
		}
	} else if ( _=="r_hand" ) {
		if ( covered_locations & 1024 ) {
			return 0
		}
	} else if ( _=="l_foot" ) {
		if ( covered_locations & 32 ) {
			return 0
		}
	} else if ( _=="r_foot" ) {
		if ( covered_locations & 64 ) {
			return 0
		}
	}
	return 1
}

function get_location_modifier( M =null ) {
	local T
	T = ::get_turf( M )
	if ( ::locate_in( ::Ent_Structure_Optable, T ) ) {
		return 1
	} else if ( ::locate_in( ::Ent_Structure_Table, T ) ) {
		return 0.800000011920929
	} else if ( ::locate_in( ::Ent_Structure_Bed, T ) ) {
		return 0.699999988079071
	} else {
		return 0.5
	}
}

function get_mob_by_ckey( key =null ) {
	local mobs, M
	if ( !key ) {
		return
	}
	mobs = ::sortmobs()
	M = null
	foreach (_ in mobs ) {
		M = _
		if ( M.ckey == key ) {
			return M
		}
	}
}

function get_mob_by_key( key =null ) {
	local M
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		if ( M.ckey == ::lowertext( key ) ) {
			return M
		}
	}
	return
}

function get_mobs_in_radio_ranges( radios =null ) {
	local R, _default
	_default = ::List()
	R = null
	foreach (_ in radios ) {
		R = _
		if ( !( R instanceof ::Ent_Item_Device_Radio ) ) {
			continue
		}
		if ( R ) {
			_default = _default | ::get_hearers_in_view( R.canhear_range, R )
		}
	}
	return _default
}

function get_radio_name( freq =null ) {
	local returntext
	returntext = ::radiochannelsreverse["" + freq]
	if ( returntext ) {
		return returntext
	}
	return "" + ::copytext( "" + freq, 1, 4 ) + "." + ::copytext( "" + freq, 4, 5 )
}

function get_radio_span( freq =null ) {
	local returntext
	returntext = ::freqtospan["" + freq]
	if ( returntext ) {
		return returntext
	}
	return "radio"
}

function get_rand_frequency(  ) {
	return ::random.int( 32000, 55000 )
}

function get_ranged_target_turf( A =null, direction =null, range =null ) {
	local x, y
	x = A.x
	y = A.y
	if ( direction & 1 ) {
		y = ::math.min( ::game.maxy, y + range )
	}
	if ( direction & 2 ) {
		y = ::math.max( 1, y - range )
	}
	if ( direction & 4 ) {
		x = ::math.min( ::game.maxx, x + range )
	}
	if ( direction & 8 ) {
		x = ::math.max( 1, x - range )
	}
	return ::locate3( x, y, A.z )
}

function get_region_accesses( code =null ) {
	local _ = code // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return ::get_all_accesses()
	} else if ( _==1 ) {
		return ::List([ ::access_kitchen, ::access_bar, ::access_hydroponics, ::access_janitor, ::access_chapel_office, ::access_crematorium, ::access_library, ::access_theatre, ::access_lawyer ])
	} else if ( _==2 ) {
		return ::List([ ::access_sec_doors, ::access_weapons, ::access_security, ::access_brig, ::access_armory, ::access_forensics_lockers, ::access_court, ::access_hos ])
	} else if ( _==3 ) {
		return ::List([ ::access_medical, ::access_genetics, ::access_morgue, ::access_chemistry, ::access_virology, ::access_surgery, ::access_cmo ])
	} else if ( _==4 ) {
		return ::List([ ::access_research, ::access_tox, ::access_tox_storage, ::access_genetics, ::access_robotics, ::access_xenobiology, ::access_minisat, ::access_rd ])
	} else if ( _==5 ) {
		return ::List([ ::access_construction, ::access_maint_tunnels, ::access_engine, ::access_engine_equip, ::access_external_airlocks, ::access_tech_storage, ::access_atmospherics, ::access_tcomsat, ::access_minisat, ::access_ce ])
	} else if ( _==6 ) {
		return ::List([ ::access_mailsorting, ::access_mining, ::access_mining_station, ::access_mineral_storeroom, ::access_cargo, ::access_qm ])
	} else if ( _==7 ) {
		return ::List([ ::access_heads, ::access_RC_announce, ::access_keycard_auth, ::access_change_ids, ::access_ai_upload, ::access_teleporter, ::access_eva, ::access_gateway, ::access_all_personal_lockers, ::access_heads_vault, ::access_hop, ::access_captain ])
	}
}

function get_region_accesses_name( code =null ) {
	local _ = code // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return "All"
	} else if ( _==1 ) {
		return "General"
	} else if ( _==2 ) {
		return "Security"
	} else if ( _==3 ) {
		return "Medbay"
	} else if ( _==4 ) {
		return "Research"
	} else if ( _==5 ) {
		return "Engineering"
	} else if ( _==6 ) {
		return "Supply"
	} else if ( _==7 ) {
		return "Command"
	}
}

function get_security_level(  ) {
	local _ = ::security_level // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		return "green"
	} else if ( _==1 ) {
		return "blue"
	} else if ( _==2 ) {
		return "red"
	} else if ( _==3 ) {
		return "delta"
	}
}

function get_sfx( soundin =null ) {
	if ( ::istext( soundin ) ) {
		local _ = soundin // Was a switch-case, sorry for the mess.
		if ( _=="shatter" ) {
			local _ = ::random.pick([ ::Rsc(16), ::Rsc(17), ::Rsc(18) ])
			soundin = _
		} else if ( _=="explosion" ) {
			local _ = ::random.pick([ ::Rsc(19), ::Rsc(20) ])
			soundin = _
		} else if ( _=="sparks" ) {
			local _ = ::random.pick([ ::Rsc(21), ::Rsc(22), ::Rsc(23), ::Rsc(24) ])
			soundin = _
		} else if ( _=="rustle" ) {
			local _ = ::random.pick([ ::Rsc(25), ::Rsc(26), ::Rsc(27), ::Rsc(28), ::Rsc(29) ])
			soundin = _
		} else if ( _=="bodyfall" ) {
			local _ = ::random.pick([ ::Rsc(30), ::Rsc(31), ::Rsc(32), ::Rsc(33) ])
			soundin = _
		} else if ( _=="punch" ) {
			local _ = ::random.pick([ ::Rsc(34), ::Rsc(35), ::Rsc(36), ::Rsc(37) ])
			soundin = _
		} else if ( _=="clownstep" ) {
			local _ = ::random.pick([ ::Rsc(38), ::Rsc(39) ])
			soundin = _
		} else if ( _=="swing_hit" ) {
			local _ = ::random.pick([ ::Rsc(40), ::Rsc(41), ::Rsc(42) ])
			soundin = _
		} else if ( _=="hiss" ) {
			local _ = ::random.pick([ ::Rsc(43), ::Rsc(44), ::Rsc(45), ::Rsc(46) ])
			soundin = _
		} else if ( _=="pageturn" ) {
			local _ = ::random.pick([ ::Rsc(47), ::Rsc(48), ::Rsc(49) ])
			soundin = _
		} else if ( _=="gunshot" ) {
			local _ = ::random.pick([ ::Rsc(50), ::Rsc(51), ::Rsc(52), ::Rsc(53) ])
			soundin = _
		}
	}
	return soundin
}

function get_stickyban_from_ckey( ckey =null ) {
	local key, _default
	if ( !ckey ) {
		return
	}
	ckey = ::ckey( ckey )
	_default = null
	key = null
	foreach (_ in ::game.GetConfig( "ban" ) ) {
		key = _
		if ( ::ckey( key ) == ckey ) {
			_default = ::stickyban2list( ::game.GetConfig( "ban", key ) )
			break
		}
	}
	return _default
}

function get_teleport_loc( location =null, target =null, distance =null, density =null, errorx =null, errory =null, eoffsetx =null, eoffsety =null ) {
	local dirx, diry, xoffset, yoffset, b1xerror, b1yerror, b2xerror, b2yerror, destination, destination_list, center, T
	if ( distance == null ) {
		distance = 1
	}
	if ( density == null ) {
		density = 0
	}
	if ( errorx == null ) {
		errorx = 0
	}
	if ( errory == null ) {
		errory = 0
	}
	if ( eoffsetx == null ) {
		eoffsetx = 0
	}
	if ( eoffsety == null ) {
		eoffsety = 0
	}
	dirx = 0
	diry = 0
	xoffset = 0
	yoffset = 0
	b1xerror = 0
	b1yerror = 0
	b2xerror = 0
	b2yerror = 0
	errorx = ::math.abs( errorx )
	errory = ::math.abs( errory )
	local _ = target.dir // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		diry += distance
		yoffset += eoffsety
		xoffset += eoffsetx
		b1xerror -= errorx
		b1yerror -= errory
		b2xerror += errorx
		b2yerror += errory
	} else if ( _==2 ) {
		diry -= distance
		yoffset -= eoffsety
		xoffset += eoffsetx
		b1xerror -= errorx
		b1yerror -= errory
		b2xerror += errorx
		b2yerror += errory
	} else if ( _==4 ) {
		dirx += distance
		yoffset += eoffsetx
		xoffset += eoffsety
		b1xerror -= errory
		b1yerror -= errorx
		b2xerror += errory
		b2yerror += errorx
	} else if ( _==8 ) {
		dirx -= distance
		yoffset -= eoffsetx
		xoffset += eoffsety
		b1xerror -= errory
		b1yerror -= errorx
		b2xerror += errory
		b2yerror += errorx
	}
	destination = ::locate3( location.x + dirx, location.y + diry, location.z )
	if ( destination ) {
		if ( errorx || errory ) {
			destination_list = ::List()
			center = ::locate3( destination.x + xoffset, destination.y + yoffset, location.z )
			T = null
			foreach (_ in null( ::locate3( center.x + b1xerror, center.y + b1yerror, location.z ), ::locate3( center.x + b2xerror, center.y + b2yerror, location.z ) ) ) {
				T = _
				if ( density && T.density ) {
					continue
				}
				if ( T.x > ::game.maxx || T.x < 1 ) {
					continue
				}
				if ( T.y > ::game.maxy || T.y < 1 ) {
					continue
				}
				destination_list += T
			}
			if ( destination_list.len ) {
				destination = ::random.pick( destination_list )
			} else {
				return
			}
		} else {
			if ( density && destination.density ) {
				return
			}
			if ( destination.x > ::game.maxx || destination.x < 1 ) {
				return
			}
			if ( destination.y > ::game.maxy || destination.y < 1 ) {
				return
			}
		}
	} else {
		return
	}
	return destination
}

function get_turf( A =null ) {
	if ( !( A instanceof ::BaseStatic ) ) {
		return
	}
	while (A && !::isturf( A )) {
		A = A.loc
	}
	return A
}

function get_turf_pixel( AM =null ) {
	local rough_x, rough_y, final_x, final_y, i_width, i_height, AMicon, n_width, n_height
	if ( AM instanceof ::BaseDynamic ) {
		rough_x = 0
		rough_y = 0
		final_x = 0
		final_y = 0
		i_width = ::game.icon_size
		i_height = ::game.icon_size
		if ( AM.bound_height != ::game.icon_size || AM.bound_width != ::game.icon_size ) {
			AMicon = ::Icon( AM.icon, AM.icon_state )
			i_width = AMicon.Width()
			i_height = AMicon.$Height()
			::qdel( AMicon )
		}
		n_width = ::game.icon_size - i_width / 2
		n_height = ::game.icon_size - i_height / 2
		if ( n_width ) {
			rough_x = ::math.round( AM.pixel_x / n_width )
		}
		if ( n_height ) {
			rough_y = ::math.round( AM.pixel_y / n_height )
		}
		final_x = AM.x + rough_x
		final_y = AM.y + rough_y
		if ( final_x || final_y ) {
			return ::locate3( final_x, final_y, AM.z )
		}
	}
}

function get_uplink_items( gamemode_override =null ) {
	local last, item, I, filtered_uplink_items, category
	if ( gamemode_override == null ) {
		gamemode_override = null
	}
	if ( !::uplink_items.len ) {
		last = ::List()
		item = null
		foreach (_ in ::typesof( ::UplinkItem ) ) {
			item = _
			I = item()
			if ( !I.item ) {
				continue
			}
			if ( I.last ) {
				last += I
				continue
			}
			if ( !::uplink_items[I.category] ) {
				::uplink_items[I.category] = ::List()
			}
			::uplink_items[I.category] += I
		}
		I = null
		foreach (_ in last ) {
			I = _
			if ( !( I instanceof ::UplinkItem ) ) {
				continue
			}
			if ( !::uplink_items[I.category] ) {
				::uplink_items[I.category] = ::List()
			}
			::uplink_items[I.category] += I
		}
	}
	filtered_uplink_items = ::List()
	category = null
	foreach (_ in ::uplink_items ) {
		category = _
		I = null
		foreach (_ in ::uplink_items[category] ) {
			I = _
			if ( !( I instanceof ::UplinkItem ) ) {
				continue
			}
			if ( I.gamemodes.len ) {
				if ( !gamemode_override && ::ticker && !( ::ticker.mode.type in I.gamemodes ) ) {
					continue
				}
				if ( gamemode_override && !( gamemode_override in I.gamemodes ) ) {
					continue
				}
			}
			if ( I.excludefrom.len ) {
				if ( !gamemode_override && ::ticker && ::ticker.mode.type in I.excludefrom ) {
					continue
				}
				if ( gamemode_override && gamemode_override in I.excludefrom ) {
					continue
				}
			}
			if ( !filtered_uplink_items[I.category] ) {
				filtered_uplink_items[I.category] = ::List()
			}
			filtered_uplink_items[category] += I
		}
	}
	return filtered_uplink_items
}

function get_viewable_pdas(  ) {
	local P, _default
	_default = ::List()
	P = null
	foreach (_ in ::PDAs ) {
		P = _
		if ( !( P instanceof ::Ent_Item_Device_Pda ) ) {
			continue
		}
		if ( !P.owner || P.toff || P.hidden ) {
			continue
		}
		_default += P
	}
	return _default
	return _default
}

function getb( col =null ) {
	return ::hex2num( ::copytext( col, 6, null ) )
}

function getBlankIcon( A =null, safety =null ) {
	local flat_icon, blank_icon
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.Blend( "#ffffff" )
	flat_icon.$BecomeAlphaMask()
	blank_icon = ::Icon( ::Rsc(11), "blank_base" )
	blank_icon.AddAlphaMask( flat_icon )
	return blank_icon
}

function getblock( input =null, blocknumber =null, blocksize =null ) {
	if ( blocksize == null ) {
		blocksize = 3
	}
	return ::copytext( input, blocksize * ( blocknumber - 1 ) + 1, blocksize * blocknumber + 1 )
}

function GetColors( hex =null ) {
	local hi1, lo1, hi2, lo2, hi3, lo3, hi4, lo4
	hex = ::uppertext( hex )
	if ( ::length( hex ) == 7 ) {
		hex += "FF"
	}
	hi1 = ::text2ascii( hex, 2 )
	lo1 = ::text2ascii( hex, 3 )
	hi2 = ::text2ascii( hex, 4 )
	lo2 = ::text2ascii( hex, 5 )
	hi3 = ::text2ascii( hex, 6 )
	lo3 = ::text2ascii( hex, 7 )
	hi4 = ::text2ascii( hex, 8 )
	lo4 = ::text2ascii( hex, 9 )
	return ::List([ ( hi1 >= 65 ? hi1 - 55 : hi1 - 48 ) << 4 | ( lo1 >= 65 ? lo1 - 55 : lo1 - 48 ), ( hi2 >= 65 ? hi2 - 55 : hi2 - 48 ) << 4 | ( lo2 >= 65 ? lo2 - 55 : lo2 - 48 ), ( hi3 >= 65 ? hi3 - 55 : hi3 - 48 ) << 4 | ( lo3 >= 65 ? lo3 - 55 : lo3 - 48 ), ( hi4 >= 65 ? hi4 - 55 : hi4 - 48 ) << 4 | ( lo4 >= 65 ? lo4 - 55 : lo4 - 48 ) ])
}

function GetExp( minutes =null ) {
	local exp, timeleftstring
	::UpdateTime()
	exp = minutes - ::CMinutes
	if ( exp <= 0 ) {
		return 0
	} else {
		if ( exp >= 1440 ) {
			timeleftstring = "" + ::math.round( exp / 1440, 0.10000000149011612 ) + " Days"
		} else if ( exp >= 60 ) {
			timeleftstring = "" + ::math.round( exp / 60, 0.10000000149011612 ) + " Hours"
		} else {
			timeleftstring = "" + exp + " Minutes"
		}
		return timeleftstring
	}
}

function GetExpjob( minutes =null ) {
	local exp, timeleftstring
	::UpdateTime()
	exp = minutes - ::CMinutes
	if ( exp <= 0 ) {
		return 0
	} else {
		if ( exp >= 1440 ) {
			timeleftstring = "" + ::math.round( exp / 1440, 0.10000000149011612 ) + " Days"
		} else if ( exp >= 60 ) {
			timeleftstring = "" + ::math.round( exp / 60, 0.10000000149011612 ) + " Hours"
		} else {
			timeleftstring = "" + exp + " Minutes"
		}
		return timeleftstring
	}
}

function getFlatIcon( A =null, defdir =null, deficon =null, defstate =null, defblend =null ) {
	local flat, noIcon, curicon, curstate, curdir, curblend, layers, copy, process, pSet, curIndex, current, currentLayer, compare, cmpIndex, add, flatX1, flatX2, flatY1, flatY2, addX1, addX2, addY1, addY2, I
	if ( defdir == null ) {
		defdir = A.dir
	}
	if ( deficon == null ) {
		deficon = A.icon
	}
	if ( defstate == null ) {
		defstate = A.icon_state
	}
	if ( defblend == null ) {
		defblend = A.blend_mode
	}
	flat = ::Icon( ::Rsc(11), "nothing" )
	if ( !A ) {
		return flat
	}
	if ( A.alpha <= 0 ) {
		return flat
	}
	noIcon = ::FALSE
	if ( A.icon ) {
		curicon = A.icon
	} else {
		curicon = deficon
	}
	if ( !curicon ) {
		noIcon = ::TRUE
	}
	if ( A.icon_state ) {
		curstate = A.icon_state
	} else {
		curstate = defstate
	}
	if ( !noIcon && !( curstate in ::icon_states( null, curicon ) ) ) {
		if ( "" in ::icon_states( null, curicon ) ) {
			curstate = ""
		} else {
			noIcon = ::TRUE
		}
	}
	if ( A.dir != 2 ) {
		curdir = A.dir
	} else {
		curdir = defdir
	}
	if ( A.blend_mode == ::BLEND_DEFAULT ) {
		curblend = defblend
	} else {
		curblend = A.blend_mode
	}
	layers = ::List()
	if ( !noIcon ) {
		copy = ::Image.lcall( ::List({ ["dir"]= curdir, ["layer"]= A.layer, ["icon_state"]= curstate, ["icon"]= curicon }) )
		copy.color = A.color
		copy.alpha = A.alpha
		copy.blend_mode = curblend
		layers[copy] = A.layer
	}
	process = A.underlays
	pSet = 0
	curIndex = 1
	while (::TRUE) {
		if ( curIndex <= process.len ) {
			current = process[curIndex]
			if ( !current ) {
				curIndex++
				continue
			}
			currentLayer = current.layer
			if ( currentLayer < 0 ) {
				if ( currentLayer <= -1000 ) {
					return flat
				}
				if ( pSet == 0 ) {
					currentLayer = A.layer + currentLayer / 1000
				} else {
					currentLayer = A.layer + ( currentLayer + 1000 ) / 1000
				}
			}
			cmpIndex = 1
			while (cmpIndex <= layers.len) {
				compare = layers[cmpIndex]
				if ( currentLayer < layers[compare] ) {
					layers.$Insert( cmpIndex, current )
					layers[current] = currentLayer
					break
				}
				cmpIndex++
			}
			if ( cmpIndex > layers.len ) {
				layers[current] = currentLayer
			}
			curIndex++
		}
		if ( curIndex > process.len ) {
			if ( pSet == 0 ) {
				curIndex = 1
				pSet = 1
				process = A.overlays
			} else {
				break
			}
		}
	}
	add = null
	flatX1 = 1
	flatX2 = flat.Width()
	flatY1 = 1
	flatY2 = flat.$Height()
	addX1 = null
	addX2 = null
	addY1 = null
	addY2 = null
	I = null
	foreach (_ in layers ) {
		I = _
		if ( I.alpha == 0 ) {
			continue
		}
		if ( I == copy ) {
			curblend = ::BLEND_OVERLAY
			add = ::Icon( I.icon, I.icon_state, I.dir )
		} else {
			add = ::getFlatIcon( ::Image( I ), curdir, curicon, curstate, curblend )
		}
		addX1 = ::math.min( flatX1, I.pixel_x + 1 )
		addX2 = ::math.max( flatX2, I.pixel_x + add.Width() )
		addY1 = ::math.min( flatY1, I.pixel_y + 1 )
		addY2 = ::math.max( flatY2, I.pixel_y + add.Height() )
		if ( addX1 != flatX1 || addX2 != flatX2 || addY1 != flatY1 || addY2 != flatY2 ) {
			flat.Crop( addX1 - flatX1 + 1, addY1 - flatY1 + 1, addX2 - flatX1 + 1, addY2 - flatY1 + 1 )
			flatX1 = addX1
			flatX2 = addX2
			flatY1 = addY1
			flatY2 = addY2
		}
		flat.Blend( add, ::blendMode2iconMode( curblend ), I.pixel_x + 2 - flatX1, I.pixel_y + 2 - flatY1 )
	}
	if ( A.color ) {
		flat.Blend( A.color, 2 )
	}
	if ( A.alpha < 255 ) {
		flat.Blend( ::rgba( 255, 255, 255, A.alpha ), 2 )
	}
	return ::Icon( flat, "", ::SOUTH )
}

function GetFromPool( get_type =null, second_arg =null ) {
	local pooled, AM
	if ( !get_type ) {
		return
	}
	if ( ::isnull( ::GlobalPool[get_type] ) ) {
		return
	}
	if ( ::length( ::GlobalPool[get_type] ) == 0 ) {
		return
	}
	pooled = ::pop( ::GlobalPool[get_type] )
	if ( pooled ) {
		if ( pooled instanceof ::BaseDynamic ) {
			AM = pooled
		}
		if ( second_arg instanceof ::List ) {
			if ( AM ) {
				AM.loc = second_arg[1]
			}
			pooled.New.lcall( second_arg )
		} else {
			if ( AM ) {
				AM.loc = second_arg
			}
			pooled.New( second_arg )
		}
		return pooled
	}
}

function getg( col =null ) {
	return ::hex2num( ::copytext( col, 4, 6 ) )
}

function getHologramIcon( A =null, safety =null ) {
	local flat_icon, alpha_mask
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.ColorTone( "#7db4e1" )
	flat_icon.$ChangeOpacity( 0.5 )
	alpha_mask = ::Icon( ::Rsc(11), "scanline" )
	flat_icon.AddAlphaMask( alpha_mask )
	return flat_icon
}

function getIconMask( A =null ) {
	local alpha_mask, I, image_overlay
	alpha_mask = ::Icon( A.icon, A.icon_state )
	I = null
	foreach (_ in A.overlays ) {
		I = _
		if ( I.layer > A.layer ) {
			continue
		}
		image_overlay = ::Icon( I.icon, I.icon_state )
		alpha_mask.Blend( image_overlay, 5 )
	}
	return alpha_mask
}

function getleftblocks( input =null, blocknumber =null, blocksize =null ) {
	if ( blocknumber > 1 ) {
		return ::copytext( input, 1, blocksize * blocknumber - ( blocksize - 1 ) )
	}
}

function getLetterImage( A =null, letter =null, uppercase =null ) {
	local atom_icon, text_image
	if ( letter == null ) {
		letter = ""
	}
	if ( uppercase == null ) {
		uppercase = 0
	}
	if ( !A ) {
		return
	}
	atom_icon = ::Icon( A.icon, A.icon_state )
	if ( !letter ) {
		letter = ::copytext( A.name, 1, 2 )
		if ( uppercase == 1 ) {
			letter = ::uppertext( letter )
		} else if ( uppercase == -1 ) {
			letter = ::lowertext( letter )
		}
	}
	text_image = ::Image.lcall( ::List({ ["loc"]= A }) )
	text_image.maptext = "<font size = 4>" + letter + "</font>"
	text_image.color = ::AverageColour( atom_icon )
	text_image.pixel_x = 7
	text_image.pixel_y = 5
	::del( atom_icon )
	atom_icon = null
	return text_image
}

function getline( M =null, N =null ) {
	local px, py, line, dx, dy, dxabs, dyabs, sdx, sdy, x, y, j
	px = M.x
	py = M.y
	line = ::List([ ::locate3( px, py, M.z ) ])
	dx = N.x - px
	dy = N.y - py
	dxabs = ::math.abs( dx )
	dyabs = ::math.abs( dy )
	sdx = ::sign( dx )
	sdy = ::sign( dy )
	x = dxabs >> 1
	y = dyabs >> 1
	if ( dxabs >= dyabs ) {
		j = 0
		while (j < dxabs) {
			y += dyabs
			if ( y >= dxabs ) {
				y -= dxabs
				py += sdy
			}
			px += sdx
			line += ::locate3( px, py, M.z )
			j++
		}
	} else {
		j = 0
		while (j < dyabs) {
			x += dxabs
			if ( x >= dyabs ) {
				x -= dyabs
				px += sdx
			}
			py += sdy
			line += ::locate3( px, py, M.z )
			j++
		}
	}
	return line
}

function getmobs(  ) {
	local mobs, names, creatures, namecounts, M, name
	mobs = ::sortmobs()
	names = ::List()
	creatures = ::List()
	namecounts = ::List()
	M = null
	foreach (_ in mobs ) {
		M = _
		name = M.name
		if ( name in names ) {
			namecounts[name]++
			name = "" + name + " (" + namecounts[name] + ")"
		} else {
			names.Add( name )
			namecounts[name] = 1
		}
		if ( M.real_name && M.real_name != M.name ) {
			name += " [" + M.real_name + "]"
		}
		if ( M.stat == 2 ) {
			if ( M instanceof ::Mob_Dead_Observer ) {
				name += " [ghost]"
			} else {
				name += " [dead]"
			}
		}
		creatures[name] = M
	}
	return creatures
}

function getr( col =null ) {
	return ::hex2num( ::copytext( col, 2, 4 ) )
}

function getrightblocks( input =null, blocknumber =null, blocksize =null ) {
	if ( blocknumber < ::length( input ) / blocksize ) {
		return ::copytext( input, blocksize * blocknumber + 1, ::length( input ) + 1 )
	}
}

function getStaticIcon( A =null, safety =null ) {
	local flat_icon, static_icon
	if ( safety == null ) {
		safety = 1
	}
	flat_icon = safety ? A : ::Icon( A )
	flat_icon.Blend( "#ffffff" )
	flat_icon.$BecomeAlphaMask()
	static_icon = ::Icon( ::Rsc(11), "static_base" )
	static_icon.AddAlphaMask( flat_icon )
	return static_icon
}

function Gibberish( t =null, p =null ) {
	local returntext, i, letter, j
	returntext = ""
	i = null
	i = 1
	while (i <= ::length( t )) {
		letter = ::copytext( t, i, i + 1 )
		if ( ::random.chance( 50 ) ) {
			if ( p >= 70 ) {
				letter = ""
			}
			j = null
			j = 1
			while (j <= ::random.int( 0, 2 )) {
				local _ = ::random.pick([ "#", "@", "*", "&", "%", "$", "/", "<", ">", ";", "*", "*", "*", "*", "*", "*", "*" ])
				letter += _
				j++
			}
		}
		returntext += letter
		i++
	}
	return returntext
}

function gibs( location =null, viruses =null, MobDNA =null ) {
	::Ent_Effect_Gibspawner_Generic( location, viruses, MobDNA )
}

function give_codewords( traitor_mob =null ) {
	traitor_mob.write( "<U><B>The Syndicate provided you with the following information on how to identify their agents:</B></U>" )
	traitor_mob.write( "<B>Code Phrase</B>: <span class='danger'>" + ::syndicate_code_phrase + "</span>" )
	traitor_mob.write( "<B>Code Response</B>: <span class='danger'>" + ::syndicate_code_response + "</span>" )
	traitor_mob.mind.store_memory( "<b>Code Phrase</b>: " + ::syndicate_code_phrase )
	traitor_mob.$store memory( "<b>Code Response</b>: " + ::syndicate_code_response )
	traitor_mob.write( "Use the code words in the order provided, during regular conversation, to identify other agents. Proceed with caution, however, as everyone is a potential foe." )
}

function gotwallitem( loc =null, dir =null, check_external =null ) {
	local locdir, O
	if ( check_external == null ) {
		check_external = 0
	}
	locdir = ::get_step( loc, dir )
	O = null
	foreach (_ in loc ) {
		O = _
		if ( !( O instanceof ::Entity ) ) {
			continue
		}
		if ( ::is_type_in_list( O, ::WALLITEMS ) && check_external != 2 ) {
			if ( ::is_type_in_list( O, ::WALLITEMS_INVERSE ) ) {
				if ( O.dir == ::turn( dir, 180 ) ) {
					return 1
				}
			} else if ( O.dir == dir ) {
				return 1
			}
			if ( ::get_turf_pixel( O ) == locdir ) {
				return 1
			}
		}
		if ( ::is_type_in_list( O, ::WALLITEMS_EXTERNAL ) && check_external ) {
			if ( ::is_type_in_list( O, ::WALLITEMS_INVERSE ) ) {
				if ( O.dir == ::turn( dir, 180 ) ) {
					return 1
				}
			} else if ( O.dir == dir ) {
				return 1
			}
		}
	}
	O = null
	foreach (_ in locdir ) {
		O = _
		if ( !( O instanceof ::Entity ) ) {
			continue
		}
		if ( ::is_type_in_list( O, ::WALLITEMS ) && check_external != 2 ) {
			if ( O.pixel_x == 0 && O.pixel_y == 0 ) {
				return 1
			}
		}
	}
	return 0
}

function has_gravity( AT =null, T =null ) {
	local A
	if ( !T ) {
		T = ::get_turf( AT )
	}
	A = ::get_area( T )
	if ( T instanceof ::Tile_Space ) {
		return 0
	} else if ( A && A.has_gravity ) {
		return 1
	} else if ( T && ::gravity_generators["" + T.z] && ::length( ::gravity_generators["" + T.z] ) ) {
		return 1
	}
	return 0
}

function hasvar( A =null, varname =null ) {
	if ( A.vars.Find( ::lowertext( varname ) ) ) {
		return 1
	} else {
		return 0
	}
}

function healthscan( user =null, M =null, mode =null ) {
	local oxy_loss, tox_loss, fire_loss, brute_loss, mob_status, H, damaged, org, D, blood_volume, blood_percent, blood_type, implant_detect, CI
	if ( mode == null ) {
		mode = 1
	}
	oxy_loss = M.getOxyLoss()
	tox_loss = M.$getToxLoss()
	fire_loss = M.$getFireLoss()
	brute_loss = M.$getBruteLoss()
	mob_status = M.stat > 1 ? "<span class='alert'><b>Deceased</b></span>" : "<b>" + M.health + " % healthy</b>"
	if ( M.status_flags & 8192 ) {
		mob_status = "<span class='alert'>Deceased</span>"
		oxy_loss = ::math.max( ::random.int( 1, 40 ), oxy_loss, 300 - ( tox_loss + fire_loss + brute_loss ) )
	}
	if ( M instanceof ::Mob_Living_Carbon_Human ) {
		H = M
		if ( H.heart_attack ) {
			user.write( "<span class='danger'>Subject suffering from heart attack: Apply defibrillator immediately!</span>" )
		}
	}
	user.write( "<span class='info'>Analyzing results for " + M + ":\n	Overall status: " + mob_status + "</span>" )
	if ( brute_loss > 10 ) {
		user.write( "	<span class='alert'>" + ( brute_loss > 50 ? "Severe" : "Minor" ) + " tissue damage detected.</span>" )
	}
	if ( fire_loss > 10 ) {
		user.write( "	<span class='alert'>" + ( fire_loss > 50 ? "Severe" : "Minor" ) + " burn damage detected.</span>" )
	}
	if ( oxy_loss > 10 ) {
		user.write( "	<span class='info'><span class='alert'>" + ( oxy_loss > 50 ? "Severe" : "Minor" ) + " oxygen deprivation detected.</span>" )
	}
	if ( tox_loss > 10 ) {
		user.write( "	<span class='alert'>" + ( tox_loss > 50 ? "Critical" : "Dangerous" ) + " amount of toxins detected.</span>" )
	}
	if ( M.getStaminaLoss() ) {
		user.write( "	<span class='alert'>Subject appears to be suffering from fatigue.</span>" )
	}
	if ( M.getCloneLoss() ) {
		user.write( "	<span class='alert'>Subject appears to have " + ( M.$getCloneLoss() > 30 ? "severe" : "minor" ) + " cellular damage.</span>" )
	}
	if ( M.reagents && M.reagents.get_reagent_amount( "epinephrine" ) ) {
		user.write( "	<span class='info'>Bloodstream analysis located " + M.reagents.get_reagent_amount( "epinephrine" ) + " units of rejuvenation chemicals.</span>" )
	}
	if ( M.getBrainLoss() >= 100 || !M.$getorgan( ::Ent_Item_Organ_Internal_Brain ) ) {
		user.write( "	<span class='alert'>Subject brain function is non-existant.</span>" )
	} else if ( M.getBrainLoss() >= 60 ) {
		user.write( "	<span class='alert'>Severe brain damage detected. Subject likely to have mental retardation.</span>" )
	} else if ( M.$getBrainLoss() >= 10 ) {
		user.write( "	<span class='alert'>Brain damage detected. Subject may have had a concussion.</span>" )
	}
	if ( M instanceof ::Mob_Living_Carbon_Human && mode == 1 ) {
		H = M
		damaged = H.get_damaged_organs( 1, 1 )
		if ( ::length( damaged ) > 0 || oxy_loss > 0 || tox_loss > 0 || fire_loss > 0 ) {
			user.write( "<span class='info'>	Damage: <span class='info'><font color='red'>Brute</font></span>-<font color='#FF8000'>Burn</font>-<font color='green'>Toxin</font>-<font color='blue'>Suffocation</font>\n		Specifics: <font color='red'>" + brute_loss + "</font>-<font color='#FF8000'>" + fire_loss + "</font>-<font color='green'>" + tox_loss + "</font>-<font color='blue'>" + oxy_loss + "</font></span>" )
			org = null
			foreach (_ in damaged ) {
				org = _
				if ( !( org instanceof ::Ent_Item_Organ_Limb ) ) {
					continue
				}
				user.write( "		<span class='info'>" + ::capitalize( org.getDisplayName() ) + ": " + ( org.brute_dam > 0 ? "<font color='red'>" + org.brute_dam + "</font></span>" : "<font color='red'>0</font>" ) + "-" + ( org.burn_dam > 0 ? "<font color='#FF8000'>" + org.burn_dam + "</font>" : "<font color='#FF8000'>0</font>" ) )
			}
		}
	}
	if ( M instanceof ::Mob_Living_Carbon_Human ) {
		H = M
		user.write( "<span class='info'>Species: " + H.dna.species.name + "</span>" )
	}
	user.write( "<span class='info'>Body temperature: " + ::math.round( M.bodytemperature - 273.1499938964844, 0.10000000149011612 ) + " &deg;C (" + ::math.round( M.bodytemperature * 1.7999999523162842 - 459.6700134277344, 0.10000000149011612 ) + " &deg;F)</span>" )
	if ( M.tod && ( M.stat == 2 || M.status_flags & 8192 ) ) {
		user.write( "<span class='info'>Time of Death:</span> " + M.tod )
	}
	D = null
	foreach (_ in M.viruses ) {
		D = _
		if ( !( D instanceof ::Disease ) ) {
			continue
		}
		if ( !( D.visibility_flags & 1 ) ) {
			user.write( "<span class='alert'><b>Warning: " + D.form + " detected</b>\nName: " + D.name + ".\nType: " + D.spread_text + ".\nStage: " + D.stage + "/" + D.max_stages + ".\nPossible Cure: " + D.cure_text + "</span>" )
		}
	}
	if ( M instanceof ::Mob_Living_Carbon_Human ) {
		H = M
		if ( H.vessel ) {
			if ( H.blood_max ) {
				user.write( "<span class='danger'>Subject is bleeding!</span>" )
			}
			blood_volume = ::math.round( H.vessel.get_reagent_amount( "blood" ) )
			blood_percent = ::math.round( blood_volume / 560, 0.009999999776482582 )
			blood_type = H.dna.blood_type
			blood_percent *= 100
			if ( blood_volume <= 500 && blood_volume > 336 ) {
				user.write( "<span class='danger'>LOW blood level " + blood_percent + " %, " + blood_volume + " cl,</span> <span class='info'>type: " + blood_type + "</span>" )
			} else if ( blood_volume <= 336 ) {
				user.write( "<span class='danger'>CRITICAL blood level CRITICAL " + blood_percent + " %, " + blood_volume + " cl,</span> <span class='info'>type: " + blood_type + "</span>" )
			} else {
				user.write( "<span class='info'>Blood level " + blood_percent + " %, " + blood_volume + " cl, type: " + blood_type + "</span>" )
			}
		}
		implant_detect = null
		CI = null
		foreach (_ in H.internal_organs ) {
			CI = _
			if ( !( CI instanceof ::Ent_Item_Organ_Internal_Cyberimp ) ) {
				continue
			}
			if ( CI.status == 2 ) {
				implant_detect += "" + H.name + " is modified with a " + CI.name + ".<br>"
			}
		}
		if ( implant_detect ) {
			user.show_message( "<span class='notice'>Detected cybernetic modifications:</span>" )
			user.$show message( "<span class='notice'>" + implant_detect + "</span>" )
		}
	}
}

function HeapPathWeightCompare( a =null, b =null ) {
	return b.f - a.f
}

function heat2colour_b( temp =null ) {
	temp /= 100
	if ( temp >= 66 ) {
		_default = 255
	} else if ( temp <= 16 ) {
		_default = 0
	} else {
		_default = ::math.max( 0, ::math.min( 255, ::math.log( temp - 10 ) * 138.51773071289062 - 305.0447998046875 ) )
	}
	return _default
}

function heat2colour_g( temp =null ) {
	temp /= 100
	if ( temp <= 66 ) {
		_default = ::math.max( 0, ::math.min( 255, ::math.log( temp ) * 99.4708023071289 - 161.11956787109375 ) )
	} else {
		_default = ::math.max( 0, ::math.min( 255, ::pow( temp - 60, -0.07514849305152893 ) * 288.1221618652344 ) )
	}
	return _default
}

function heat2colour_r( temp =null ) {
	temp /= 100
	if ( temp <= 66 ) {
		_default = 255
	} else {
		_default = ::math.max( 0, ::math.min( 255, ::pow( temp - 60, -0.13320475816726685 ) * 329.69873046875 ) )
	}
	return _default
}

function hex2num( hex =null ) {
	local negative, len, i, num, _default
	_default = 0
	if ( ::istext( hex ) ) {
		negative = 0
		len = ::length( hex )
		i = null
		i = 1
		while (i <= len) {
			num = ::text2ascii( hex, i )
			local _ = num // Was a switch-case, sorry for the mess.
			if ( 48<=_&&_<=57 ) {
				num -= 48
			} else if ( 97<=_&&_<=102 ) {
				num -= 87
			} else if ( 65<=_&&_<=70 ) {
				num -= 55
			} else if ( _==45 ) {
				negative = 1
			} else {
				if ( num ) {
					break
				} else {
					i++
					continue
				}
			}
			_default *= 16
			_default += num
			i++
		}
		if ( negative ) {
			_default *= -1
		}
	}
	return _default
	return _default
}

function hgibs( location =null, viruses =null, MobDNA =null ) {
	::Ent_Effect_Gibspawner_Human( location, viruses, MobDNA )
}

function init_paths( prototype =null, L =null ) {
	local path
	if ( !( L instanceof ::List ) ) {
		L = ::List()
		path = null
		foreach (_ in ::typesof( prototype ) ) {
			path = _
			if ( path == prototype ) {
				continue
			}
			L += path
		}
		return L
	}
}

function init_sprite_accessory_subtypes( prototype =null, L =null, male =null, female =null ) {
	local path, D
	if ( !( L instanceof ::List ) ) {
		L = ::List()
	}
	if ( !( male instanceof ::List ) ) {
		male = ::List()
	}
	if ( !( female instanceof ::List ) ) {
		female = ::List()
	}
	path = null
	foreach (_ in ::typesof( prototype ) ) {
		path = _
		if ( path == prototype ) {
			continue
		}
		D = path()
		if ( D.icon_state ) {
			L[D.name] = D
		} else {
			L += D.name
		}
		local _ = D.gender // Was a switch-case, sorry for the mess.
		if ( _=="male" ) {
			male += D.name
		} else if ( _=="female" ) {
			female += D.name
		} else {
			male += D.name
			female += D.name
		}
	}
	return L
}

function init_subtypes( prototype =null, L =null ) {
	local path
	if ( !( L instanceof ::List ) ) {
		L = ::List()
	}
	path = null
	foreach (_ in ::typesof( prototype ) ) {
		path = _
		if ( path == prototype ) {
			continue
		}
		L += path()
	}
	return L
}

function InitializeSwapMaps(  ) {
	local V
	if ( ::swapmaps_initialized ) {
		return
	}
	::swapmaps_initialized = 1
	::swapmaps_compiled_maxx = ::game.maxx
	::swapmaps_compiled_maxy = ::game.maxy
	::swapmaps_compiled_maxz = ::game.maxz
	::swapmaps_loaded = ::List()
	::swapmaps_byname = ::List()
	if ( ::swapmaps_iconcache ) {
		V = null
		foreach (_ in ::swapmaps_iconcache ) {
			V = _
			::swapmaps_iconcache[::swapmaps_iconcache[V]] = V
		}
	}
}

function inLineOfSight( X1 =null, Y1 =null, X2 =null, Y2 =null, Z =null, PX1 =null, PY1 =null, PX2 =null, PY2 =null ) {
	local T, s, m, b, signX, signY
	if ( Z == null ) {
		Z = 1
	}
	if ( PX1 == null ) {
		PX1 = 16.5
	}
	if ( PY1 == null ) {
		PY1 = 16.5
	}
	if ( PX2 == null ) {
		PX2 = 16.5
	}
	if ( PY2 == null ) {
		PY2 = 16.5
	}
	if ( X1 == X2 ) {
		if ( Y1 == Y2 ) {
			return 1
		} else {
			s = Y2 - Y1 < 0 ? -1 : 1
			Y1 += s
			while (Y1 != Y2) {
				T = ::locate3( X1, Y1, Z )
				if ( T.opacity ) {
					return 0
				}
				Y1 += s
			}
		}
	} else {
		m = ( ( Y2 - Y1 ) * 32 + ( PY2 - PY1 ) ) / ( ( X2 - X1 ) * 32 + ( PX2 - PX1 ) )
		b = Y1 + PY1 / 32 - 0.015625 - m * ( X1 + PX1 / 32 - 0.015625 )
		signX = X2 - X1 < 0 ? -1 : 1
		signY = Y2 - Y1 < 0 ? -1 : 1
		if ( X1 < X2 ) {
			b += m
		}
		while (X1 != X2 || Y1 != Y2) {
			if ( ::math.round( m * X1 + b - Y1 ) ) {
				Y1 += signY
			} else {
				X1 += signX
			}
			T = ::locate3( X1, Y1, Z )
			if ( T.opacity ) {
				return 0
			}
		}
	}
	return 1
}

function intent_numeric( argument =null ) {
	if ( ::istext( argument ) ) {
		local _ = argument // Was a switch-case, sorry for the mess.
		if ( _=="help" ) {
			return 0
		} else if ( _=="disarm" ) {
			return 1
		} else if ( _=="grab" ) {
			return 2
		} else {
			return 3
		}
	} else {
		local _ = argument // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			return "help"
		} else if ( _==1 ) {
			return "disarm"
		} else if ( _==2 ) {
			return "grab"
		} else {
			return "harm"
		}
	}
}

function investigate_subject2file( subject =null ) {
	
}

function ionnum(  ) {
	local _ = ::random.pick([ "!", "@", "#", "$", "%", "^", "&" ])
	local _ = ::random.pick([ "!", "@", "#", "$", "%", "^", "&", "*" ])
	local _ = ::random.pick([ "!", "@", "#", "$", "%", "^", "&", "*" ])
	local _ = ::random.pick([ "!", "@", "#", "$", "%", "^", "&", "*" ])
	return "" + _ + _ + _ + _
}

function is_blind( A =null ) {
	local B
	if ( ::ismob( A ) ) {
		B = A
		return B.eye_blind
	}
	return 0
}

function is_convertable_to_cult( mind =null ) {
	if ( !( mind instanceof ::Mind ) ) {
		return 0
	}
	if ( mind.current instanceof ::Mob_Living_Carbon_Human && mind.assigned_role in ::List([ "Captain", "Chaplain" ]) ) {
		return 0
	}
	if ( ::isloyal( mind.current ) ) {
		return 0
	}
	if ( ::ticker.mode.name == "cult" ) {
		if ( ::is_sacrifice_target( mind ) ) {
			return 0
		}
	}
	return 1
}

function is_gangster( M =null ) {
	return M instanceof ::Mob_Living && M.mind && M.mind.gang_datum
}

function is_in_gang( M =null, gang_type =null ) {
	local G
	if ( !::is_gangster( M ) || !gang_type ) {
		return 0
	}
	G = M.mind.gang_datum
	if ( G.name == gang_type ) {
		return 1
	}
	return 0
}

function is_pointed( W =null ) {
	if ( W instanceof ::Ent_Item_Weapon_Pen ) {
		return 1
	}
	if ( W instanceof ::Ent_Item_Weapon_Screwdriver ) {
		return 1
	}
	if ( W instanceof ::Ent_Item_Weapon_ReagentContainers_Syringe ) {
		return 1
	}
	if ( W instanceof ::Ent_Item_Weapon_Kitchen_Fork ) {
		return 1
	} else {
		return 0
	}
}

function is_sacrifice_target( mind =null ) {
	local cult_mode
	if ( ::ticker.mode.name == "cult" ) {
		cult_mode = ::ticker.mode
		if ( mind == cult_mode.sacrifice_target ) {
			return 1
		}
	}
	return 0
}

function is_shadow( M =null ) {
	return M instanceof ::Mob_Living && M.mind && ::ticker && ::ticker.mode && M.mind in ::ticker.mode.shadows
}

function is_shadow_or_thrall( M =null ) {
	return M instanceof ::Mob_Living && M.mind && ::ticker && ::ticker.mode && ( M.mind in ::ticker.mode.thralls || M.mind in ::ticker.mode.shadows )
}

function is_special_character( M =null ) {
	local R, A
	if ( !::ticker || !::ticker.mode ) {
		return 0
	}
	if ( !( M instanceof ::Mob ) ) {
		return 0
	}
	if ( M instanceof ::Mob_Living_Silicon ) {
		if ( M instanceof ::Mob_Living_Silicon_Robot ) {
			R = M
			if ( R.emagged || R.syndicate ) {
				return 1
			}
			if ( R.mind && R.mind.special_role && R.laws && R.laws.zeroth ) {
				if ( R.connected_ai ) {
					if ( ::is_special_character( R.connected_ai ) && R.connected_ai.laws && ( R.connected_ai.laws.zeroth_borg == R.laws.zeroth || R.connected_ai.laws.zeroth == R.laws.zeroth ) ) {
						return 0
					}
					return 1
				}
				return 1
			}
		} else if ( M instanceof ::Mob_Living_Silicon_Ai ) {
			A = M
			if ( A.laws && A.laws.zeroth && A.mind && A.mind.special_role ) {
				if ( ::ticker.config_tag == "malfunction" && M.mind in ::ticker.mode.malf_ai ) {
					return 2
				}
				return 1
			}
		}
		return 0
	}
	if ( M.mind && M.mind.special_role ) {
		local _ = ::ticker.mode.config_tag // Was a switch-case, sorry for the mess.
		if ( _=="revolution" ) {
			if ( M.mind in ::ticker.head_revolutionaries || M.mind in ::ticker.mode.revolutionaries ) {
				return 2
			}
		} else if ( _=="cult" ) {
			if ( M.mind in M.cult ) {
				return 2
			}
		} else if ( _=="nuclear" ) {
			if ( M.mind in M.syndicates ) {
				return 2
			}
		} else if ( _=="changeling" ) {
			if ( M.mind in M.changelings ) {
				return 2
			}
		} else if ( _=="wizard" ) {
			if ( M.mind in M.wizards ) {
				return 2
			}
		} else if ( _=="monkey" ) {
			if ( M.viruses && ::locate_in( ::Disease_Transformation_JungleFever, M.viruses ) ) {
				return 2
			}
		} else if ( _=="abductor" ) {
			if ( M.mind in M.abductors ) {
				return 2
			}
		}
		return 1
	}
	return 0
}

function is_thrall( M =null ) {
	return M instanceof ::Mob_Living && M.mind && ::ticker && ::ticker.mode && M.mind in ::ticker.mode.thralls
}

function is_type_in_list( A =null, L =null ) {
	local type
	type = null
	foreach (_ in L ) {
		type = _
		if ( A instanceof type ) {
			return 1
		}
	}
	return 0
}

function iscultist( M =null ) {
	return M instanceof ::Mob_Living && M.mind && ::ticker && ::ticker.mode && M.mind in ::ticker.mode.cult
}

function isemptylist( L =null ) {
	if ( !L.len ) {
		return 1
	}
	return 0
}

function IsEven( x =null ) {
	return x % 2 == 0
}

function IsGuestKey( key =null ) {
	local i, ch, len
	if ( ::findtext( key, "Guest-", 1, 7 ) != 1 ) {
		return 0
	}
	len = ::length( key )
	i = 7
	while (i <= len) {
		ch = ::text2ascii( key, i )
		if ( ch < 48 || ch > 57 ) {
			return 0
		}
		i++
	}
	return 1
}

function IsInRange( val =null, min =null, max =null ) {
	return min <= val && val <= max
}

function isInSight( A =null, B =null ) {
	local Aturf, Bturf
	Aturf = ::get_turf( A )
	Bturf = ::get_turf( B )
	if ( !Aturf || !Bturf ) {
		return 0
	}
	if ( ::inLineOfSight( Aturf.x, Aturf.y, Bturf.x, Bturf.y, Aturf.z ) ) {
		return 1
	} else {
		return 0
	}
}

function isLeap( y =null ) {
	return y % 4 == 0 && ( y % 100 != 0 || y % 400 == 0 )
}

function isloyal( A =null ) {
	local L
	L = null
	foreach (_ in A ) {
		L = _
		if ( !( L instanceof ::Ent_Item_Weapon_Implant_Loyalty ) ) {
			continue
		}
		if ( L && L.implanted ) {
			return 1
		}
	}
	return 0
}

function IsMultiple( x =null, y =null ) {
	return x % y == 0
}

function IsOdd( x =null ) {
	return !::IsEven( x )
}

function isorgan( A =null ) {
	return A instanceof ::Ent_Item_Organ_Internal
}

function istool( O =null ) {
	if ( O && ::is_type_in_list( O, ::common_tools ) ) {
		return 1
	}
	return 0
}

function iswizard( M =null ) {
	return M instanceof ::Mob_Living && M.mind && ::ticker && ::ticker.mode && M.mind in ::ticker.mode.wizards
}

function jobban_isbanned( M =null, rank =null ) {
	local s, startpos, text
	if ( M && rank ) {
		s = null
		foreach (_ in ::jobban_keylist ) {
			s = _
			if ( ::findtext( s, "" + M.ckey + " - " + rank, 1, null ) == 1 ) {
				startpos = ::findtext( s, "## ", 1, null ) + 3
				if ( startpos && startpos < ::length( s ) ) {
					text = ::copytext( s, startpos, 0 )
					if ( text ) {
						return text
					}
				}
				return "Reason Unspecified"
			}
		}
	}
	return 0
}

function key_name( whom =null, include_link =null, include_name =null ) {
	local M, C, key, ckey, _default
	if ( include_link == null ) {
		include_link = null
	}
	if ( include_name == null ) {
		include_name = 1
	}
	if ( !whom ) {
		return "*null*"
	}
	if ( whom instanceof BAD_GOOFY_EXPANSION??? ) {
		C = whom
		M = C.mob
		key = C.key
		ckey = C.ckey
	} else if ( ::ismob( whom ) ) {
		M = whom
		C = M.client
		key = M.key
		ckey = M.ckey
	} else if ( ::istext( whom ) ) {
		key = whom
		ckey = ::ckey( whom )
		C = ::directory[ckey]
		if ( C ) {
			M = C.mob
		}
	} else {
		return "*invalid*"
	}
	_default = ""
	if ( !ckey ) {
		include_link = 0
	}
	if ( key ) {
		if ( C && C.holder && C.holder.fakekey && !include_name ) {
			if ( include_link ) {
				_default += "<a href='?priv_msg=" + C.findStealthKey() + "'>"
			}
			_default += "Administrator"
		} else {
			if ( include_link ) {
				_default += "<a href='?priv_msg=" + ckey + "'>"
			}
			_default += key
		}
		if ( !C ) {
			_default += "[DC]"
		}
		if ( include_link ) {
			_default += "</a>"
		}
	} else {
		_default += "*no key*"
	}
	if ( include_name && M ) {
		if ( M.real_name ) {
			_default += "/(" + M.real_name + ")"
		} else if ( M.name ) {
			_default += "/(" + M.name + ")"
		}
	}
	return _default
	return _default
}

function key_name_admin( whom =null, include_name =null ) {
	if ( include_name == null ) {
		include_name = 1
	}
	return ::key_name( whom, 1, include_name )
}

function keywords_lookup( msg =null ) {
	local adminhelp_ignored_words, msglist, surnames, forenames, ckeys, M, indexing, string, L, surname_found, i, word, ai_found, mobs_found, original_word, found
	adminhelp_ignored_words = ::List([ "unknown", "the", "a", "an", "of", "monkey", "alien", "as", "i" ])
	msglist = ::text2list( msg, " " )
	surnames = ::List()
	forenames = ::List()
	ckeys = ::List()
	M = null
	foreach (_ in ::mob_list ) {
		M = _
		indexing = ::List([ M.real_name, M.name ])
		if ( M.mind ) {
			indexing += M.mind.name
		}
		string = null
		foreach (_ in indexing ) {
			string = _
			L = ::text2list( string, " " )
			surname_found = 0
			i = null
			i = L.len
			while (i >= 1) {
				word = ::ckey( L[i] )
				if ( word ) {
					surnames[word] = M
					surname_found = i
					break
				}
				i--
			}
			i = null
			i = 1
			while (i < surname_found) {
				word = ::ckey( L[i] )
				if ( word ) {
					forenames[word] = M
				}
				i++
			}
			ckeys[M.ckey] = M
		}
	}
	ai_found = 0
	msg = ""
	mobs_found = ::List()
	original_word = null
	foreach (_ in msglist ) {
		original_word = _
		word = ::ckey( original_word )
		if ( word ) {
			if ( !( word in adminhelp_ignored_words ) ) {
				if ( word == "ai" ) {
					ai_found = 1
				} else {
					found = ckeys[word]
					if ( !found ) {
						found = surnames[word]
						if ( !found ) {
							found = forenames[word]
						}
					}
					if ( found ) {
						if ( !( found in mobs_found ) ) {
							mobs_found += found
							if ( !ai_found && found instanceof ::Mob_Living_Silicon_Ai ) {
								ai_found = 1
							}
							msg += ::Txt().item( original_word ).str( "<font size='1' color='black'>(<A HREF='?_src_=holder;adminmoreinfo=" ).ref( found ).str( "'>?</A>|<A HREF='?_src_=holder;adminplayerobservefollow=" ).ref( found ).str( "'>F</A>)</font> " )
							continue
						}
					}
				}
			}
		}
		msg += "" + original_word + " "
	}
	return msg
}

function list2json( L =null ) {
	return ::_jsonw.WriteObject( L )
}

function list2stickyban( ban =null ) {
	if ( !ban || !( ban instanceof ::List ) ) {
		return
	}
	_default = ban.Copy()
	if ( _default.keys ) {
		_default.keys = ::list2text( _default.keys, "," )
	}
	if ( _default.type ) {
		_default.type = ::list2text( _default.type, "," )
	}
	if ( _default.IP ) {
		_default.IP = ::list2text( _default.IP, "," )
	}
	if ( _default.computer_id ) {
		_default.computer_id = ::list2text( _default.computer_id, "," )
	}
	_default = ::list2params( _default )
	return _default
}

function list2text( ls =null, sep =null ) {
	local l, i, _default
	if ( ls.len <= 1 ) {
		return ls.len ? ls[1] : ""
	}
	l = ls.len
	i = 0
	if ( sep != null ) {
		_default = "" + ls[++i]
		if ( l - 1 & 1 ) {
			_default = "" + _default + sep + ls[++i]
		}
		if ( l - i & 2 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i]
		}
		if ( l - i & 4 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
		if ( l - i & 8 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
		if ( l - i & 16 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
		if ( l - i & 32 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
		if ( l - i & 64 ) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
		while (l > i) {
			_default = "" + _default + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i] + sep + ls[++i]
		}
	} else {
		_default = "" + ls[++i]
		if ( l - 1 & 1 ) {
			_default += "" + ls[++i]
		}
		if ( l - i & 2 ) {
			_default = "" + _default + ls[++i] + ls[++i]
		}
		if ( l - i & 4 ) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
		if ( l - i & 8 ) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
		if ( l - i & 16 ) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
		if ( l - i & 32 ) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
		if ( l - i & 64 ) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
		while (l > i) {
			_default = "" + _default + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i] + ls[++i]
		}
	}
	return _default
}

function listclearnulls( L =null ) {
	local i, thing
	if ( L instanceof ::List ) {
		i = 1
		thing = null
		foreach (_ in L ) {
			thing = _
			if ( thing != null ) {
				i++
				continue
			}
			L.Cut( i, i + 1 )
		}
	}
}

function listgetindex( L =null, index =null ) {
	if ( L instanceof ::List ) {
		if ( ::isnum( index ) ) {
			if ( ::IsInRange( index, 1, L.len ) ) {
				return L[index]
			}
		} else if ( index in L ) {
			return L[index]
		}
	}
	return
}

function living_player_count(  ) {
	local living_player_count, mob
	living_player_count = 0
	mob = null
	foreach (_ in ::player_list ) {
		mob = _
		if ( mob in ::living_mob_list ) {
			living_player_count += 1
		}
	}
	return living_player_count
}

function lizard_name( gender =null ) {
	if ( gender == ::MALE ) {
		return "" + ::random.pick( ::lizard_names_male ) + "-" + ::random.pick( ::lizard_names_male )
	} else {
		return "" + ::random.pick( ::lizard_names_female ) + "-" + ::random.pick( ::lizard_names_female )
	}
}

function load_admin_ranks(  ) {
	local previous_rights, line, next, R, prev, query, rank_name, flags
	::admin_ranks.Cut()
	if ( ::config.admin_legacy_system ) {
		previous_rights = 0
		line = null
		foreach (_ in ::file2list( "config/admin_ranks.txt" ) ) {
			line = _
			if ( !line ) {
				continue
			}
			if ( ::findtextEx( line, "#", 1, 2 ) ) {
				continue
			}
			next = ::findtext( line, "=", 1, null )
			R = ::AdminRank( ::ckeyEx( ::copytext( line, 1, next ) ) )
			if ( !R ) {
				continue
			}
			::admin_ranks += R
			prev = ::findchar( line, "+-", next, 0 )
			while (prev) {
				next = ::findchar( line, "+-", prev + 1, 0 )
				R.process_keyword( ::copytext( line, prev, next ), previous_rights )
				prev = next
			}
			previous_rights = R.rights
		}
	} else {
		::establish_db_connection()
		if ( !::dbcon.IsConnected() ) {
			::game.log.write( "Failed to connect to database in load_admin_ranks(). Reverting to legacy system." )
			::diary.write( "Failed to connect to database in load_admin_ranks(). Reverting to legacy system." )
			::config.admin_legacy_system = 1
			::load_admin_ranks()
			return
		}
		query = ::dbcon.NewQuery( "SELECT rank, flags FROM " + ::format_table_name( "admin_ranks" ) )
		query.Execute()
		while (query.NextRow()) {
			rank_name = ::ckeyEx( query.item[1] )
			flags = query.item[2]
			if ( ::istext( flags ) ) {
				flags = ::text2num( flags )
			}
			R = ::AdminRank( rank_name, flags )
			if ( !R ) {
				continue
			}
			::admin_ranks += R
		}
	}
}

function load_admins(  ) {
	local C, rank_names, R, Lines, line, List, ckey, rank, D, query
	::admin_datums.Cut()
	C = null
	foreach (_ in ::admins ) {
		C = _
		if ( !( C instanceof BAD_GOOFY_EXPANSION??? ) ) {
			continue
		}
		C.remove_admin_verbs()
		C.holder = null
	}
	::admins.Cut()
	::load_admin_ranks()
	rank_names = ::List()
	R = null
	foreach (_ in ::admin_ranks ) {
		R = _
		if ( !( R instanceof ::AdminRank ) ) {
			continue
		}
		rank_names[R.name] = R
	}
	if ( ::config.admin_legacy_system ) {
		Lines = ::file2list( "config/admins.txt" )
		line = null
		foreach (_ in Lines ) {
			line = _
			if ( !::length( line ) ) {
				continue
			}
			if ( ::findtextEx( line, "#", 1, 2 ) ) {
				continue
			}
			List = ::text2list( line, "=" )
			if ( !List.len ) {
				continue
			}
			ckey = ::ckey( List[1] )
			if ( !ckey ) {
				continue
			}
			rank = ""
			if ( List.len >= 2 ) {
				rank = ::ckeyEx( List[2] )
			}
			D = ::Admins( rank_names[rank], ckey )
			if ( !D ) {
				continue
			}
			D.associate( ::directory[ckey] )
		}
	} else {
		::establish_db_connection()
		if ( !::dbcon.IsConnected() ) {
			::game.log.write( "Failed to connect to database in load_admins(). Reverting to legacy system." )
			::diary.write( "Failed to connect to database in load_admins(). Reverting to legacy system." )
			::config.admin_legacy_system = 1
			::load_admins()
			return
		}
		query = ::dbcon.NewQuery( "SELECT ckey, rank FROM " + ::format_table_name( "admin" ) )
		query.Execute()
		while (query.NextRow()) {
			ckey = ::ckey( query.item[1] )
			rank = ::ckeyEx( query.item[2] )
			if ( rank_names[rank] == null ) {
				::warning( "" + ( "Admin rank (" + rank + ") does not exist." ) + " in " + "code/modules/admin/admin_ranks.dm" + " at line " + 183 + " src: " + this + " usr: " + ::thread.user + "." )
				continue
			}
			D = ::Admins( rank_names[rank], ckey )
			if ( !D ) {
				continue
			}
			D.associate( ::directory[ckey] )
		}
	}
}

function load_library_db_to_cache(  ) {
	local query, newbook
	if ( ::cachedbooks ) {
		return
	}
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		return
	}
	::cachedbooks = ::List()
	query = ::dbcon.NewQuery( "SELECT id, author, title, category FROM " + ::format_table_name( "library" ) + " WHERE isnull(deleted)" )
	query.Execute()
	while (query.NextRow()) {
		newbook = ::Cachedbook()
		newbook.id = query.item[1]
		newbook.author = query.item[2]
		newbook.title = query.item[3]
		newbook.category = query.item[4]
		::cachedbooks += newbook
	}
}

function log_access( text =null ) {
	if ( ::config.log_access ) {
		::diary.write( "[" + ::time_stamp() + "]ACCESS: " + text )
	}
}

function log_admin( text =null ) {
	::admin_log.Add( text )
	if ( ::config.log_admin ) {
		::diary.write( "[" + ::time_stamp() + "]ADMIN: " + text )
	}
}

function log_attack( text =null ) {
	if ( ::config.log_attack ) {
		::diaryofmeanpeople.write( "[" + ::time_stamp() + "]ATTACK: " + text )
	}
}

function log_chat( text =null ) {
	if ( ::config.log_pda ) {
		::diary.write( "[" + ::time_stamp() + "]CHAT: " + text )
	}
}

function log_emote( text =null ) {
	if ( ::config.log_emote ) {
		::diary.write( "[" + ::time_stamp() + "]EMOTE: " + text )
	}
}

function log_game( text =null ) {
	if ( ::config.log_game ) {
		::diary.write( "[" + ::time_stamp() + "]GAME: " + text )
	}
}

function log_law( text =null ) {
	if ( ::config.log_law ) {
		::diary.write( "[" + ::time_stamp() + "]LAW: " + text )
	}
}

function log_ooc( text =null ) {
	if ( ::config.log_ooc ) {
		::diary.write( "[" + ::time_stamp() + "]OOC: " + text )
	}
}

function log_pda( text =null ) {
	if ( ::config.log_pda ) {
		::diary.write( "[" + ::time_stamp() + "]PDA: " + text )
	}
}

function log_prayer( text =null ) {
	if ( ::config.log_prayer ) {
		::diary.write( "[" + ::time_stamp() + "]PRAY: " + text )
	}
}

function log_say( text =null ) {
	if ( ::config.log_say ) {
		::diary.write( "[" + ::time_stamp() + "]SAY: " + text )
	}
}

function log_vote( text =null ) {
	if ( ::config.log_vote ) {
		::diary.write( "[" + ::time_stamp() + "]VOTE: " + text )
	}
}

function log_whisper( text =null ) {
	if ( ::config.log_whisper ) {
		::diary.write( "[" + ::time_stamp() + "]WHISPER: " + text )
	}
}

function machine_upgrade( M =null ) {
	local new_rating, P
	new_rating = ::input( "Enter new rating:", "Num", null, null, null, 8 )
	if ( new_rating && M.component_parts ) {
		P = null
		foreach (_ in M.component_parts ) {
			P = _
			if ( !( P instanceof ::Ent_Item_Weapon_StockParts ) ) {
				continue
			}
			P.rating = new_rating
		}
		M.RefreshParts()
	}
	::feedback_add_details( "admin_verb", "MU" )
}

function make_maint_all_access(  ) {
	local A, D
	A = null
	foreach (_ in ::game ) {
		A = _
		if ( !( A instanceof ::Area(2826) ) ) {
			continue
		}
		D = null
		foreach (_ in A ) {
			D = _
			if ( !( D instanceof ::Ent_Machinery_Door_Airlock ) ) {
				continue
			}
			D.emergency = 1
			D.$update icon( 0 )
		}
	}
	::minor_announce( "Access restrictions on maintenance and external airlocks have been lifted.", "Attention! Station-wide emergency declared!", 1 )
	::emergency_access = 1
}

function make_mining_asteroid_secret(  ) {
	local valid, T, sanity, room, turfs, x_size, y_size, areapoints, theme, walltypes, floortypes, treasureitems, fluffitems, floor, surroundings, emptyturfs, A, surprise, garbage
	valid = 0
	T = null
	sanity = 0
	room = null
	turfs = null
	x_size = 5
	y_size = 5
	areapoints = 0
	theme = "organharvest"
	walltypes = ::List({ [::Tile_Simulated_Mineral_Random]= 1, [::Tile_Simulated_Wall]= 3 })
	floortypes = ::List([ ::Tile_Simulated_Floor_Plasteel ])
	treasureitems = ::List()
	fluffitems = ::List()
	x_size = ::random.int( 3, 7 )
	y_size = ::random.int( 3, 7 )
	areapoints = x_size * y_size
	local _ = ::random.pick( ::possiblethemes ) // Was a switch-case, sorry for the mess.
	if ( _=="organharvest" ) {
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random_HighChance]= 1, [::Tile_Simulated_Wall]= 2, [::Tile_Simulated_Wall_RWall]= 2 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Plasteel, ::Tile_Simulated_Floor_Engine ])
		treasureitems = ::List({ [::Ent_Structure_Closet_Critter_Cat]= 2, [::Ent_Item_Weapon_CircularSaw]= 1, [::Ent_Machinery_Bot_Medbot_Mysterious]= 1 })
		fluffitems = ::List({ [::Ent_Item_Clothing_Glasses_Hud_Health]= 1, [::Ent_Item_Device_MassSpectrometer_Adv]= 1, [::Ent_Item_Weapon_SurgicalDrapes]= 2, [::Ent_Item_Weapon_Tank_Internals_Anesthetic]= 1, [::Ent_Item_Weapon_Storage_Firstaid_Regular]= 3, [::Ent_Item_Weapon_Scalpel]= 1, [::Ent_Structure_Optable]= 1, [::Ent_Structure_Closet_Crate_Freezer]= 2, [::Ent_Item_Organ_Internal_Appendix]= 2, [::Ent_Effect_Decal_Cleanable_Blood]= 5 })
	} else if ( _=="cult" ) {
		theme = "cult"
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random_HighChance]= 1, [::Tile_Simulated_Wall_Cult]= 3 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Plasteel_Cult ])
		treasureitems = ::List({ [::Mob_Living_SimpleAnimal_Hostile_Creature]= 3, [::Ent_Item_Clothing_Suit_Cultrobes]= 2, [::Ent_Item_Weapon_Bedsheet_Cult]= 2, [::Ent_Item_Clothing_Suit_Space_Cult]= 1, [::Ent_Item_Device_Soulstone_Anybody]= 1 })
		fluffitems = ::List({ [::Ent_Item_Clothing_Shoes_Cult]= 1, [::Ent_Item_Clothing_Head_Helmet_Space_Cult]= 1, [::Ent_Item_Weapon_Ectoplasm]= 3, [::Ent_Structure_Table_Wood]= 2, [::Ent_Effect_Decal_Cleanable_Blood]= 4, [::Ent_Item_Organ_Internal_Heart]= 2, [::Ent_Item_Toy_Crayon_Red]= 2, [::Ent_Structure_Cult_Talisman]= 1, [::Ent_Effect_Gibspawner]= 1, [::Ent_Effect_Gateway]= 1 })
	} else if ( _=="wizden" ) {
		theme = "wizden"
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random_HighChance]= 1, [::Tile_Simulated_Wall_Mineral_Plasma]= 3 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Wood ])
		treasureitems = ::List({ [::Ent_Item_Voodoo]= 3, [::Ent_Item_Toy_Katana]= 3, [::Ent_Structure_Constructshell]= 1, [::Ent_Item_Weapon_Spellbook_Oneuse_Smoke]= 1, [::Ent_Item_Weapon_Spellbook_Oneuse_Forcewall]= 1, [::Ent_Item_Clothing_Head_Wizard_Red]= 2, [::Ent_Item_Weapon_Spellbook_Oneuse_Blind]= 1, [::Ent_Item_Weapon_Veilrender_Vealrender]= 2 })
		fluffitems = ::List({ [::Ent_Item_Weapon_Coin_Mythril]= 3, [::Ent_Effect_Decal_Cleanable_Dirt]= 3, [::Ent_Item_Weapon_Staff]= 2, [::Ent_Item_Weapon_Dice]= 3, [::Ent_Item_Trash_Candle]= 3, [::Ent_Item_Weapon_Storage_Belt_Soulstone]= 1, [::Ent_Structure_Dresser]= 1, [::Ent_Structure_Safe_Floor]= 1 })
	} else if ( _=="cavein" ) {
		theme = "cavein"
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random_HighChance]= 1 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Plating_Asteroid_Airless, ::Tile_Simulated_Floor_Plating_Beach_Sand ])
		treasureitems = ::List({ [::Ent_Item_Weapon_Pickaxe_Drill_Jackhammer]= 5, [::Ent_Item_Weapon_Resonator]= 1, [::Ent_Item_Weapon_Gun_Energy_KineticAccelerator]= 1, [::Ent_Item_Weapon_Pickaxe_Drill_Diamonddrill]= 2, [::Ent_Mecha_Working_Ripley_Mining]= 1 })
		fluffitems = ::List({ [::Ent_Item_Weapon_Tank_Internals_Oxygen_Red]= 2, [::Ent_Item_Weapon_ReagentContainers_Food_Snacks_Grown_Chili]= 1, [::Ent_Item_Clothing_Under_Overalls]= 1, [::Ent_Effect_Decal_Remains_Human]= 1, [::Ent_Effect_Decal_Cleanable_Blood]= 3 })
	} else if ( _=="xenoden" ) {
		theme = "xenoden"
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random_HighChance]= 1 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Plating_Asteroid_Airless, ::Tile_Simulated_Floor_Plating_Beach_Sand ])
		treasureitems = ::List({ [::Ent_Item_Clothing_Mask_Facehugger]= 1 })
		fluffitems = ::List({ [::Ent_Effect_Decal_Cleanable_Xenoblood_Xsplatter]= 5, [::Ent_Effect_Decal_Remains_Human]= 1 })
	} else if ( _=="hitech" ) {
		theme = "hitech"
		walltypes = ::List({ [::Tile_Simulated_Mineral_Random]= 1, [::Tile_Simulated_Wall_RWall]= 5 })
		floortypes = ::List([ ::Tile_Simulated_Floor_Greengrid, ::Tile_Simulated_Floor_Bluegrid ])
		treasureitems = ::List({ [::Ent_Machinery_Biogenerator]= 1, [::Ent_Machinery_RND_Protolathe]= 1, [::Ent_Machinery_Computer_Telescience]= 1, [::Ent_Machinery_ChemDispenser_Constructable]= 1, [::Ent_Item_Weapon_StockParts_Cell_Hyper]= 1 })
		fluffitems = ::List({ [::Ent_Structure_MechaWreckage_Phazon]= 1, [::Ent_Item_Device_Pda_Clear]= 1, [::Ent_Item_Weapon_StockParts_Capacitor_Super]= 3, [::Ent_Item_Weapon_StockParts_Manipulator_Pico]= 3, [::Ent_Item_Weapon_StockParts_MatterBin_Super]= 3, [::Ent_Item_Weapon_StockParts_ScanningModule_Phasic]= 3, [::Ent_Structure_Table_Reinforced]= 2 })
	} else if ( _=="speakeasy" ) {
		theme = "speakeasy"
		floortypes = ::List([ ::Tile_Simulated_Floor_Plasteel, ::Tile_Simulated_Floor_Wood ])
		treasureitems = ::List({ [::Ent_Machinery_Vending_Coffee]= 3, [::Ent_Machinery_Computer_Security_WoodenTv]= 4, [::Ent_Machinery_Reagentgrinder]= 2, [::Ent_Item_Weapon_Storage_Backpack_SatchelFlat]= 1, [::Ent_Item_Weapon_Gun_Projectile_Revolver_Doublebarrel]= 1, [::Ent_Item_Weapon_Melee_Energy_Sword_Pirate]= 1 })
		fluffitems = ::List({ [::Ent_Item_Clothing_Shoes_Laceup]= 2, [::Ent_Item_Weapon_ReagentContainers_Food_Drinks_Bottle_Whiskey]= 3, [::Ent_Item_Weapon_ReagentContainers_Food_Drinks_Bottle_Wine]= 3, [::Ent_Item_Weapon_ReagentContainers_Food_Drinks_Shaker]= 1, [::Ent_Item_Stack_Spacecash_C500]= 4, [::Ent_Structure_ReagentDispensers_Beerkeg]= 1, [::Ent_Structure_Table_Wood]= 2 })
	} else if ( _=="plantlab" ) {
		theme = "plantlab"
		treasureitems = ::List({ [::Ent_Item_Seeds_Cashseed]= 2, [::Ent_Item_Seeds_CoffeeRobustaSeed]= 2, [::Ent_Item_Seeds_Bluetomatoseed]= 2, [::Ent_Item_Seeds_Bluespacetomatoseed]= 2, [::Ent_Item_Seeds_Novaflowerseed]= 2, [::Ent_Item_Weapon_Gun_Energy_Floragun]= 1 })
		fluffitems = ::List({ [::Ent_Item_Weapon_ReagentContainers_Glass_Bottle_Ammonia]= 3, [::Ent_Item_Weapon_ReagentContainers_Glass_Bottle_Diethylamine]= 3, [::Ent_Item_Weapon_ReagentContainers_Syringe_Charcoal]= 2, [::Ent_Effect_Glowshroom_Single]= 2, [::Ent_Machinery_Hydroponics]= 1, [::Ent_Structure_Table_Reinforced]= 2, [::Ent_Structure_Flora_Kirbyplants]= 1 })
	}
	::possiblethemes -= theme
	floor = ::random.pick( floortypes )
	turfs = ::get_area_turfs( ::Area(3120) )
	if ( !turfs.len ) {
		return 0
	}
	while (!valid) {
		valid = 1
		sanity++
		if ( sanity > 100 ) {
			return 0
		}
		T = ::random.pick( turfs )
		if ( !T ) {
			return 0
		}
		surroundings = ::List()
		surroundings += ::range( 7, ::locate3( T.x, T.y, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x + x_size, T.y, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x, T.y + y_size, T.z ) )
		surroundings += ::range( 7, ::locate3( T.x + x_size, T.y + y_size, T.z ) )
		if ( ::locate_in( ::Area(3119), surroundings ) ) {
			valid = 0
			continue
		}
		if ( ::locate_in( ::Tile_Space, surroundings ) ) {
			valid = 0
			continue
		}
		if ( ::locate_in( ::Area(2768), surroundings ) ) {
			valid = 0
			continue
		}
		if ( ::locate_in( ::Tile_Simulated_Floor_Plating_Asteroid_Airless, ::range( 5, T ) ) ) {
			valid = 0
			continue
		}
	}
	if ( !T ) {
		return 0
	}
	room = ::spawn_room( T, x_size, y_size, walltypes, floor )
	if ( room ) {
		emptyturfs = room.floors
		A = null
		foreach (_ in emptyturfs ) {
			A = _
			if ( !( A instanceof ::Tile_Simulated_Floor ) ) {
				continue
			}
			if ( A instanceof ::Tile_Simulated_Floor ) {
				::thread.schedule( 2, function() {
					A.fullUpdateMineralOverlays()
					return
				})
			}
		}
		T = ::random.pick( emptyturfs )
		if ( T ) {
			::Ent_Effect_Glowshroom_Single( T )
			surprise = null
			surprise = ::pickweight( treasureitems )
			surprise( T )
			emptyturfs -= T
			while (areapoints >= 10) {
				T = ::random.pick( emptyturfs )
				garbage = null
				garbage = ::pickweight( fluffitems )
				garbage( T )
				areapoints -= 5
				emptyturfs -= T
			}
		}
	}
	return 1
}

function make_ne_corner( adjacencies =null ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 1 && adjacencies & 4 ) {
		if ( adjacencies & 16 ) {
			sdir = "f"
		} else {
			sdir = "ne"
		}
	} else if ( adjacencies & 1 ) {
		sdir = "n"
	} else if ( adjacencies & 4 ) {
		sdir = "e"
	}
	return "2-" + sdir
}

function make_nw_corner( adjacencies =null ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 1 && adjacencies & 8 ) {
		if ( adjacencies & 32 ) {
			sdir = "f"
		} else {
			sdir = "nw"
		}
	} else if ( adjacencies & 1 ) {
		sdir = "n"
	} else if ( adjacencies & 8 ) {
		sdir = "w"
	}
	return "1-" + sdir
}

function make_progress_bar( current_number =null, goal_number =null, target =null ) {
	local progbar
	if ( current_number && goal_number && target ) {
		progbar = ::Image.lcall( ::List({ ["icon_state"]= "prog_bar_0", ["loc"]= target, ["icon"]= ::Rsc(15) }) )
		progbar.icon_state = "prog_bar_" + ::math.round( current_number / goal_number * 100, 10 )
		progbar.pixel_y = 32
		return progbar
	}
}

function make_se_corner( adjacencies =null ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 2 && adjacencies & 4 ) {
		if ( adjacencies & 64 ) {
			sdir = "f"
		} else {
			sdir = "se"
		}
	} else if ( adjacencies & 2 ) {
		sdir = "s"
	} else if ( adjacencies & 4 ) {
		sdir = "e"
	}
	return "4-" + sdir
}

function make_sw_corner( adjacencies =null ) {
	local sdir
	sdir = "i"
	if ( adjacencies & 2 && adjacencies & 8 ) {
		if ( adjacencies & 128 ) {
			sdir = "f"
		} else {
			sdir = "sw"
		}
	} else if ( adjacencies & 2 ) {
		sdir = "s"
	} else if ( adjacencies & 8 ) {
		sdir = "w"
	}
	return "3-" + sdir
}

function makeBody( G_found =null ) {
	local new_character
	if ( !G_found || !G_found.key ) {
		return
	}
	new_character = ::Mob_Living_Carbon_Human( ::random.pick( ::latejoin ) )
	G_found.client.prefs.copy_to( new_character )
	new_character.dna.update_dna_identity()
	new_character.key = G_found.key
	return new_character
}

function makeNewConstruct( ctype =null, target =null, stoner =null, cultoverride =null ) {
	local newstruct
	if ( stoner == null ) {
		stoner = null
	}
	if ( cultoverride == null ) {
		cultoverride = 0
	}
	newstruct = ctype( ::get_turf( target ) )
	newstruct.faction = newstruct.faction | ::Txt().ref( stoner )
	newstruct.key = target.key
	if ( stoner && ::iscultist( stoner ) || cultoverride ) {
		if ( ::ticker.mode.name == "cult" ) {
			::ticker.mode.add_cultist( newstruct.mind )
		} else {
			::ticker.mode.cult += newstruct.mind
		}
		::ticker.mode.update_cult_icons_added( newstruct.mind )
	}
	newstruct.write( newstruct.playstyle_string )
	if ( stoner && ::iswizard( stoner ) ) {
		newstruct.write( "<B>You are still bound to serve your creator, follow their orders and help them complete their goals at all costs.</B>" )
	} else if ( stoner && ::iscultist( stoner ) ) {
		newstruct.write( "<B>You are still bound to serve the cult, follow their orders and help them complete their goals at all costs.</B>" )
	} else {
		newstruct.write( "<B>You are still bound to serve your creator, follow their orders and help them complete their goals at all costs.</B>" )
	}
	::get_verb( newstruct, "Cancel Camera View" )()
}

function maprotate(  ) {
	local players, mapvotes, c, vote, map, VM, pickedmap, _default
	return
	players = ::clients.len
	mapvotes = ::List()
	c = null
	foreach (_ in ::clients ) {
		c = _
		if ( !( c instanceof BAD_GOOFY_EXPANSION??? ) ) {
			continue
		}
		vote = c.prefs.preferred_map
		if ( !vote ) {
			if ( ::config.defaultmap ) {
				mapvotes[::config.defaultmap.name] += 1
			}
			continue
		}
		mapvotes[vote] += 1
	}
	map = null
	foreach (_ in mapvotes ) {
		map = _
		if ( !map ) {
			mapvotes.Remove( map )
		}
		if ( !( map in ::config.maplist ) ) {
			mapvotes.Remove( map )
			continue
		}
		VM = ::config.maplist[map]
		if ( !VM ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.voteweight <= 0 ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.minusers > 0 && players < VM.minusers ) {
			mapvotes.Remove( map )
			continue
		}
		if ( VM.maxusers > 0 && players > VM.maxusers ) {
			mapvotes.Remove( map )
			continue
		}
		mapvotes[map] = mapvotes[map] * VM.voteweight
	}
	pickedmap = ::pickweight( mapvotes )
	if ( !pickedmap ) {
		return
	}
	VM = ::config.maplist[pickedmap]
	::message_admins( "Randomly rotating map to " + VM.name + "(" + VM.friendlyname + ")" )
	_default = ::changemap( VM )
	if ( _default == 0 ) {
		::game.write( "<span class='boldannounce'>Map rotation has chosen " + VM.friendlyname + " for next round!</span>" )
	}
	return _default
}

function merge_powernets( net1 =null, net2 =null ) {
	local temp, Cable, Node
	if ( !net1 || !net2 ) {
		return
	}
	if ( net1 == net2 ) {
		return
	}
	if ( net1.cables.len < net2.cables.len ) {
		temp = net1
		net1 = net2
		net2 = temp
	}
	Cable = null
	foreach (_ in net2.cables ) {
		Cable = _
		if ( !( Cable instanceof ::Ent_Structure_Cable ) ) {
			continue
		}
		net1.add_cable( Cable )
	}
	Node = null
	foreach (_ in net2.nodes ) {
		Node = _
		if ( !( Node instanceof ::Ent_Machinery_Power ) ) {
			continue
		}
		if ( !Node.connect_to_network() ) {
			Node.disconnect_from_network()
		}
	}
	return net1
}

function merge_text( into =null, from =null, null_char =null ) {
	local null_ascii, previous, start, end, i, ascii, _default
	if ( null_char == null ) {
		null_char = "_"
	}
	_default = ""
	if ( !::istext( into ) ) {
		into = ""
	}
	if ( !::istext( from ) ) {
		from = ""
	}
	null_ascii = ::istext( null_char ) ? ::text2ascii( null_char, 1 ) : null_char
	previous = 0
	start = 1
	end = ::length( into ) + 1
	i = null
	i = 1
	while (i < end) {
		ascii = ::text2ascii( from, i )
		if ( ascii == null_ascii ) {
			if ( previous != 1 ) {
				_default += ::copytext( from, start, i )
				start = i
				previous = 1
			}
		} else if ( previous != 0 ) {
			_default += ::copytext( into, start, i )
			start = i
			previous = 0
		}
		i++
	}
	if ( previous == 0 ) {
		_default += ::copytext( from, start, end )
	} else {
		_default += ::copytext( into, start, end )
	}
	return _default
}

function message_admins( msg =null ) {
	msg = "<span class=\"admin\"><span class=\"prefix\">ADMIN LOG:</span> <span class=\"message\">" + msg + "</span></span>"
	::admins.write( msg )
}

function message_spans_start( spans =null ) {
	local output, S
	output = "<span class='"
	S = null
	foreach (_ in spans ) {
		S = _
		output = "" + output + S + " "
	}
	output = "" + output + "'>"
	return output
}

function mineral_scan_pulse( mobs =null, T =null, range =null ) {
	local minerals, M, user, C, F, I
	if ( range == null ) {
		range = ::game.view
	}
	minerals = ::List()
	M = null
	foreach (_ in ::range( range, T ) ) {
		M = _
		if ( !( M instanceof ::Tile_Simulated_Mineral ) ) {
			continue
		}
		if ( M.scan_state ) {
			minerals += M
		}
	}
	if ( minerals.len ) {
		user = null
		foreach (_ in mobs ) {
			user = _
			if ( user.client ) {
				C = user.client
				M = null
				foreach (_ in minerals ) {
					M = _
					if ( !( M instanceof ::Tile_Simulated_Mineral ) ) {
						continue
					}
					F = ::get_turf( M )
					I = ::Image.lcall( ::List({ ["layer"]= 18, ["icon_state"]= M.scan_state, ["loc"]= F, [1]= ::Rsc(61) }) )
					C.images += I
					::thread.schedule( 30, function() {
						if ( C ) {
							C.images -= I
						}
						return
					})
				}
			}
		}
	}
}

function minor_announce( message =null, title =null, alert =null ) {
	local M
	if ( title == null ) {
		title = "Attention:"
	}
	if ( !message ) {
		return
	}
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( !( M instanceof ::Mob_NewPlayer ) && !M.ear_deaf ) {
			M.write( "<b><font size = 3><font color = red>" + title + "</font color><BR>" + message + "</font size></b><BR>" )
			if ( alert ) {
				M.write( ::Sound( ::Rsc(63) ) )
			} else {
				M.write( ::Sound( ::Rsc(9) ) )
			}
		}
	}
}

function mix_color_from_reagents( reagent_list =null ) {
	local color, vol_counter, vol_temp, R
	if ( !( reagent_list instanceof ::List ) ) {
		return
	}
	vol_counter = 0
	R = null
	foreach (_ in reagent_list ) {
		R = _
		if ( !( R instanceof ::Reagent ) ) {
			continue
		}
		vol_temp = R.volume
		vol_counter += vol_temp
		if ( !color ) {
			color = R.color
		} else if ( ::length( color ) >= ::length( R.color ) ) {
			color = ::BlendRGB( color, R.color, vol_temp / vol_counter )
		} else {
			color = ::BlendRGB( R.color, color, vol_temp / vol_counter )
		}
	}
	return color
}

function moveElement( L =null, fromIndex =null, toIndex =null ) {
	if ( fromIndex == toIndex || fromIndex + 1 == toIndex ) {
		return
	}
	if ( fromIndex > toIndex ) {
		fromIndex++
	}
	L.Insert( toIndex, null )
	L.$Swap( fromIndex, toIndex )
	L.$Cut( fromIndex, fromIndex + 1 )
}

function near_camera( M =null ) {
	local R
	if ( !::isturf( M.loc ) ) {
		return 0
	}
	if ( M instanceof ::Mob_Living_Silicon_Robot ) {
		R = M
		if ( !( R.camera && R.camera.f_can_use() ) && !::cameranet.checkCameraVis( M ) ) {
			return 0
		}
	} else if ( !::cameranet.checkCameraVis( M ) ) {
		return 0
	}
	return 1
}

function new_station_name(  ) {
	local random, name, new_station_name, holiday_name, holiday
	random = ::random.int( 1, 5 )
	name = ""
	new_station_name = ""
	if ( ::random.chance( 10 ) ) {
		local _ = ::random.pick([ "Imperium", "Heretical", "Cuban", "Psychic", "Elegant", "Common", "Uncommon", "Rare", "Unique", "Houseruled", "Religious", "Atheist", "Traditional", "Houseruled", "Mad", "Super", "Ultra", "Secret", "Top Secret", "Deep", "Death", "Zybourne", "Central", "Main", "Government", "Uoi", "Fat", "Automated", "Experimental", "Augmented" ])
		name = _
		new_station_name = name + " "
		name = ""
	}
	holiday_name = null
	foreach (_ in ::SSevent.holidays ) {
		holiday_name = _
		if ( holiday_name == "Friday the 13th" ) {
			random = 13
		}
		holiday = ::SSevent.holidays[holiday_name]
		name = holiday.getStationPrefix()
	}
	if ( !name ) {
		local _ = ::random.pick([ "", "Stanford", "Dorf", "Alium", "Prefix", "Clowning", "Aegis", "Ishimura", "Scaredy", "Death-World", "Mime", "Honk", "Rogue", "MacRagge", "Ultrameens", "Safety", "Paranoia", "Explosive", "Neckbear", "Donk", "Muppet", "North", "West", "East", "South", "Slant-ways", "Widdershins", "Rimward", "Expensive", "Procreatory", "Imperial", "Unidentified", "Immoral", "Carp", "Ork", "Pete", "Control", "Nettle", "Aspie", "Class", "Crab", "Fist", "Corrogated", "Skeleton", "Race", "Fatguy", "Gentleman", "Capitalist", "Communist", "Bear", "Beard", "Derp", "Space", "Spess", "Star", "Moon", "System", "Mining", "Neckbeard", "Research", "Supply", "Military", "Orbital", "Battle", "Science", "Asteroid", "Home", "Production", "Transport", "Delivery", "Extraplanetary", "Orbital", "Correctional", "Robot", "Hats", "Pizza" ])
		name = _
	}
	if ( name ) {
		new_station_name += name + " "
	}
	local _ = ::random.pick([ "Station", "Fortress", "Frontier", "Suffix", "Death-trap", "Space-hulk", "Lab", "Hazard", "Spess Junk", "Fishery", "No-Moon", "Tomb", "Crypt", "Hut", "Monkey", "Bomb", "Trade Post", "Fortress", "Village", "Town", "City", "Edition", "Hive", "Complex", "Base", "Facility", "Depot", "Outpost", "Installation", "Drydock", "Observatory", "Array", "Relay", "Monitor", "Platform", "Construct", "Hangar", "Prison", "Center", "Port", "Waystation", "Factory", "Waypoint", "Stopover", "Hub", "HQ", "Office", "Object", "Fortification", "Colony", "Planet-Cracker", "Roost", "Fat Camp" ])
	name = _
	new_station_name += name + " "
	local _ = random // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		new_station_name += "" + ::random.int( 1, 99 )
	} else if ( _==2 ) {
		local _ = ::random.pick([ "Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu", "Xi", "Omicron", "Pi", "Rho", "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega" ])
		new_station_name += _
	} else if ( _==3 ) {
		local _ = ::random.pick([ "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "XIII", "XIV", "XV", "XVI", "XVII", "XVIII", "XIX", "XX" ])
		new_station_name += _
	} else if ( _==4 ) {
		local _ = ::random.pick([ "Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliet", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu" ])
		new_station_name += _
	} else if ( _==5 ) {
		local _ = ::random.pick([ "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen" ])
		new_station_name += _
	} else if ( _==13 ) {
		local _ = ::random.pick([ "13", "XIII", "Thirteen" ])
		new_station_name += _
	}
	return new_station_name
}

function ninjaspeak( n =null ) {
	local te, t, p, n_letter, n_mod
	te = ::html_decode( n )
	t = ""
	n = ::length( n )
	p = 1
	while (p <= n) {
		n_letter = null
		n_mod = ::random.int( 1, 4 )
		if ( p + n_mod > n + 1 ) {
			n_letter = ::copytext( te, p, n + 1 )
		} else {
			n_letter = ::copytext( te, p, p + n_mod )
		}
		if ( ::random.chance( 50 ) ) {
			if ( ::random.chance( 30 ) ) {
				n_letter = "" + n_letter + "-" + n_letter + "-" + n_letter
			} else {
				n_letter = "" + n_letter + "-" + n_letter
			}
		} else {
			n_letter = "" + n_letter
		}
		t = "" + t + n_letter
		p = p + n_mod
	}
	return ::copytext( ::sanitize( t ), 1, 1024 )
}

function notice( msg =null ) {
	::game.log.write( "## NOTICE: " + msg )
}

function nukelastname( M =null ) {
	local randomname, newname
	randomname = ::random.pick( ::last_names )
	local _ = ::random.pick([ "Czar", "Boss", "Commander", "Chief", "Kingpin", "Director", "Overlord" ])
	newname = ::copytext( ::sanitize( ::input( M, "You are the nuke operative " + _ + ". Please choose a last name for your family.", "Name change", randomname, null, 0 ) ), 1, 26 )
	if ( !newname ) {
		newname = randomname
	} else if ( newname == "Unknown" || newname == "floor" || newname == "wall" || newname == "rwall" || newname == "_" ) {
		M.write( "That name is reserved." )
		return ::nukelastname( M )
	}
	return ::capitalize( newname )
}

function NukeNameAssign( lastname =null, syndicates =null ) {
	local synd_mind, H
	synd_mind = null
	foreach (_ in syndicates ) {
		synd_mind = _
		if ( !( synd_mind instanceof ::Mind ) ) {
			continue
		}
		H = synd_mind.current
		synd_mind.name = H.dna.species.random_name( H.gender, 0, lastname )
		synd_mind.current.real_name = synd_mind.name
	}
	return
}

function num2hex( num =null, len =null ) {
	local i, remainder, _default
	if ( len == null ) {
		len = 2
	}
	if ( !::isnum( num ) ) {
		num = 0
	}
	num = ::math.round( ::math.abs( num ) )
	_default = ""
	i = 0
	while (1) {
		if ( len <= 0 ) {
			if ( !num ) {
				break
			}
		} else if ( i >= len ) {
			break
		}
		remainder = num / 16
		num = ::math.round( remainder )
		remainder = ( remainder - num ) * 16
		local _ = remainder // Was a switch-case, sorry for the mess.
		if ( _==9 || _==8 || _==7 || _==6 || _==5 || _==4 || _==3 || _==2 || _==1 ) {
			_default = "" + remainder + _default
		} else if ( _==10 || _==11 || _==12 || _==13 || _==14 || _==15 ) {
			_default = ::ascii2text( remainder + 87 ) + _default
		} else {
			_default = "0" + _default
		}
		i++
	}
	return _default
	return _default
}

function onclose( user =null, windowid =null, ref =null ) {
	local param
	if ( ref == null ) {
		ref = null
	}
	if ( !user.client ) {
		return
	}
	param = "null"
	if ( ref ) {
		param = ::Txt().ref( ref )
	}
	::winset( user, windowid, "on-close=\".windowclose " + param + "\"" )
}

function parse_zone( zone =null ) {
	if ( zone == "r_hand" ) {
		return "right hand"
	} else if ( zone == "l_hand" ) {
		return "left hand"
	} else if ( zone == "l_arm" ) {
		return "left arm"
	} else if ( zone == "r_arm" ) {
		return "right arm"
	} else if ( zone == "l_leg" ) {
		return "left leg"
	} else if ( zone == "r_leg" ) {
		return "right leg"
	} else if ( zone == "l_foot" ) {
		return "left foot"
	} else if ( zone == "r_foot" ) {
		return "right foot"
	} else {
		return zone
	}
}

function parsepencode( t =null, user =null, signfont =null ) {
	if ( user == null ) {
		user = null
	}
	if ( signfont == null ) {
		signfont = "Times New Roman"
	}
	if ( ::length( t ) < 1 ) {
		return
	}
	t = ::replacetext( t, "[center]", "<center>" )
	t = ::replacetext( t, "[/center]", "</center>" )
	t = ::replacetext( t, "[br]", "<BR>" )
	t = ::replacetext( t, "[b]", "<B>" )
	t = ::replacetext( t, "[/b]", "</B>" )
	t = ::replacetext( t, "[i]", "<I>" )
	t = ::replacetext( t, "[/i]", "</I>" )
	t = ::replacetext( t, "[u]", "<U>" )
	t = ::replacetext( t, "[/u]", "</U>" )
	t = ::replacetext( t, "[large]", "<font size=\"4\">" )
	t = ::replacetext( t, "[/large]", "</font>" )
	if ( user ) {
		t = ::replacetext( t, "[sign]", "<font face=\"" + signfont + "\"><i>" + user.real_name + "</i></font>" )
	} else {
		t = ::replacetext( t, "[sign]", "" )
	}
	t = ::replacetext( t, "[field]", "<span class=\"paper_field\"></span>" )
	t = ::replacetext( t, "[*]", "<li>" )
	t = ::replacetext( t, "[hr]", "<HR>" )
	t = ::replacetext( t, "[small]", "<font size = \"1\">" )
	t = ::replacetext( t, "[/small]", "</font>" )
	t = ::replacetext( t, "[list]", "<ul>" )
	t = ::replacetext( t, "[/list]", "</ul>" )
	return t
}

function pick_n_take( L =null ) {
	local picked, _default
	if ( L.len ) {
		picked = ::random.int( 1, L.len )
		_default = L[picked]
		L.$Cut( picked, picked + 1 )
	}
	return _default
}

function pickweight( L =null ) {
	local total, item
	total = 0
	foreach (_ in L ) {
		item = _
		if ( !L[item] ) {
			L[item] = 1
		}
		total += L[item]
	}
	total = ::random.int( 1, total )
	foreach (_ in L ) {
		item = _
		total -= L[item]
		if ( total <= 0 ) {
			return item
		}
	}
	return
}

function PlaceInPool( diver =null, destroy =null ) {
	if ( destroy == null ) {
		destroy = 1
	}
	if ( !( diver instanceof ::Datum ) ) {
		return
	}
	if ( diver in ::GlobalPool[diver.type] ) {
		return
	}
	if ( !::GlobalPool[diver.type] ) {
		::GlobalPool[diver.type] = ::List()
	}
	::GlobalPool[diver.type] = ::GlobalPool[diver.type] | diver
	if ( destroy ) {
		diver.Destroy()
	}
	diver.ResetVars()
}

function play_vox_word( word =null, z_level =null, only_listener =null ) {
	local sound_file, voice, M, T
	word = ::lowertext( word )
	if ( ::vox_sounds[word] ) {
		sound_file = ::vox_sounds[word]
		voice = ::Sound.lcall( ::List({ ["channel"]= ::VOX_CHANNEL, ["wait"]= 1, [1]= sound_file }) )
		voice.status = ::SOUND_STREAM
		if ( !only_listener ) {
			M = null
			foreach (_ in ::player_list ) {
				M = _
				if ( M.client && !M.ear_deaf ) {
					T = ::get_turf( M )
					if ( T.z == z_level ) {
						M.write( voice )
					}
				}
			}
		} else {
			only_listener.write( voice )
		}
		return 1
	}
	return 0
}

function playsound( source =null, soundin =null, vol =null, vary =null, extrarange =null, falloff =null, surround =null ) {
	local frequency, turf_source, P, M, T
	if ( surround == null ) {
		surround = 1
	}
	soundin = ::get_sfx( soundin )
	if ( ::isarea( source ) ) {
		throw ::Exception( "playsound(): source is an area", "code/game/sound.dm", 6 )
		return
	}
	frequency = ::get_rand_frequency()
	turf_source = ::get_turf( source )
	P = null
	foreach (_ in ::player_list ) {
		P = _
		M = P
		if ( !M || !M.client ) {
			continue
		}
		if ( ::get_dist( M, turf_source ) <= ::game.view + extrarange ) {
			T = ::get_turf( M )
			if ( T && T.z == turf_source.z ) {
				M.playsound_local( turf_source, soundin, vol, vary, frequency, falloff, surround )
			}
		}
	}
}

function pollCandidates( Question =null, jobbanType =null, gametypeCheck =null, be_special_flag =null, poll_time =null ) {
	local candidates, time_passed, G
	if ( be_special_flag == null ) {
		be_special_flag = 0
	}
	if ( poll_time == null ) {
		poll_time = 300
	}
	candidates = ::List()
	time_passed = ::game.time
	if ( !Question ) {
		Question = "Would you like to be a special role?"
	}
	G = null
	foreach (_ in ::player_list ) {
		G = _
		if ( !( G instanceof ::Mob_Dead_Observer ) ) {
			continue
		}
		if ( !G.key || !G.client ) {
			continue
		}
		if ( be_special_flag ) {
			if ( !( G.client.prefs.be_special & be_special_flag ) ) {
				continue
			}
		}
		if ( gametypeCheck ) {
			if ( !gametypeCheck.age_check( G.client ) ) {
				continue
			}
		}
		if ( jobbanType ) {
			if ( ::jobban_isbanned( G, jobbanType ) || ::jobban_isbanned( G, "Syndicate" ) ) {
				continue
			}
		}
		::thread.schedule( 0, function() {
			G.write( ::Rsc(9) )
			local _ = ::alert( G, Question, "Please answer in " + poll_time / 10 + " seconds!", "Yes", "No", null ) // Was a switch-case, sorry for the mess.
			if ( _=="Yes" ) {
				G.write( "<span class='notice'>Choice registered: Yes.</span>" )
				if ( ::game.time - time_passed > poll_time ) {
					G.write( "<span class='danger'>Sorry, you were too late for the consideration!</span>" )
					G.write( ::Rsc(10) )
					return
				}
				candidates += G
			} else if ( _=="No" ) {
				G.write( "<span class='danger'>Choice registered: No.</span>" )
				return
			} else {
				return
			}
			return
		})
	}
	::thread.sleep( poll_time )
	G = null
	foreach (_ in candidates ) {
		G = _
		if ( !( G instanceof ::Mob_Dead_Observer ) ) {
			continue
		}
		if ( !G.key || !G.client ) {
			candidates.Remove( G )
		}
	}
	return candidates
}

function PoolOrNew( get_type =null, second_arg =null ) {
	if ( !get_type ) {
		return
	}
	_default = ::GetFromPool( get_type, second_arg )
	if ( !_default ) {
		if ( ::ispath( get_type ) ) {
			if ( second_arg instanceof ::List ) {
				_default = get_type.lcall( second_arg )
			} else {
				_default = get_type( second_arg )
			}
		}
	}
	return _default
}

function pop( L =null ) {
	if ( L.len ) {
		_default = L[L.len]
		L.len--
	}
	return _default
}

function possess( O =null ) {
	local T
	if ( O instanceof ::Ent_Singularity ) {
		if ( ::config.forbid_singulo_possession ) {
			::thread.user.write( "It is forbidden to possess singularities." )
			return
		}
	}
	T = ::get_turf( O )
	if ( T ) {
		::log_admin( "" + ::key_name( ::thread.user ) + " has possessed " + O + " (" + O.type + ") at (" + T.x + ", " + T.y + ", " + T.z + ")" )
		::message_admins( "" + ::key_name( ::thread.user ) + " has possessed " + O + " (" + O.type + ") at (" + T.x + ", " + T.y + ", " + T.z + ")" )
	} else {
		::log_admin( "" + ::key_name( ::thread.user ) + " has possessed " + O + " (" + O.type + ") at an unknown location" )
		::message_admins( "" + ::key_name( ::thread.user ) + " has possessed " + O + " (" + O.type + ") at an unknown location" )
	}
	if ( !::thread.user.control_object ) {
		::thread.user.name_archive = ::thread.user.real_name
	}
	::thread.user.loc = O
	::thread.user.real_name = O.name
	::thread.user.name = O.name
	::thread.user.client.eye = O
	::thread.user.control_object = O
	::feedback_add_details( "admin_verb", "PO" )
}

function power_list( T =null, source =null, d =null, unmarked =null, cable_only =null ) {
	local AM, P, C, _default
	if ( unmarked == null ) {
		unmarked = 0
	}
	if ( cable_only == null ) {
		cable_only = 0
	}
	_default = ::List()
	AM = null
	foreach (_ in T ) {
		AM = _
		if ( AM == source ) {
			continue
		}
		if ( !cable_only && AM instanceof ::Ent_Machinery_Power ) {
			P = AM
			if ( P.powernet == 0 ) {
				continue
			}
			if ( !unmarked || !P.powernet ) {
				if ( d == 0 ) {
					_default += P
				}
			}
		} else if ( AM instanceof ::Ent_Structure_Cable ) {
			C = AM
			if ( !unmarked || !C.powernet ) {
				if ( C.d1 == d || C.d2 == d ) {
					_default += C
				}
			}
		}
	}
	return _default
	return _default
}

function pretty_string_from_reagent_list( reagent_list =null ) {
	local result, R
	result = "| "
	R = null
	foreach (_ in reagent_list ) {
		R = _
		if ( !( R instanceof ::Reagent ) ) {
			continue
		}
		result += "" + R.name + ", " + R.volume + " | "
	}
	return result
}

function print_command_report( text =null, title =null ) {
	local C, P
	if ( text == null ) {
		text = ""
	}
	if ( title == null ) {
		title = "Central Command Update"
	}
	C = null
	foreach (_ in ::machines ) {
		C = _
		if ( !( C instanceof ::Ent_Machinery_Computer_Communications ) ) {
			continue
		}
		if ( !( C.stat & 3 ) && C.z == 1 ) {
			P = ::Ent_Item_Weapon_Paper( C.loc )
			P.name = "paper- '" + title + "'"
			P.info = text
			C.messagetitle.Add( "" + title )
			C.messagetext.Add( text )
		}
	}
}

function priority_announce( text =null, title =null, sound =null, type =null ) {
	local announcement, M
	if ( title == null ) {
		title = ""
	}
	if ( sound == null ) {
		sound = ::Rsc(62)
	}
	if ( !text ) {
		return
	}
	if ( type == "Priority" ) {
		announcement += "<h1 class='alert'>Priority Announcement</h1>"
		if ( title && ::length( title ) > 0 ) {
			announcement += "<br><h2 class='alert'>" + ::html_encode( title ) + "</h2>"
		}
	} else if ( type == "Captain" ) {
		announcement += "<h1 class='alert'>Captain Announces</h1>"
		::news_network.SubmitArticle( text, "Captain's Announcement", "Station Announcements", null )
	} else {
		announcement += "<h1 class='alert'>" + ::_command_name() + " Update</h1>"
		if ( title && ::length( title ) > 0 ) {
			announcement += "<br><h2 class='alert'>" + ::html_encode( title ) + "</h2>"
		}
		if ( title == "" ) {
			::news_network.SubmitArticle( text, "Central Command Update", "Station Announcements", null )
		} else {
			::news_network.SubmitArticle( title + "<br><br>" + text, "Central Command", "Station Announcements", null )
		}
	}
	announcement += "<br><span class='alert'>" + ::html_encode( text ) + "</span><br>"
	announcement += "<br>"
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( !( M instanceof ::Mob_NewPlayer ) && !M.ear_deaf ) {
			M.write( announcement )
			M.write( ::Sound( sound ) )
		}
	}
}

function projectile_trajectory( src_x =null, src_y =null, rotation =null, angle =null, power =null ) {
	local power_x, power_y, time, distance, dest_x, dest_y
	power_x = power * ::math.cos( angle )
	power_y = power * ::math.sin( angle )
	time = power_y * 2 / 10
	distance = time * power_x
	dest_x = src_x + distance * ::math.sin( rotation )
	dest_y = src_y + distance * ::math.cos( rotation )
	return ::ProjectileData( src_x, src_y, time, distance, power_x, power_y, dest_x, dest_y )
}

function propagate_network( O =null, PN =null ) {
	local worklist, found_machines, index, P, C, M, PM
	worklist = ::List()
	found_machines = ::List()
	index = 1
	P = null
	worklist += O
	while (index <= worklist.len) {
		P = worklist[index]
		index++
		if ( P instanceof ::Ent_Structure_Cable ) {
			C = P
			if ( C.powernet != PN ) {
				PN.add_cable( C )
			}
			worklist = worklist | C.get_connections()
		} else if ( P.anchored && P instanceof ::Ent_Machinery_Power ) {
			M = P
			found_machines = found_machines | M
		} else {
			continue
		}
	}
	PM = null
	foreach (_ in found_machines ) {
		PM = _
		if ( !( PM instanceof ::Ent_Machinery_Power ) ) {
			continue
		}
		if ( !PM.connect_to_network() ) {
			PM.disconnect_from_network()
		}
	}
}

function qdel( A =null ) {
	local hint
	if ( !A ) {
		return
	}
	if ( !( A instanceof ::Datum ) ) {
		::del( A )
		A = null
	} else if ( ::isnull( A.gc_destroyed ) ) {
		hint = A.$Destroy()
		if ( !A ) {
			return
		}
		local _ = hint // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			::SSgarbage.Queue( A )
		} else if ( _==1 ) {
			return
		} else if ( _==2 ) {
			return
		} else if ( _==3 ) {
			::SSgarbage.HardQueue( A )
		} else if ( _==4 ) {
			::del( A )
			A = null
		} else if ( _==5 ) {
			::PlaceInPool( A, 0 )
		} else if ( _==6 ) {
			::SSgarbage.Queue( A )
		} else {
			if ( !( "" + A.type in ::SSgarbage.noqdelhint ) ) {
				::SSgarbage.noqdelhint += "" + A.type
				::testing( "WARNING: " + A.type + " is not returning a qdel hint. It is being placed in the queue. Further instances of this type will also be queued." )
			}
			::SSgarbage.Queue( A )
		}
	}
}

function qdeleted( A =null ) {
	if ( !( A instanceof ::Datum ) ) {
		return 0
	}
	if ( A.gc_destroyed ) {
		return 1
	}
	return 0
}

function radiation_pulse( epicenter =null, heavy_range =null, light_range =null, severity =null, log =null ) {
	local light_severity, T, distance
	if ( log == null ) {
		log = 0
	}
	if ( !epicenter || !severity ) {
		return
	}
	if ( !( epicenter instanceof ::Tile ) ) {
		epicenter = ::get_turf( epicenter.loc )
	}
	if ( log ) {
		::message_admins( "Radiation pulse with size (" + heavy_range + ", " + light_range + ") and severity " + severity + " in area " + epicenter.loc.name + " " )
		::log_game( "Radiation pulse with size (" + heavy_range + ", " + light_range + ") and severity " + severity + " in area " + epicenter.loc.name + " " )
	}
	if ( heavy_range > light_range ) {
		light_range = heavy_range
	}
	light_severity = severity * 0.5
	T = null
	foreach (_ in ::range( light_range, epicenter ) ) {
		T = _
		if ( !( T instanceof ::BaseStatic ) ) {
			continue
		}
		distance = ::get_dist( epicenter, T )
		if ( distance < 0 ) {
			distance = 0
		}
		if ( distance < heavy_range ) {
			T.rad_act( severity )
		} else if ( distance == heavy_range ) {
			if ( ::random.chance( 50 ) ) {
				T.rad_act( severity )
			} else {
				T.rad_act( light_severity )
			}
		} else if ( distance <= light_range ) {
			T.rad_act( light_severity )
		}
	}
	return 1
}

function ran_zone( zone =null, probability =null ) {
	local t
	if ( probability == null ) {
		probability = 80
	}
	zone = ::check_zone( zone )
	if ( ::random.chance( probability ) ) {
		return zone
	}
	t = ::random.int( 1, 18 )
	local _ = t // Was a switch-case, sorry for the mess.
	if ( 3<=_&&_<=6 ) {
		return "l_arm"
	} else if ( 7<=_&&_<=10 ) {
		return "r_arm"
	} else if ( 11<=_&&_<=14 ) {
		return "l_leg"
	} else if ( 15<=_&&_<=18 ) {
		return "r_leg"
	} else if ( _==1 ) {
		return "head"
	} else if ( _==2 ) {
		return "chest"
	}
	return zone
}

function randmutb( M =null ) {
	local HM, _default
	if ( !M.has_dna() ) {
		return
	}
	HM = ::random.pick( ( ::bad_mutations | ::not_good_mutations ) - ::mutations_list.Monkified )
	_default = HM.force_give( M )
	return _default
}

function randmutg( M =null ) {
	local HM, _default
	if ( !M.has_dna() ) {
		return
	}
	HM = ::random.pick( ::good_mutations )
	_default = HM.force_give( M )
	return _default
}

function randmuti( M =null ) {
	local num, newdna
	if ( !M.has_dna() ) {
		return
	}
	num = ::random.int( 1, 7 )
	newdna = ::setblock( M.dna.uni_identity, num, ::random_string( 3, ::hex_characters ) )
	M.dna.uni_identity = newdna
	return
}

function random_blood_type(  ) {
	local _ = ::random.int(0,65535) // Was a weighted pick, sorry for the mess.
	if ( _ < 2674 ) { _ = "O-" }
	else if ( _ < 26748 ) { _ = "O+" }
	else if ( _ < 28754 ) { _ = "A-" }
	else if ( _ < 47478 ) { _ = "A+" }
	else if ( _ < 48146 ) { _ = "B-" }
	else if ( _ < 61520 ) { _ = "B+" }
	else if ( _ < 62188 ) { _ = "AB-" }
	else  { _ = "AB+" }
	return _
}

function random_eye_color(  ) {
	local _ = ::random.int(0,65535) // Was a weighted pick, sorry for the mess.
	if ( _ < 14246 ) { _ = "brown" }
	else if ( _ < 28492 ) { _ = "hazel" }
	else if ( _ < 42738 ) { _ = "grey" }
	else if ( _ < 53423 ) { _ = "blue" }
	else if ( _ < 64108 ) { _ = "green" }
	else if ( _ < 64820 ) { _ = "amber" }
	else  { _ = "albino" }
	local _ = _ // Was a switch-case, sorry for the mess.
	if ( _=="brown" ) {
		return "630"
	} else if ( _=="hazel" ) {
		return "542"
	} else if ( _=="grey" ) {
		local _ = ::random.pick([ "666", "777", "888", "999", "aaa", "bbb", "ccc" ])
		return _
	} else if ( _=="blue" ) {
		return "36c"
	} else if ( _=="green" ) {
		return "060"
	} else if ( _=="amber" ) {
		return "fc0"
	} else if ( _=="albino" ) {
		local _ = ::random.pick([ "c", "d", "e", "f" ])
		local _ = ::random.pick([ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ])
		local _ = ::random.pick([ "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ])
		return _ + _ + _
	} else {
		return "000"
	}
}

function random_facial_hair_style( gender =null ) {
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::random.pick( ::facial_hair_styles_male_list )
	} else if ( _=="female" ) {
		return ::random.pick( ::facial_hair_styles_female_list )
	} else {
		return ::random.pick( ::facial_hair_styles_list )
	}
}

function random_features(  ) {
	if ( !::tails_list_human.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Tails_Human, ::tails_list_human )
	}
	if ( !::tails_list_lizard.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Tails_Lizard, ::tails_list_lizard )
	}
	if ( !::snouts_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Snouts, ::snouts_list )
	}
	if ( !::horns_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Horns, ::horns_list )
	}
	if ( !::ears_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Ears, ::horns_list )
	}
	if ( !::frills_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Frills, ::frills_list )
	}
	if ( !::spines_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Spines, ::spines_list )
	}
	if ( !::body_markings_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_BodyMarkings, ::body_markings_list )
	}
	local _ = ::random.pick([ "FFFFFF", "7F7F7F", "7FFF7F", "7F7FFF", "FF7F7F", "7FFFFF", "FF7FFF", "FFFF7F" ])
	return ::List({ ["body_markings"]= ::random.pick( ::body_markings_list ), ["spines"]= ::random.pick( ::spines_list ), ["frills"]= ::random.pick( ::frills_list ), ["ears"]= "None", ["horns"]= ::random.pick( ::horns_list ), ["snout"]= ::random.pick( ::snouts_list ), ["tail_human"]= "None", ["tail_lizard"]= ::random.pick( ::tails_list_lizard ), ["mcolor"]= _ })
}

function random_hair_style( gender =null ) {
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::random.pick( ::hair_styles_male_list )
	} else if ( _=="female" ) {
		return ::random.pick( ::hair_styles_female_list )
	} else {
		return ::random.pick( ::hair_styles_list )
	}
}

function random_short_color(  ) {
	return ::random_string( 3, ::hex_characters )
}

function random_skin_tone(  ) {
	return ::random.pick( ::skin_tones )
}

function random_socks( gender =null ) {
	if ( !::socks_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Socks, ::socks_list, ::socks_m, ::socks_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::random.pick( ::socks_m )
	} else if ( _=="female" ) {
		return ::random.pick( ::socks_f )
	} else {
		return ::random.pick( ::socks_list )
	}
}

function random_step( AM =null, steps =null, chance =null ) {
	local initial_chance
	initial_chance = chance
	while (steps > 0) {
		if ( ::random.chance( chance ) ) {
			::step( AM, ::random.pick( ::alldirs ) )
		}
		chance = ::math.max( chance - initial_chance / steps, 0 )
		steps--
	}
}

function random_string( length =null, characters =null ) {
	local i, _default
	_default = ""
	i = null
	i = 1
	while (i <= length) {
		_default += ::random.pick( characters )
		i++
	}
	return _default
}

function random_undershirt( gender =null ) {
	if ( !::undershirt_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Undershirt, ::undershirt_list, ::undershirt_m, ::undershirt_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::random.pick( ::undershirt_m )
	} else if ( _=="female" ) {
		return ::random.pick( ::undershirt_f )
	} else {
		return ::random.pick( ::undershirt_list )
	}
}

function random_underwear( gender =null ) {
	if ( !::underwear_list.len ) {
		::init_sprite_accessory_subtypes( ::SpriteAccessory_Underwear, ::underwear_list, ::underwear_m, ::underwear_f )
	}
	local _ = gender // Was a switch-case, sorry for the mess.
	if ( _=="male" ) {
		return ::random.pick( ::underwear_m )
	} else if ( _=="female" ) {
		return ::random.pick( ::underwear_f )
	} else {
		return ::random.pick( ::underwear_list )
	}
}

function random_unique_lizard_name( gender =null, attempts_to_find_unique_name =null ) {
	local i, _default
	if ( attempts_to_find_unique_name == null ) {
		attempts_to_find_unique_name = 10
	}
	i = null
	i = 1
	while (i <= attempts_to_find_unique_name) {
		_default = ::capitalize( ::lizard_name( gender ) )
		if ( i != attempts_to_find_unique_name && !::findname( _default ) ) {
			break
		}
		i++
	}
	return _default
}

function random_unique_name( gender =null, attempts_to_find_unique_name =null ) {
	local i, _default
	if ( attempts_to_find_unique_name == null ) {
		attempts_to_find_unique_name = 10
	}
	i = null
	i = 1
	while (i <= attempts_to_find_unique_name) {
		if ( gender == ::FEMALE ) {
			_default = ::capitalize( ::random.pick( ::first_names_female ) ) + " " + ::capitalize( ::random.pick( ::last_names ) )
		} else {
			_default = ::capitalize( ::random.pick( ::first_names_male ) ) + " " + ::capitalize( ::random.pick( ::last_names ) )
		}
		if ( i != attempts_to_find_unique_name && !::findname( _default ) ) {
			break
		}
		i++
	}
	return _default
}

function randomColor( mode =null ) {
	if ( mode == null ) {
		mode = 0
	}
	local _ = mode // Was a switch-case, sorry for the mess.
	if ( _==0 ) {
		local _ = ::random.pick([ "white", "black", "gray", "red", "green", "blue", "brown", "yellow", "orange", "darkred", "crimson", "lime", "darkgreen", "cyan", "navy", "teal", "purple", "indigo" ])
		return _
	} else if ( _==1 ) {
		local _ = ::random.pick([ "red", "green", "blue", "brown", "yellow", "orange", "darkred", "crimson", "lime", "darkgreen", "cyan", "navy", "teal", "purple", "indigo" ])
		return _
	} else {
		return "white"
	}
}

function randomize_human( H =null ) {
	local _ = ::random.pick([ ::MALE, ::FEMALE ])
	H.gender = _
	H.real_name = ::random_unique_name( H.gender )
	H.name = H.real_name
	H.underwear = ::random_underwear( H.gender )
	H.skin_tone = ::random_skin_tone()
	H.hair_style = ::random_hair_style( H.gender )
	H.facial_hair_style = ::random_facial_hair_style( H.gender )
	H.hair_color = ::random_short_color()
	H.facial_hair_color = H.hair_color
	H.eye_color = ::random_eye_color()
	H.dna.blood_type = ::random_blood_type()
	H.update_body()
	H.$update hair()
}

function ReadRGB( rgb =null ) {
	local i, start, ch, which, r, g, b, alpha, usealpha, digits, single, _default
	if ( !rgb ) {
		return
	}
	i = 1
	start = 1
	if ( ::text2ascii( rgb, null ) == 35 ) {
		start++
	}
	which = 0
	r = 0
	g = 0
	b = 0
	alpha = 0
	digits = 0
	i = start
	while (i <= ::length( rgb )) {
		ch = ::text2ascii( rgb, i )
		if ( ch < 48 || ch > 57 && ch < 65 || ch > 70 && ch < 97 || ch > 102 ) {
			break
		}
		digits++
		if ( digits == 8 ) {
			break
		}
		i++
	}
	single = digits < 6
	if ( digits != 3 && digits != 4 && digits != 6 && digits != 8 ) {
		return
	}
	if ( digits == 4 || digits == 8 ) {
		usealpha = 1
	}
	i = start
	while (digits > 0) {
		ch = ::text2ascii( rgb, i )
		if ( ch >= 48 && ch <= 57 ) {
			ch -= 48
		} else if ( ch >= 65 && ch <= 70 ) {
			ch -= 55
		} else if ( ch >= 97 && ch <= 102 ) {
			ch -= 87
		} else {
			break
		}
		digits--
		local _ = which // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			r = r << 4 | ch
			if ( single ) {
				r = r | r << 4
				which++
			} else if ( !( digits & 1 ) ) {
				which++
			}
		} else if ( _==1 ) {
			g = g << 4 | ch
			if ( single ) {
				g = g | g << 4
				which++
			} else if ( !( digits & 1 ) ) {
				which++
			}
		} else if ( _==2 ) {
			b = b << 4 | ch
			if ( single ) {
				b = b | b << 4
				which++
			} else if ( !( digits & 1 ) ) {
				which++
			}
		} else if ( _==3 ) {
			alpha = alpha << 4 | ch
			if ( single ) {
				alpha = alpha | alpha << 4
			}
		}
		i++
	}
	_default = ::List([ r, g, b ])
	if ( usealpha ) {
		_default += alpha
	}
	return _default
}

function recursive_hear_check( O =null ) {
	local processing_list, processed_list, found_atoms, A, B
	processing_list = ::List([ O ])
	processed_list = ::List()
	found_atoms = ::List()
	while (processing_list.len) {
		A = processing_list[1]
		if ( A.flags & 16 ) {
			found_atoms = found_atoms | A
		}
		B = null
		foreach (_ in A ) {
			B = _
			if ( !( B instanceof ::BaseStatic ) ) {
				continue
			}
			if ( !processed_list[B] ) {
				processing_list = processing_list | B
			}
		}
		processing_list.Cut( 1, 2 )
		processed_list[A] = A
	}
	return found_atoms
}

function recursive_mob_check( O =null, client_check =null, sight_check =null, include_radio =null ) {
	local processing_list, processed_list, found_mobs, A, passed, A_tmp, B
	if ( client_check == null ) {
		client_check = 1
	}
	if ( sight_check == null ) {
		sight_check = 1
	}
	if ( include_radio == null ) {
		include_radio = 1
	}
	processing_list = ::List([ O ])
	processed_list = ::List()
	found_mobs = ::List()
	while (processing_list.len) {
		A = processing_list[1]
		passed = 0
		if ( ::ismob( A ) ) {
			A_tmp = A
			passed = 1
			if ( client_check && !A_tmp.client ) {
				passed = 0
			}
			if ( sight_check && !::isInSight( A_tmp, O ) ) {
				passed = 0
			}
		} else if ( include_radio && A instanceof ::Ent_Item_Device_Radio ) {
			passed = 1
			if ( sight_check && !::isInSight( A, O ) ) {
				passed = 0
			}
		}
		if ( passed ) {
			found_mobs = found_mobs | A
		}
		B = null
		foreach (_ in A ) {
			B = _
			if ( !( B instanceof ::BaseStatic ) ) {
				continue
			}
			if ( !processed_list[B] ) {
				processing_list = processing_list | B
			}
		}
		processing_list.Cut( 1, 2 )
		processed_list[A] = A
	}
	return found_mobs
}

function regex_find( str =null, exp =null ) {
	return ::Regex( str, exp, ::getf_dll( "bin/bygex", "regex_find" )( str, exp ) )
}

function reject_bad_name( t_in =null, allow_numbers =null, max_length =null ) {
	local number_of_alphanumeric, last_char_group, t_out, i, ascii_char, bad_name
	if ( allow_numbers == null ) {
		allow_numbers = 0
	}
	if ( max_length == null ) {
		max_length = 26
	}
	if ( !t_in || ::length( t_in ) > max_length ) {
		return
	}
	number_of_alphanumeric = 0
	last_char_group = 0
	t_out = ""
	i = null
	i = 1
	while (i <= ::length( t_in )) {
		ascii_char = ::text2ascii( t_in, i )
		local _ = ascii_char // Was a switch-case, sorry for the mess.
		if ( 65<=_&&_<=90 ) {
			t_out += ::ascii2text( ascii_char )
			number_of_alphanumeric++
			last_char_group = 4
		} else if ( 97<=_&&_<=122 ) {
			if ( last_char_group < 2 ) {
				t_out += ::ascii2text( ascii_char - 32 )
			} else {
				t_out += ::ascii2text( ascii_char )
			}
			number_of_alphanumeric++
			last_char_group = 4
		} else if ( 48<=_&&_<=57 ) {
			if ( !last_char_group ) {
				i++
				continue
			}
			if ( !allow_numbers ) {
				i++
				continue
			}
			t_out += ::ascii2text( ascii_char )
			number_of_alphanumeric++
			last_char_group = 3
		} else if ( _==39 || _==45 || _==46 ) {
			if ( !last_char_group ) {
				i++
				continue
			}
			t_out += ::ascii2text( ascii_char )
			last_char_group = 2
		} else if ( _==126 || _==124 || _==64 || _==58 || _==35 || _==36 || _==37 || _==38 || _==42 || _==43 ) {
			if ( !last_char_group ) {
				i++
				continue
			}
			if ( !allow_numbers ) {
				i++
				continue
			}
			t_out += ::ascii2text( ascii_char )
			last_char_group = 2
		} else if ( _==32 ) {
			if ( last_char_group <= 1 ) {
				i++
				continue
			}
			t_out += ::ascii2text( ascii_char )
			last_char_group = 1
		} else {
			return
		}
		i++
	}
	if ( number_of_alphanumeric < 2 ) {
		return
	}
	if ( last_char_group == 1 ) {
		t_out = ::copytext( t_out, 1, ::length( t_out ) )
	}
	bad_name = null
	foreach (_ in ::List([ "space", "floor", "wall", "r-wall", "monkey", "unknown", "inactive ai" ]) ) {
		bad_name = _
		if ( ::cmptext( bad_name, t_out ) ) {
			return
		}
	}
	return t_out
}

function reject_bad_text( text =null, max_length =null ) {
	local non_whitespace, i
	if ( max_length == null ) {
		max_length = 512
	}
	if ( ::length( text ) > max_length ) {
		return
	}
	non_whitespace = 0
	i = null
	i = 1
	while (i <= ::length( text )) {
		local _ = ::text2ascii( text, i ) // Was a switch-case, sorry for the mess.
		if ( 127<=_&&_<=255 ) {
			return
		} else if ( 0<=_&&_<=31 ) {
			return
		} else if ( _==62 || _==60 || _==92 || _==47 ) {
			return
		} else if ( _==32 ) {
			i++
			continue
		} else {
			non_whitespace = 1
		}
		i++
	}
	if ( non_whitespace ) {
		return text
	}
}

function release( O =null ) {
	local H
	if ( ::thread.user.control_object && ::thread.user.name_archive ) {
		::thread.user.real_name = ::thread.user.name_archive
		::thread.user.name = ::thread.user.real_name
		if ( ::thread.user instanceof ::Mob_Living_Carbon_Human ) {
			H = ::thread.user
			H.name = H.get_visible_name()
		}
	}
	::thread.user.loc = O.loc
	::thread.user.client.eye = ::thread.user
	::thread.user.control_object = null
	::feedback_add_details( "admin_verb", "RO" )
}

function remove_radio( radio =null, freq =null ) {
	if ( !freq || !radio ) {
		return
	}
	if ( !::all_radios["" + freq] ) {
		return
	}
	::all_radios["" + freq] -= radio
}

function remove_radio_all( radio =null ) {
	local freq
	freq = null
	foreach (_ in ::all_radios ) {
		freq = _
		::all_radios["" + freq] -= radio
	}
}

function removeNullsFromList( L =null ) {
	while (L.Remove( null )) {
		continue
	}
	return L
}

function repeat_string( times =null, string =null ) {
	local i, _default
	if ( string == null ) {
		string = ""
	}
	_default = ""
	i = null
	i = 1
	while (i <= times) {
		_default += string
		i++
	}
	return _default
}

function replacetext( str =null, exp =null, fmt =null ) {
	return ::getf_dll( "bin/bygex", "regex_replaceallliteral" )( str, exp, fmt )
}

function return_file_text( filename =null ) {
	local text
	if ( ::file.exists( filename ) == 0 ) {
		throw ::Exception( "return_file_text(): File not found", "code/__HELPERS/files.dm", 5 )
		return
	}
	text = ::file.read( filename )
	if ( !text ) {
		throw ::Exception( "return_file_text(): File empty", "code/__HELPERS/files.dm", 10 )
		return
	}
	return text
}

function reverseRange( L =null, start =null, end =null ) {
	if ( start == null ) {
		start = 1
	}
	if ( end == null ) {
		end = 0
	}
	if ( L.len ) {
		start = start % L.len
		end = end % ( L.len + 1 )
		if ( start <= 0 ) {
			start += L.len
		}
		if ( end <= 0 ) {
			end += L.len + 1
		}
		end--
		while (start < end) {
			L.Swap( start++, end-- )
		}
	}
	return L
}

function rgb2hsl( red =null, green =null, blue =null ) {
	local max, min, range, hue, saturation, lightness, dred, dgreen, dblue
	red /= 255
	green /= 255
	blue /= 255
	max = ::math.max( red, green, blue )
	min = ::math.min( red, green, blue )
	range = max - min
	hue = 0
	saturation = 0
	lightness = 0
	lightness = ( max + min ) / 2
	if ( range != 0 ) {
		if ( lightness < 0.5 ) {
			saturation = range / ( max + min )
		} else {
			saturation = range / ( 2 - max - min )
		}
		dred = ( max - red ) / ( max * 6 ) + 0.5
		dgreen = ( max - green ) / ( max * 6 ) + 0.5
		dblue = ( max - blue ) / ( max * 6 ) + 0.5
		if ( max == red ) {
			hue = dblue - dgreen
		} else if ( max == green ) {
			hue = dred - dblue + 0.3333333432674408
		} else {
			hue = dgreen - dred + 0.6666666865348816
		}
		if ( hue < 0 ) {
			hue++
		} else if ( hue > 1 ) {
			hue--
		}
	}
	return ::List([ hue, saturation, lightness ])
}

function rightandwrong( summon_type =null, user =null, survivor_probability =null ) {
	local gunslist, magiclist, magicspeciallist, H, guns, survive, obj_count, OBJ, randomizeguns, randomizemagic, randomizemagicspecial, gat
	gunslist = ::List([ "taser", "egun", "laser", "revolver", "detective", "c20r", "nuclear", "deagle", "gyrojet", "pulse", "suppressed", "cannon", "doublebarrel", "shotgun", "combatshotgun", "bulldog", "mateba", "sabr", "crossbow", "saw", "car", "boltaction", "speargun", "arg", "uzi" ])
	magiclist = ::List([ "fireball", "smoke", "blind", "mindswap", "forcewall", "knock", "horsemask", "charge", "summonitem", "wandnothing", "wanddeath", "wandresurrection", "wandpolymorph", "wandteleport", "wanddoor", "wandfireball", "staffchange", "staffhealing", "armor", "scrying", "staffdoor", "voodoo", "special" ])
	magicspeciallist = ::List([ "staffchange", "staffanimation", "wandbelt", "contract", "staffchaos", "necromantic" ])
	if ( user ) {
		user.write( "<B>You summoned " + ( summon_type ? "magic" : "guns" ) + "!</B>" )
		::message_admins( "" + ::key_name_admin( user, 1 ) + " summoned " + ( summon_type ? "magic" : "guns" ) + "!" )
		::log_game( "" + ::key_name( user ) + " summoned " + ( summon_type ? "magic" : "guns" ) + "!" )
	}
	H = null
	foreach (_ in ::player_list ) {
		H = _
		if ( !( H instanceof ::Mob_Living_Carbon_Human ) ) {
			continue
		}
		if ( H.stat == 2 || !H.client ) {
			continue
		}
		if ( H.mind ) {
			if ( H.mind.special_role == "Wizard" || H.special_role == "apprentice" || H.special_role == "survivalist" ) {
				continue
			}
		}
		if ( ::random.chance( survivor_probability ) && !( H.mind in ::ticker.mode.traitors ) ) {
			::ticker.mode.traitors += H.mind
			guns = ::Objective_SummonGuns()
			guns.owner = H.mind
			H.mind.objectives += guns
			H.mind.special_role = "survivalist"
			survive = ::Objective_Survive()
			survive.owner = H.mind
			H.mind.objectives += survive
			H.attack_log += "[" + ::time_stamp() + "] <font color='red'>Was made into a survivalist, and trusts no one!</font>"
			H.write( "<B>You are the survivalist! Your own safety matters above all else, and the only way to ensure your safety is to stockpile weapons! Grab as many guns as possible, by any means necessary. Kill anyone who gets in your way.</B>" )
			obj_count = 1
			OBJ = null
			foreach (_ in H.mind.objectives ) {
				OBJ = _
				if ( !( OBJ instanceof ::Objective ) ) {
					continue
				}
				H.write( "<B>Objective #" + obj_count + "</B>: " + OBJ.explanation_text )
				obj_count++
			}
		}
		randomizeguns = ::random.pick( gunslist )
		randomizemagic = ::random.pick( magiclist )
		randomizemagicspecial = ::random.pick( magicspeciallist )
		if ( !summon_type ) {
			local _ = randomizeguns // Was a switch-case, sorry for the mess.
			if ( _=="taser" ) {
				::Ent_Item_Weapon_Gun_Energy_Gun_Advtaser( ::get_turf( H ) )
			} else if ( _=="egun" ) {
				::Ent_Item_Weapon_Gun_Energy_Gun( ::get_turf( H ) )
			} else if ( _=="laser" ) {
				::Ent_Item_Weapon_Gun_Energy_Laser( ::get_turf( H ) )
			} else if ( _=="revolver" ) {
				::Ent_Item_Weapon_Gun_Projectile_Revolver( ::get_turf( H ) )
			} else if ( _=="detective" ) {
				::Ent_Item_Weapon_Gun_Projectile_Revolver_Detective( ::get_turf( H ) )
			} else if ( _=="deagle" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_Pistol_Deagle_Camo( ::get_turf( H ) )
			} else if ( _=="gyrojet" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_Gyropistol( ::get_turf( H ) )
			} else if ( _=="pulse" ) {
				::Ent_Item_Weapon_Gun_Energy_Pulse( ::get_turf( H ) )
			} else if ( _=="suppressed" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_Pistol( ::get_turf( H ) )
				::Ent_Item_Weapon_Suppressor( ::get_turf( H ) )
			} else if ( _=="doublebarrel" ) {
				::Ent_Item_Weapon_Gun_Projectile_Revolver_Doublebarrel( ::get_turf( H ) )
			} else if ( _=="shotgun" ) {
				::Ent_Item_Weapon_Gun_Projectile_Shotgun( ::get_turf( H ) )
			} else if ( _=="combatshotgun" ) {
				::Ent_Item_Weapon_Gun_Projectile_Shotgun_Automatic_Combat( ::get_turf( H ) )
			} else if ( _=="arg" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_Ar( ::get_turf( H ) )
			} else if ( _=="mateba" ) {
				::Ent_Item_Weapon_Gun_Projectile_Revolver_Mateba( ::get_turf( H ) )
			} else if ( _=="boltaction" ) {
				::Ent_Item_Weapon_Gun_Projectile_Shotgun_Boltaction( ::get_turf( H ) )
			} else if ( _=="speargun" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_Speargun( ::get_turf( H ) )
			} else if ( _=="uzi" ) {
				::Ent_Item_Weapon_Gun_Projectile_Automatic_MiniUzi( ::get_turf( H ) )
			} else if ( _=="cannon" ) {
				gat = ::Ent_Item_Weapon_Gun_Energy_Lasercannon( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="crossbow" ) {
				gat = ::Ent_Item_Weapon_Gun_Energy_KineticAccelerator_Crossbow_Large( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="nuclear" ) {
				gat = ::Ent_Item_Weapon_Gun_Energy_Gun_Nuclear( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="sabr" ) {
				gat = ::Ent_Item_Weapon_Gun_Projectile_Automatic_Proto( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="bulldog" ) {
				gat = ::Ent_Item_Weapon_Gun_Projectile_Automatic_Shotgun_Bulldog( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="c20r" ) {
				gat = ::Ent_Item_Weapon_Gun_Projectile_Automatic_C20r( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="saw" ) {
				gat = ::Ent_Item_Weapon_Gun_Projectile_Automatic_L6Saw( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			} else if ( _=="car" ) {
				gat = ::Ent_Item_Weapon_Gun_Projectile_Automatic_M90( ::get_turf( H ) )
				gat.pin = ::Ent_Item_Device_FiringPin()
			}
			::playsound( ::get_turf( H ), ::Rsc(56), 50, 1 )
		} else {
			local _ = randomizemagic // Was a switch-case, sorry for the mess.
			if ( _=="fireball" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Fireball( ::get_turf( H ) )
			} else if ( _=="smoke" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Smoke( ::get_turf( H ) )
			} else if ( _=="blind" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Blind( ::get_turf( H ) )
			} else if ( _=="mindswap" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Mindswap( ::get_turf( H ) )
			} else if ( _=="forcewall" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Forcewall( ::get_turf( H ) )
			} else if ( _=="knock" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Knock( ::get_turf( H ) )
			} else if ( _=="horsemask" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Barnyard( ::get_turf( H ) )
			} else if ( _=="charge" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Charge( ::get_turf( H ) )
			} else if ( _=="summonitem" ) {
				::Ent_Item_Weapon_Spellbook_Oneuse_Summonitem( ::get_turf( H ) )
			} else if ( _=="wandnothing" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand( ::get_turf( H ) )
			} else if ( _=="wanddeath" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Death( ::get_turf( H ) )
			} else if ( _=="wandresurrection" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Resurrection( ::get_turf( H ) )
			} else if ( _=="wandpolymorph" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Polymorph( ::get_turf( H ) )
			} else if ( _=="wandteleport" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Teleport( ::get_turf( H ) )
			} else if ( _=="wanddoor" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Door( ::get_turf( H ) )
			} else if ( _=="wandfireball" ) {
				::Ent_Item_Weapon_Gun_Magic_Wand_Fireball( ::get_turf( H ) )
			} else if ( _=="staffhealing" ) {
				::Ent_Item_Weapon_Gun_Magic_Staff_Healing( ::get_turf( H ) )
			} else if ( _=="staffdoor" ) {
				::Ent_Item_Weapon_Gun_Magic_Staff_Door( ::get_turf( H ) )
			} else if ( _=="armor" ) {
				::Ent_Item_Clothing_Suit_Space_Hardsuit_Wizard( ::get_turf( H ) )
			} else if ( _=="scrying" ) {
				::Ent_Item_Weapon_Scrying( ::get_turf( H ) )
				if ( !H.dna.check_mutation( "X Ray Vision" ) ) {
					H.$add mutation( "X Ray Vision" )
					H.write( "<span class='notice'>The walls suddenly disappear.</span>" )
				}
			} else if ( _=="voodoo" ) {
				::Ent_Item_Voodoo( ::get_turf( H ) )
			} else if ( _=="special" ) {
				magiclist -= "special"
				local _ = randomizemagicspecial // Was a switch-case, sorry for the mess.
				if ( _=="staffchange" ) {
					::Ent_Item_Weapon_Gun_Magic_Staff_Change( ::get_turf( H ) )
				} else if ( _=="staffanimation" ) {
					::Ent_Item_Weapon_Gun_Magic_Staff_Animate( ::get_turf( H ) )
				} else if ( _=="wandbelt" ) {
					::Ent_Item_Weapon_Storage_Belt_Wands_Full( ::get_turf( H ) )
				} else if ( _=="contract" ) {
					::Ent_Item_Weapon_AntagSpawner_Contract( ::get_turf( H ) )
				} else if ( _=="staffchaos" ) {
					::Ent_Item_Weapon_Gun_Magic_Staff_Chaos( ::get_turf( H ) )
				} else if ( _=="necromantic" ) {
					::Ent_Item_Device_NecromanticStone( ::get_turf( H ) )
				}
				H.write( "<span class='notice'>You suddenly feel lucky.</span>" )
			}
			::playsound( ::get_turf( H ), ::Rsc(57), 50, 1 )
		}
	}
}

function rights2text( rights =null, seperator =null, adds =null, subs =null ) {
	local verbpath, _default
	if ( seperator == null ) {
		seperator = ""
	}
	if ( rights & 1 ) {
		_default += "" + seperator + "+BUILDMODE"
	}
	if ( rights & 2 ) {
		_default += "" + seperator + "+ADMIN"
	}
	if ( rights & 4 ) {
		_default += "" + seperator + "+BAN"
	}
	if ( rights & 8 ) {
		_default += "" + seperator + "+FUN"
	}
	if ( rights & 16 ) {
		_default += "" + seperator + "+SERVER"
	}
	if ( rights & 32 ) {
		_default += "" + seperator + "+DEBUG"
	}
	if ( rights & 64 ) {
		_default += "" + seperator + "+POSSESS"
	}
	if ( rights & 128 ) {
		_default += "" + seperator + "+PERMISSIONS"
	}
	if ( rights & 256 ) {
		_default += "" + seperator + "+STEALTH"
	}
	if ( rights & 512 ) {
		_default += "" + seperator + "+REJUVINATE"
	}
	if ( rights & 1024 ) {
		_default += "" + seperator + "+VAREDIT"
	}
	if ( rights & 2048 ) {
		_default += "" + seperator + "+SOUND"
	}
	if ( rights & 4096 ) {
		_default += "" + seperator + "+SPAWN"
	}
	verbpath = null
	foreach (_ in adds ) {
		verbpath = _
		_default += "" + seperator + "+" + verbpath
	}
	verbpath = null
	foreach (_ in subs ) {
		verbpath = _
		_default += "" + seperator + "-" + verbpath
	}
	return _default
	return _default
}

function robogibs( location =null, viruses =null ) {
	::Ent_Effect_Gibspawner_Robot( location, viruses )
}

function RoundDiagBar( value =null ) {
	local _ = value * 100 // Was a switch-case, sorry for the mess.
	if ( 95<=_&&_<=9.999999848243207e+30 ) {
		return "max"
	} else if ( 80<=_&&_<=100 ) {
		return "good"
	} else if ( 60<=_&&_<=80 ) {
		return "high"
	} else if ( 40<=_&&_<=60 ) {
		return "med"
	} else if ( 20<=_&&_<=40 ) {
		return "low"
	} else if ( 1<=_&&_<=20 ) {
		return "crit"
	} else {
		return "dead"
	}
	return "dead"
}

function RoundHealth( health =null ) {
	local _ = health // Was a switch-case, sorry for the mess.
	if ( 100<=_&&_<=9.999999848243207e+30 ) {
		return "health100"
	} else if ( 70<=_&&_<=100 ) {
		return "health80"
	} else if ( 50<=_&&_<=70 ) {
		return "health60"
	} else if ( 30<=_&&_<=50 ) {
		return "health40"
	} else if ( 18<=_&&_<=30 ) {
		return "health25"
	} else if ( 5<=_&&_<=18 ) {
		return "health10"
	} else if ( 1<=_&&_<=5 ) {
		return "health1"
	} else if ( -99<=_&&_<=0 ) {
		return "health0"
	} else {
		return "health-100"
	}
	return "0"
}

function safepick( L =null ) {
	if ( L instanceof ::List && L.len ) {
		return ::random.pick( L )
	}
}

function sanitize( t =null, repl_chars =null ) {
	if ( repl_chars == null ) {
		repl_chars = null
	}
	return ::html_encode( ::sanitize_simple( t, repl_chars ) )
}

function sanitize_frequency( f =null ) {
	f = ::math.round( f )
	f = ::math.max( 1441, f )
	f = ::math.min( 1489, f )
	if ( f % 2 == 0 ) {
		f += 1
	}
	return f
}

function sanitize_hexcolor( color =null, desired_format =null, include_crunch =null, __default =null ) {
	local crunch, start, len, step_size, i, ascii, _default
	if ( desired_format == null ) {
		desired_format = 3
	}
	if ( include_crunch == null ) {
		include_crunch = 0
	}
	crunch = include_crunch ? "#" : ""
	if ( !::istext( color ) ) {
		color = ""
	}
	start = ( ::text2ascii( color, 1 ) == 35 ) + 1
	len = ::length( color )
	step_size = ( len + 1 - start != desired_format ) + 1
	_default = ""
	i = null
	i = start
	while (i <= len) {
		ascii = ::text2ascii( color, i )
		local _ = ascii // Was a switch-case, sorry for the mess.
		if ( 48<=_&&_<=57 ) {
			_default += ::ascii2text( ascii )
		} else if ( 97<=_&&_<=102 ) {
			_default += ::ascii2text( ascii )
		} else if ( 65<=_&&_<=70 ) {
			_default += ::ascii2text( ascii + 32 )
		} else {
			break
		}
		i += step_size
	}
	if ( ::length( _default ) != desired_format ) {
		if ( __default ) {
			return __default
		}
		return crunch + ::repeat_string( desired_format, "0" )
	}
	return crunch + _default
	return _default
}

function sanitize_ooccolor( color =null ) {
	local HSL, RGB
	HSL = ::rgb2hsl( ::hex2num( ::copytext( color, 2, 4 ) ), ::hex2num( ::copytext( color, 4, 6 ) ), ::hex2num( ::copytext( color, 6, 8 ) ) )
	HSL[3] = ::math.min( HSL[3], 0.4000000059604645 )
	RGB = ::get_dist_euclidian.lcall( HSL )
	return "#" + ::num2hex( RGB[1], 2 ) + ::num2hex( RGB[2], 2 ) + ::num2hex( RGB[3], 2 )
}

function sanitize_simple( t =null, repl_chars =null ) {
	local char, index
	if ( repl_chars == null ) {
		repl_chars = ::List({ ["	"]= "#", ["\n"]= "#" })
	}
	char = null
	foreach (_ in repl_chars ) {
		char = _
		index = ::findtext( t, char, 1, null )
		while (index) {
			t = ::copytext( t, 1, index ) + repl_chars[char] + ::copytext( t, index + 1, null )
			index = ::findtext( t, char, index + 1, null )
		}
	}
	return t
}

function sanitizeSQL( t =null ) {
	local sqltext
	sqltext = ::dbcon.Quote( t )
	return ::copytext( sqltext, 2, ::length( sqltext ) )
}

function screen_loc2turf( scr_loc =null, origin =null ) {
	local tX, tY, tZ
	tX = ::text2list( scr_loc, "," )
	tY = ::text2list( tX[2], ":" )
	tZ = origin.z
	tY = tY[1]
	tX = ::text2list( tX[1], ":" )
	tX = tX[1]
	tX = ::math.max( 1, ::math.min( ::game.maxx, origin.x + ( ::text2num( tX ) - ( ::game.view + 1 ) ) ) )
	tY = ::math.max( 1, ::math.min( ::game.maxy, origin.y + ( ::text2num( tY ) - ( ::game.view + 1 ) ) ) )
	return ::locate3( tX, tY, tZ )
}

function SDQL_expression( object =null, expression =null, start =null ) {
	local result, val, i, op, ret
	if ( start == null ) {
		start = 1
	}
	result = 0
	i = null
	i = start
	while (i <= expression.len) {
		op = ""
		if ( i > start ) {
			op = expression[i]
			i++
		}
		ret = ::SDQL_value( object, expression, i )
		val = ret.val
		i = ret.i
		if ( op != "" ) {
			local _ = op // Was a switch-case, sorry for the mess.
			if ( _=="+" ) {
				result += val
			} else if ( _=="-" ) {
				result -= val
			} else if ( _=="*" ) {
				result *= val
			} else if ( _=="/" ) {
				result /= val
			} else if ( _=="&" ) {
				result = result & val
			} else if ( _=="|" ) {
				result = result | val
			} else if ( _=="^" ) {
				result = result ^ val
			} else if ( _=="=" || _=="==" ) {
				result = result == val
			} else if ( _=="!=" || _=="<>" ) {
				result = result != val
			} else if ( _=="<" ) {
				result = result < val
			} else if ( _=="<=" ) {
				result = result <= val
			} else if ( _==">" ) {
				result = result > val
			} else if ( _==">=" ) {
				result = result >= val
			} else if ( _=="and" || _=="&&" ) {
				result = result && val
			} else if ( _=="or" || _=="||" ) {
				result = result || val
			} else {
				::thread.user.write( "<span class='danger'>SDQL2: Unknown op " + op + "</span>" )
				result = null
			}
		} else {
			result = val
		}
		i++
	}
	return result
}

function SDQL_from_objs( tree =null ) {
	local out, type, char
	if ( "world" in tree ) {
		return ::List([ ::game ])
	}
	out = ::List()
	type = null
	foreach (_ in tree ) {
		type = _
		char = ::copytext( type, 1, 2 )
		if ( char == "/" ) {
			out += ::SDQL_get_all( type, ::game )
		} else if ( char == "'" || char == "\"" ) {
			out += ::locate1( ::copytext( type, 2, ::length( type ) ) )
		}
	}
	return out
}

function SDQL_get_all( type =null, location =null ) {
	local out, d
	out = ::List()
	if ( type == "*" ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( !( d instanceof ::Datum ) ) {
				continue
			}
			out += d
		}
		return out
	}
	type = ::text2path( type )
	if ( ::ispath2( type, ::Mob ) ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( d instanceof type ) {
				out += d
			}
		}
	} else if ( ::ispath2( type, ::Tile ) ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( d instanceof type ) {
				out += d
			}
		}
	} else if ( ::ispath2( type, ::Entity ) ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( !( d instanceof ::Entity ) ) {
				continue
			}
			if ( d instanceof type ) {
				out += d
			}
		}
	} else if ( ::ispath2( type, ::Area(3137) ) ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( d instanceof type ) {
				out += d
			}
		}
	} else if ( ::ispath2( type, ::BaseStatic ) ) {
		d = null
		foreach (_ in location ) {
			d = _
			if ( !( d instanceof ::BaseStatic ) ) {
				continue
			}
			if ( d instanceof type ) {
				out += d
			}
		}
	} else {
		d = null
		foreach (_ in location ) {
			d = _
			if ( !( d instanceof ::Datum ) ) {
				continue
			}
			if ( d instanceof type ) {
				out += d
			}
		}
	}
	return out
}

function SDQL_parse( query_list =null ) {
	local parser, querys, query_tree, pos, querys_pos, do_parse, val, parsed_tree
	parser = ::SDQLParser()
	querys = ::List()
	query_tree = ::List()
	pos = 1
	querys_pos = 1
	do_parse = 0
	val = null
	foreach (_ in query_list ) {
		val = _
		if ( val == ";" ) {
			do_parse = 1
		} else if ( pos >= query_list.len ) {
			query_tree += val
			do_parse = 1
		}
		if ( do_parse ) {
			parser.query = query_tree
			parsed_tree = null
			parsed_tree = parser.parse()
			if ( parsed_tree.len > 0 ) {
				querys.len = querys_pos
				querys[querys_pos] = parsed_tree
				querys_pos++
			} else {
				::thread.user.write( ::Txt( "<span class='danger'>Parsing error on " ).st_nd_rd( querys_pos ).str( " query. Nothing was executed.</span>" ) )
				return ::List()
			}
			query_tree = ::List()
			do_parse = 0
		} else {
			query_tree += val
		}
		pos++
	}
	::qdel( parser )
	return querys
}

function SDQL_testout( query_tree =null, indent =null ) {
	local spaces, s, item
	if ( indent == null ) {
		indent = 0
	}
	spaces = ""
	s = null
	s = 0
	while (s < indent) {
		spaces += "    "
		s++
	}
	item = null
	foreach (_ in query_tree ) {
		item = _
		if ( item instanceof ::List ) {
			::thread.user.write( "" + spaces + "(" )
			::SDQL_testout( item, indent + 1 )
			::thread.user.write( "" + spaces + ")" )
		} else {
			::thread.user.write( "" + spaces + item )
		}
		if ( !::isnum( item ) && query_tree[item] ) {
			if ( query_tree[item] instanceof ::List ) {
				::thread.user.write( "" + spaces + "    (" )
				::SDQL_testout( query_tree[item], indent + 2 )
				::thread.user.write( "" + spaces + "    )" )
			} else {
				::thread.user.write( "" + spaces + "    " + query_tree[item] )
			}
		}
	}
}

function SDQL_value( object =null, expression =null, start =null ) {
	local i, val, ret
	if ( start == null ) {
		start = 1
	}
	i = start
	val = null
	if ( i > expression.len ) {
		return ::List({ ["i"]= i, ["val"]= null })
	}
	if ( expression[i] instanceof ::List ) {
		val = ::SDQL_expression( object, expression[i] )
	} else if ( expression[i] == "!" ) {
		ret = ::SDQL_value( object, expression, i + 1 )
		val = !ret.val
		i = ret.i
	} else if ( expression[i] == "~" ) {
		ret = ::SDQL_value( object, expression, i + 1 )
		val = ~ret.val
		i = ret.i
	} else if ( expression[i] == "-" ) {
		ret = ::SDQL_value( object, expression, i + 1 )
		val = -ret.val
		i = ret.i
	} else if ( expression[i] == "null" ) {
		val = null
	} else if ( ::isnum( expression[i] ) ) {
		val = expression[i]
	} else if ( ::copytext( expression[i], 1, 2 ) in ::List([ "'", "\"" ]) ) {
		val = ::copytext( expression[i], 2, ::length( expression[i] ) )
	} else {
		val = ::SDQL_var( object, expression, i )
		i = expression.len
	}
	return ::List({ ["i"]= i, ["val"]= val })
}

function SDQL_var( object =null, expression =null, start =null ) {
	if ( start == null ) {
		start = 1
	}
	if ( expression[start] in object.vars ) {
		if ( start < expression.len && expression[start + 1] == "." ) {
			return ::SDQL_var( object.vars[expression[start]], expression[start + 2] )
		} else {
			return object.vars[expression[start]]
		}
	} else {
		return
	}
}

function SDQL2_tokenize( query_text =null ) {
	local whitespace, single, multi, word, query_list, len, i, char, char2
	whitespace = ::List([ " ", "\n", "	" ])
	single = ::List([ "(", ")", ",", "+", "-", ".", ";" ])
	multi = ::List({
		["!"]= ::List([ "", "=" ]),
		[">"]= ::List([ "", "=" ]),
		["<"]= ::List([ "", "=", ">" ]),
		["="]= ::List([ "", "=" ])
	})
	word = ""
	query_list = ::List()
	len = ::length( query_text )
	i = null
	i = 1
	while (i <= len) {
		char = ::copytext( query_text, i, i + 1 )
		if ( char in whitespace ) {
			if ( word != "" ) {
				query_list += word
				word = ""
			}
		} else if ( char in single ) {
			if ( word != "" ) {
				query_list += word
				word = ""
			}
			query_list += char
		} else if ( char in multi ) {
			if ( word != "" ) {
				query_list += word
				word = ""
			}
			char2 = ::copytext( query_text, i + 1, i + 2 )
			if ( char2 in multi[char] ) {
				query_list += "" + char + char2
				i++
			} else {
				query_list += char
			}
		} else if ( char == "'" ) {
			if ( word != "" ) {
				::thread.user.write( ::Txt().red().str( "SDQL2: You have an error in your SDQL syntax, unexpected ' in query: \"<font color=gray>" ).item( query_text ).str( "</font>\" following \"<font color=gray>" ).item( word ).str( "</font>\". Please check your syntax, and try again." ) )
				return
			}
			word = "'"
			i++
			while (i <= len) {
				char = ::copytext( query_text, i, i + 1 )
				if ( char == "'" ) {
					if ( ::copytext( query_text, i + 1, i + 2 ) == "'" ) {
						word += "'"
						i++
					} else {
						break
					}
				} else {
					word += char
				}
				i++
			}
			if ( i > len ) {
				::thread.user.write( ::Txt().red().str( "SDQL2: You have an error in your SDQL syntax, unmatched ' in query: \"<font color=gray>" ).item( query_text ).str( "</font>\". Please check your syntax, and try again." ) )
				return
			}
			query_list += "" + word + "'"
			word = ""
		} else if ( char == "\"" ) {
			if ( word != "" ) {
				::thread.user.write( ::Txt().red().str( "SDQL2: You have an error in your SDQL syntax, unexpected \" in query: \"<font color=gray>" ).item( query_text ).str( "</font>\" following \"<font color=gray>" ).item( word ).str( "</font>\". Please check your syntax, and try again." ) )
				return
			}
			word = "\""
			i++
			while (i <= len) {
				char = ::copytext( query_text, i, i + 1 )
				if ( char == "\"" ) {
					if ( ::copytext( query_text, i + 1, i + 2 ) == "'" ) {
						word += "\""
						i++
					} else {
						break
					}
				} else {
					word += char
				}
				i++
			}
			if ( i > len ) {
				::thread.user.write( ::Txt().red().str( "SDQL2: You have an error in your SDQL syntax, unmatched \" in query: \"<font color=gray>" ).item( query_text ).str( "</font>\". Please check your syntax, and try again." ) )
				return
			}
			query_list += "" + word + "\""
			word = ""
		} else {
			word += char
		}
		i++
	}
	if ( word != "" ) {
		query_list += word
	}
	return query_list
}

function seclevel2num( seclevel =null ) {
	local _ = ::lowertext( seclevel ) // Was a switch-case, sorry for the mess.
	if ( _=="green" ) {
		return 0
	} else if ( _=="blue" ) {
		return 1
	} else if ( _=="red" ) {
		return 2
	} else if ( _=="delta" ) {
		return 3
	}
}

function seedify( O =null, t_max =null, extractor =null ) {
	local t_amount, F, t_prod
	t_amount = 0
	if ( t_max == -1 ) {
		if ( extractor ) {
			t_max = ::random.int( 1, 4 ) * extractor.seed_multiplier
		} else {
			t_max = ::random.int( 1, 4 )
		}
	}
	if ( O instanceof ::Ent_Item_Weapon_ReagentContainers_Food_Snacks_Grown ) {
		F = O
		while (t_amount < t_max) {
			t_prod = F.seed( O.loc, O )
			t_prod.lifespan = F.lifespan
			t_prod.endurance = F.endurance
			t_prod.maturation = F.maturation
			t_prod.production = F.production
			t_prod._yield = F._yield
			t_prod.potency = F.potency
			t_amount++
		}
		::qdel( O )
		return 1
	} else if ( O instanceof ::Ent_Item_Weapon_Grown ) {
		F = O
		if ( F.seed ) {
			while (t_amount < t_max) {
				t_prod = F.seed( O.loc, O )
				t_prod.lifespan = F.lifespan
				t_prod.endurance = F.endurance
				t_prod.maturation = F.maturation
				t_prod.production = F.production
				t_prod._yield = F._yield
				t_prod.potency = F.potency
				t_amount++
			}
			::qdel( O )
			return 1
		} else {
			return 0
		}
	} else {
		return 0
	}
}

function select_active_ai( user =null ) {
	local ais, _default
	ais = ::active_ais()
	if ( ais.len ) {
		if ( user ) {
			_default = ::input( user, "AI signals detected:", "AI Selection", ais[1], ais, 0 )
		} else {
			_default = ::random.pick( ais )
		}
	}
	return _default
	return _default
}

function select_active_ai_with_fewest_borgs(  ) {
	local selected, active, A
	active = ::active_ais()
	A = null
	foreach (_ in active ) {
		A = _
		if ( !( A instanceof ::Mob_Living_Silicon_Ai ) ) {
			continue
		}
		if ( !selected || selected.connected_robots.len > A.connected_robots.len ) {
			selected = A
		}
	}
	return selected
}

function send_byjax( receiver =null, control_id =null, target_element =null, new_content =null, callback =null, callback_args =null ) {
	local argums
	if ( new_content == null ) {
		new_content = null
	}
	if ( callback == null ) {
		callback = null
	}
	if ( callback_args == null ) {
		callback_args = null
	}
	if ( receiver && target_element && control_id ) {
		argums = ::List([ target_element, new_content ])
		if ( callback ) {
			argums += callback
			if ( callback_args ) {
				argums += callback_args
			}
		}
		argums = ::list2params( argums )
		::output( receiver, argums, "" + control_id + ":replaceContent" )
	}
	return
}

function send2irc( msg =null, msg2 =null ) {
	if ( ::config.useircbot ) {
		::shell( "python nudge.py " + msg + " " + msg2 )
	}
	return
}

function send2irc_adminless_only( source =null, msg =null, requiredflags =null ) {
	local admin_number_total, admin_number_afk, admin_number_ignored, admin_number_decrease, X, invalid, admin_number_present
	if ( requiredflags == null ) {
		requiredflags = 4
	}
	admin_number_total = 0
	admin_number_afk = 0
	admin_number_ignored = 0
	admin_number_decrease = 0
	X = null
	foreach (_ in ::admins ) {
		X = _
		if ( !( X instanceof BAD_GOOFY_EXPANSION??? ) ) {
			continue
		}
		admin_number_total++
		invalid = 0
		if ( requiredflags != 0 && !::check_rights_for( X, requiredflags ) ) {
			admin_number_ignored++
			invalid = 1
		}
		if ( X.is_afk() ) {
			admin_number_afk++
			invalid = 1
		}
		if ( X.holder.fakekey ) {
			admin_number_ignored++
			invalid = 1
		}
		if ( invalid ) {
			admin_number_decrease++
		}
	}
	admin_number_present = admin_number_total - admin_number_decrease
	if ( admin_number_present <= 0 ) {
		if ( !admin_number_afk && !admin_number_ignored ) {
			::send2irc( source, "" + msg + " - No admins online" )
		} else {
			::send2irc( source, "" + msg + " - All admins AFK (" + admin_number_afk + "/" + admin_number_total + ") or skipped (" + admin_number_ignored + "/" + admin_number_total + ")" )
		}
	}
	return admin_number_present
}

function set_security_level( level =null ) {
	local FA, pod
	local _ = level // Was a switch-case, sorry for the mess.
	if ( _=="green" ) {
		level = 0
	} else if ( _=="blue" ) {
		level = 1
	} else if ( _=="red" ) {
		level = 2
	} else if ( _=="delta" ) {
		level = 3
	}
	if ( level >= 0 && level <= 3 && level != ::security_level ) {
		local _ = level // Was a switch-case, sorry for the mess.
		if ( _==0 ) {
			::minor_announce( ::config.alert_desc_green, "Attention! Security level lowered to green:" )
			::security_level = 0
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !( FA instanceof ::Ent_Machinery_Firealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.$update icon()
				}
			}
		} else if ( _==1 ) {
			if ( ::security_level < 1 ) {
				::minor_announce( ::config.alert_desc_blue_upto, "Attention! Security level elevated to blue:", 1 )
			} else {
				::minor_announce( ::config.alert_desc_blue_downto, "Attention! Security level lowered to blue:" )
			}
			::security_level = 1
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !( FA instanceof ::Ent_Machinery_Firealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.$update icon()
				}
			}
		} else if ( _==2 ) {
			if ( ::security_level < 2 ) {
				::minor_announce( ::config.alert_desc_red_upto, "Attention! Code red!", 1 )
			} else {
				::minor_announce( ::config.alert_desc_red_downto, "Attention! Code red!" )
			}
			::security_level = 2
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !( FA instanceof ::Ent_Machinery_Firealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.$update icon()
				}
			}
			pod = null
			foreach (_ in ::machines ) {
				pod = _
				if ( !( pod instanceof ::Ent_Machinery_Computer_Shuttle_Pod ) ) {
					continue
				}
				pod.admin_controlled = 0
			}
		} else if ( _==3 ) {
			::minor_announce( ::config.alert_desc_delta, "Attention! Delta security level reached!", 1 )
			::security_level = 3
			FA = null
			foreach (_ in ::machines ) {
				FA = _
				if ( !( FA instanceof ::Ent_Machinery_Firealarm ) ) {
					continue
				}
				if ( FA.z == 1 ) {
					FA.$update icon()
				}
			}
			pod = null
			foreach (_ in ::machines ) {
				pod = _
				if ( !( pod instanceof ::Ent_Machinery_Computer_Shuttle_Pod ) ) {
					continue
				}
				pod.admin_controlled = 0
			}
		}
	} else {
		return
	}
}

function setblock( istring =null, blocknumber =null, replacement =null, blocksize =null ) {
	if ( blocksize == null ) {
		blocksize = 3
	}
	if ( !istring || !blocknumber || !replacement || !blocksize ) {
		return 0
	}
	return ::getleftblocks( istring, blocknumber, blocksize ) + replacement + ::getrightblocks( istring, blocknumber, blocksize )
}

function setup_database_connection(  ) {
	local user, pass, db, address, port, _default
	if ( ::failed_db_connections >= 5 ) {
		return 0
	}
	if ( !::dbcon ) {
		::dbcon = ::DBConnection()
	}
	user = ::sqlfdbklogin
	pass = ::sqlfdbkpass
	db = ::sqlfdbkdb
	address = ::sqladdress
	port = ::sqlport
	::dbcon.Connect( "dbi:mysql:" + db + ":" + address + ":" + port, "" + user, "" + pass )
	_default = ::dbcon.$IsConnected()
	if ( _default ) {
		::failed_db_connections = 0
	} else {
		::failed_db_connections++
		if ( ::config.sql_enabled ) {
			::game.log.write( "SQL error: " + ::dbcon.ErrorMsg() )
		}
	}
	return _default
	return _default
}

function setup_map_transitions(  ) {
	local SLS, D, conf_set_len, k, A, point_grid, grid, P, i, j, pnt, possible_points, used_points, S
	SLS = ::List()
	conf_set_len = ::map_transition_config.len
	k = 1
	A = null
	foreach (_ in ::map_transition_config ) {
		A = _
		D = ::SpaceLevel( ::map_transition_config[A] )
		D.name = A
		D.z_value = k
		if ( D.linked < 2 ) {
			::z_levels_list["" + D.z_value] = D
		} else {
			SLS.Add( D )
		}
		k++
	}
	point_grid = null
	point_grid = ::List( conf_set_len * 2 + 1, conf_set_len * 2 + 1 )
	grid = ::List()
	P = null
	i = null
	i = 1
	while (i <= conf_set_len * 2 + 1) {
		j = null
		j = 1
		while (j <= conf_set_len * 2 + 1) {
			P = ::Point( i, j, point_grid )
			point_grid[i][j] = P
			grid.Add( P )
			j++
		}
		i++
	}
	pnt = null
	foreach (_ in grid ) {
		pnt = _
		if ( !( pnt instanceof ::Point ) ) {
			continue
		}
		pnt.set_neigbours( point_grid )
	}
	P = point_grid[conf_set_len + 1][conf_set_len + 1]
	possible_points = ::List()
	used_points = ::List()
	grid.Cut()
	while (SLS.len) {
		D = ::random.pick( SLS )
		SLS.$Remove( D )
		D.xi = P.x
		D.yi = P.y
		P.spl = D
		possible_points = possible_points | P.neigbours
		used_points = used_points | P
		possible_points.Remove( used_points )
		D.set_neigbours( used_points )
		P = ::random.pick( possible_points )
		grid["" + D.z_value] = D
	}
	A = null
	foreach (_ in ::z_levels_list ) {
		A = _
		grid[A] = ::z_levels_list[A]
	}
	S = null
	foreach (_ in ::game ) {
		S = _
		if ( !( S instanceof ::Tile_Space ) ) {
			continue
		}
		if ( S.x <= 7 ) {
			D = grid["" + S.z]
			if ( !D ) {
				::crash( "" + S.z + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.8 && D.neigbours.8 != D ) {
				D = D.neigbours.8
				S.destination_z = D.z_value
			} else {
				while (D.neigbours.4 && D.neigbours.4 != D) {
					D = D.neigbours.4
				}
				S.destination_z = D.z_value
			}
			S.destination_x = ::game.maxx - 7 - 2
			S.destination_y = S.y
		}
		if ( S.x >= ::game.maxx - 7 - 1 ) {
			D = grid["" + S.z]
			if ( !D ) {
				::crash( "" + S.z + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.4 && D.neigbours.4 != D ) {
				D = D.neigbours.4
				S.destination_z = D.z_value
			} else {
				while (D.neigbours.8 && D.neigbours.8 != D) {
					D = D.neigbours.8
				}
				S.destination_z = D.z_value
			}
			S.destination_x = 9
			S.destination_y = S.y
		}
		if ( S.y <= 7 ) {
			D = grid["" + S.z]
			if ( !D ) {
				::crash( "" + S.z + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.2 && D.neigbours.2 != D ) {
				D = D.neigbours.2
				S.destination_z = D.z_value
			} else {
				while (D.neigbours.1 && D.neigbours.1 != D) {
					D = D.neigbours.1
				}
				S.destination_z = D.z_value
			}
			S.destination_x = S.x
			S.destination_y = ::game.maxy - 7 - 2
		}
		if ( S.y >= ::game.maxy - 7 - 1 ) {
			D = grid["" + S.z]
			if ( !D ) {
				::crash( "" + S.z + " position has no space level datum" )
			}
			if ( !D.neigbours.len ) {
				continue
			}
			if ( D.neigbours.1 && D.neigbours.1 != D ) {
				D = D.neigbours.1
				S.destination_z = D.z_value
			} else {
				while (D.neigbours.2 && D.neigbours.2 != D) {
					D = D.neigbours.2
				}
				S.destination_z = D.z_value
			}
			S.destination_x = S.x
			S.destination_y = 9
		}
	}
	A = null
	foreach (_ in grid ) {
		A = _
		::z_levels_list[A] = grid[A]
	}
}

function SetViruses( R =null, data =null ) {
	local preserve, A
	if ( data ) {
		preserve = ::List()
		if ( data instanceof ::List && data.viruses ) {
			A = null
			foreach (_ in data.viruses ) {
				A = _
				if ( !( A instanceof ::Disease ) ) {
					continue
				}
				preserve += A.Copy()
			}
			R.data = data.Copy()
		}
		if ( preserve.len ) {
			R.data.viruses = preserve
		}
	}
}

function shake_camera( M =null, duration =null, strength =null ) {
	local oldeye, x
	if ( strength == null ) {
		strength = 1
	}
	::thread.schedule( 0, function() {
		if ( !M || !M.client || M.shakecamera ) {
			return
		}
		oldeye = M.client.eye
		M.shakecamera = 1
		x = 0
		while (x < duration) {
			if ( M && M.client ) {
				M.client.eye = ::locate3( ::dd_range( 1, M.loc.x + ::random.int( -strength, strength ), ::game.maxx ), ::dd_range( 1, M.loc.y + ::random.int( -strength, strength ), ::game.maxy ), M.loc.z )
				::thread.sleep( 1 )
			}
			x++
		}
		if ( M ) {
			M.shakecamera = 0
			if ( M.client ) {
				M.client.eye = oldeye
			}
		}
		return
	})
}

function show_note( target_ckey =null, index =null, linkless =null ) {
	local output, navbar, ruler, letter, target_sql_ckey, query_get_notes, err, id, timestamp, notetext, adminckey, last_editor, server, index_ckey, search, query_list_notes
	if ( linkless == null ) {
		linkless = 0
	}
	ruler = "<hr style='background:#000000; border:0; height:3px'>"
	navbar = "<a href='?_src_=holder;nonalpha=1'>[All]</a>|<a href='?_src_=holder;nonalpha=2'>[#]</a>"
	letter = null
	foreach (_ in ::alphabet ) {
		letter = _
		navbar += "|<a href='?_src_=holder;shownote=" + letter + "'>[" + letter + "]</a>"
	}
	navbar += "<br><form method='GET' name='search' action='?'><input type='hidden' name='_src_' value='holder'><input type='text' name='notessearch' value='" + index + "'><input type='submit' value='Search'></form>"
	if ( !linkless ) {
		output = navbar
	}
	if ( target_ckey ) {
		target_sql_ckey = ::sanitizeSQL( target_ckey )
		query_get_notes = ::dbcon.NewQuery( "SELECT id, timestamp, notetext, adminckey, last_editor, server FROM " + ::format_table_name( "notes" ) + " WHERE ckey = '" + target_sql_ckey + "' ORDER BY timestamp" )
		if ( !query_get_notes.Execute() ) {
			err = query_get_notes.$ErrorMsg()
			::log_game( "SQL ERROR obtaining ckey, notetext, adminckey, last_editor, server from notes table. Error : [" + err + "]\n" )
			return
		}
		output += "<h2><center>Notes of " + target_ckey + "</center></h2>"
		if ( !linkless ) {
			output += "<center><a href='?_src_=holder;addnote=" + target_ckey + "'>[Add Note]</a></center>"
		}
		output += ruler
		while (query_get_notes.NextRow()) {
			id = query_get_notes.item[1]
			timestamp = query_get_notes.item[2]
			notetext = query_get_notes.item[3]
			adminckey = query_get_notes.item[4]
			last_editor = query_get_notes.item[5]
			server = query_get_notes.item[6]
			output += "<b>" + timestamp + " | " + server + " | " + adminckey + "</b>"
			if ( !linkless ) {
				output += " <a href='?_src_=holder;removenote=" + id + "'>[Remove Note]</a> <a href='?_src_=holder;editnote=" + id + "'>[Edit Note]</a>"
				if ( last_editor ) {
					output += " <font size='2'>Last edit by " + last_editor + " <a href='?_src_=holder;noteedits=" + id + "'>(Click here to see edit log)</a></font>"
				}
			}
			output += "<br>" + notetext + "<hr style='background:#000000; border:0; height:1px'>"
		}
	} else if ( index ) {
		index_ckey = null
		search = null
		output += "<center><a href='?_src_=holder;addnoteempty=1'>[Add Note]</a></center>"
		output += ruler
		if ( !::isnum( index ) ) {
			index = ::sanitizeSQL( index )
		}
		local _ = index // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			search = "^."
		} else if ( _==2 ) {
			search = "^[^[:alpha:]]"
		} else {
			search = "^" + index
		}
		query_list_notes = ::dbcon.NewQuery( "SELECT DISTINCT ckey FROM " + ::format_table_name( "notes" ) + " WHERE ckey REGEXP '" + search + "' ORDER BY ckey" )
		if ( !query_list_notes.Execute() ) {
			err = query_list_notes.$ErrorMsg()
			::log_game( "SQL ERROR obtaining ckey from notes table. Error : [" + err + "]\n" )
			return
		}
		while (query_list_notes.NextRow()) {
			index_ckey = query_list_notes.item[1]
			output += "<a href='?_src_=holder;shownoteckey=" + index_ckey + "'>" + index_ckey + "</a><br>"
		}
	} else {
		output += "<center><a href='?_src_=holder;addnoteempty=1'>[Add Note]</a></center>"
		output += ruler
	}
	::browse( ::thread.user, output, "window=show_notes;size=900x500" )
}

function shuffle( L =null ) {
	local i
	if ( !L ) {
		return
	}
	L = L.Copy()
	i = null
	i = 1
	while (i < L.len) {
		L.$Swap( i, ::random.int( i, L.len ) )
		i++
	}
	return L
}

function sign( x =null ) {
	return x != 0 ? x / ::math.abs( x ) : 0
}

function SimplifyDegrees( degrees =null ) {
	degrees = degrees % 360
	if ( degrees < 0 ) {
		degrees += 360
	}
	return degrees
}

function slur( n =null ) {
	local phrase, leng, counter, newphrase, newletter
	phrase = ::html_decode( n )
	leng = ::length( phrase )
	counter = ::length( phrase )
	newphrase = ""
	newletter = ""
	while (counter >= 1) {
		newletter = ::copytext( phrase, leng - counter + 1, leng - counter + 2 )
		if ( ::random.int( 1, 3 ) == 3 ) {
			if ( ::lowertext( newletter ) == "o" ) {
				newletter = "u"
			}
			if ( ::lowertext( newletter ) == "s" ) {
				newletter = "ch"
			}
			if ( ::lowertext( newletter ) == "a" ) {
				newletter = "ah"
			}
			if ( ::lowertext( newletter ) == "u" ) {
				newletter = "oo"
			}
			if ( ::lowertext( newletter ) == "c" ) {
				newletter = "k"
			}
		}
		if ( ::random.int( 1, 20 ) == 20 ) {
			if ( newletter == " " ) {
				newletter = "...huuuhhh..."
			}
			if ( newletter == "." ) {
				newletter = " *BURP*."
			}
		}
		local _ = ::random.int( 1, 20 ) // Was a switch-case, sorry for the mess.
		if ( _==1 ) {
			newletter += "'"
		} else if ( _==10 ) {
			newletter += "" + newletter
		} else if ( _==20 ) {
			newletter += "" + newletter + newletter
		}
		newphrase += "" + newletter
		counter -= 1
	}
	return newphrase
}

function smooth_icon( A =null ) {
	local adjacencies
	if ( ::qdeleted( A ) ) {
		return
	}
	::thread.schedule( 0, function() {
		if ( A && A.smooth ) {
			adjacencies = ::calculate_adjacencies( A )
			A.clear_smooth_overlays()
			A.top_left_corner = ::make_nw_corner( adjacencies )
			A.top_right_corner = ::make_ne_corner( adjacencies )
			A.bottom_left_corner = ::make_sw_corner( adjacencies )
			A.bottom_right_corner = ::make_se_corner( adjacencies )
			A.overlays += A.top_left_corner
			A.overlays += A.top_right_corner
			A.overlays += A.bottom_right_corner
			A.overlays += A.bottom_left_corner
		}
		return
	})
}

function smooth_icon_neighbors( A =null ) {
	local T
	T = null
	foreach (_ in ::orange( 1, A ) ) {
		T = _
		if ( !( T instanceof ::BaseStatic ) ) {
			continue
		}
		if ( T.smooth ) {
			::smooth_icon( T )
		}
	}
}

function sortInsert( L =null, cmp =null, associative =null, fromIndex =null, toIndex =null ) {
	if ( cmp == null ) {
		cmp = ::cmp_numeric_asc
	}
	if ( fromIndex == null ) {
		fromIndex = 1
	}
	if ( toIndex == null ) {
		toIndex = 0
	}
	if ( L && L.len >= 2 ) {
		fromIndex = fromIndex % L.len
		toIndex = toIndex % ( L.len + 1 )
		if ( fromIndex <= 0 ) {
			fromIndex += L.len
		}
		if ( toIndex <= 0 ) {
			toIndex += L.len + 1
		}
		::sortInstance.L = L
		::sortInstance.cmp = cmp
		::sortInstance.associative = associative
		::sortInstance.$binarySort( fromIndex, toIndex, fromIndex )
	}
	return L
}

function sortKey( L =null, order =null ) {
	if ( order == null ) {
		order = 1
	}
	return ::sortTim( L, order >= 0 ? ::cmp_ckey_asc : ::cmp_ckey_dsc )
}

function sortList( L =null, cmp =null ) {
	if ( cmp == null ) {
		cmp = ::cmp_text_asc
	}
	return ::sortTim( L.Copy(), cmp )
}

function sortmobs(  ) {
	local moblist, sortmob, M
	moblist = ::List()
	sortmob = ::sortNames( ::mob_list )
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Silicon_Ai ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Camera ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Silicon_Pai ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Silicon_Robot ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Carbon_Human ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Carbon_Brain ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Carbon_Alien ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Dead_Observer ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_NewPlayer ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_Carbon_Monkey ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_SimpleAnimal_Slime ) ) {
			continue
		}
		moblist.Add( M )
	}
	M = null
	foreach (_ in sortmob ) {
		M = _
		if ( !( M instanceof ::Mob_Living_SimpleAnimal ) ) {
			continue
		}
		moblist.Add( M )
	}
	return moblist
}

function sortNames( L =null, order =null ) {
	if ( order == null ) {
		order = 1
	}
	return ::sortTim( L, order >= 0 ? ::cmp_name_asc : ::cmp_name_dsc )
}

function sortRecord( L =null, field =null, order =null ) {
	if ( field == null ) {
		field = "name"
	}
	if ( order == null ) {
		order = 1
	}
	::cmp_field = field
	return ::sortTim( L, order >= 0 ? ::cmp_records_asc : ::cmp_records_dsc )
}

function sortTim( L =null, cmp =null, associative =null, fromIndex =null, toIndex =null ) {
	if ( cmp == null ) {
		cmp = ::cmp_numeric_asc
	}
	if ( fromIndex == null ) {
		fromIndex = 1
	}
	if ( toIndex == null ) {
		toIndex = 0
	}
	if ( L && L.len >= 2 ) {
		fromIndex = fromIndex % L.len
		toIndex = toIndex % ( L.len + 1 )
		if ( fromIndex <= 0 ) {
			fromIndex += L.len
		}
		if ( toIndex <= 0 ) {
			toIndex += L.len + 1
		}
		::sortInstance.L = L
		::sortInstance.cmp = cmp
		::sortInstance.associative = associative
		::sortInstance.timSort( fromIndex, toIndex )
	}
	return L
}

function spaceDebrisFinishLoc( startSide =null, Z =null ) {
	local endy, endx, T
	local _ = startSide // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		endy = 7
		endx = ::random.int( 7, ::game.maxx - 7 )
	} else if ( _==2 ) {
		endy = ::random.int( 7, ::game.maxy - 7 )
		endx = 7
	} else if ( _==3 ) {
		endy = ::game.maxy - 7
		endx = ::random.int( 7, ::game.maxx - 7 )
	} else if ( _==4 ) {
		endy = ::random.int( 7, ::game.maxy - 7 )
		endx = ::game.maxx - 7
	}
	T = ::locate3( endx, endy, Z )
	return T
}

function spaceDebrisStartLoc( startSide =null, Z =null ) {
	local starty, startx, T
	local _ = startSide // Was a switch-case, sorry for the mess.
	if ( _==1 ) {
		starty = ::game.maxy - 8
		startx = ::random.int( 8, ::game.maxx - 8 )
	} else if ( _==2 ) {
		starty = ::random.int( 8, ::game.maxy - 8 )
		startx = ::game.maxx - 8
	} else if ( _==3 ) {
		starty = 8
		startx = ::random.int( 8, ::game.maxx - 8 )
	} else if ( _==4 ) {
		starty = ::random.int( 8, ::game.maxy - 8 )
		startx = 8
	}
	T = ::locate3( startx, starty, Z )
	return T
}

function spawn_meteor( meteortypes =null ) {
	local pickedstart, pickedgoal, max_i, startSide, Me, M
	max_i = 10
	while (!( pickedstart instanceof ::Tile_Space )) {
		startSide = ::random.pick( ::cardinal )
		pickedstart = ::spaceDebrisStartLoc( startSide, 1 )
		pickedgoal = ::spaceDebrisFinishLoc( startSide, 1 )
		max_i--
		if ( max_i <= 0 ) {
			return
		}
	}
	Me = ::pickweight( meteortypes )
	M = Me( pickedstart )
	M.dest = pickedgoal
	M.z_original = 1
	::thread.schedule( 0, function() {
		::walk_towards( M, M.dest, 1 )
		return
	})
	return
}

function spawn_meteors( number =null, meteortypes =null ) {
	local i
	if ( number == null ) {
		number = 10
	}
	i = null
	i = 0
	while (i < number) {
		::spawn_meteor( meteortypes )
		i++
	}
}

function spawn_room( start_loc =null, x_size =null, y_size =null, walltypes =null, floor =null, name =null ) {
	local room_turfs, x, y, T, cur_loc, A, wall
	room_turfs = ::List({
		["floors"]= ::List(),
		["walls"]= ::List()
	})
	x = null
	x = 0
	while (x < x_size) {
		y = null
		y = 0
		while (y < y_size) {
			T = null
			cur_loc = ::locate3( start_loc.x + x, start_loc.y + y, start_loc.z )
			A = ::Area(2768)()
			if ( name ) {
				A.name = name
			} else {
				A.name = "Artifact Room #" + A.x + "-" + A.y + "-" + A.z
			}
			if ( x == 0 || x == x_size - 1 || y == 0 || y == y_size - 1 ) {
				wall = ::pickweight( walltypes )
				T = cur_loc
				T.ChangeTurf( wall )
				room_turfs.walls += T
			} else {
				T = cur_loc
				T.ChangeTurf( floor )
				room_turfs.floors += T
			}
			A.contents += T
			y++
		}
		x++
	}
	return room_turfs
}

function sql_poll_admins(  ) {
	local admincount, sqltime, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	admincount = ::admins.len
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during admin polling. Failed to connect." )
	} else {
		sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
		query = ::dbcon.NewQuery( "INSERT INTO " + ::format_table_name( "legacy_population" ) + " (admincount, time) VALUES (" + admincount + ", '" + sqltime + "')" )
		if ( !query.Execute() ) {
			err = query.$ErrorMsg()
			::log_game( "SQL ERROR during admin polling. Error : [" + err + "]\n" )
		}
	}
}

function sql_poll_players(  ) {
	local playercount, M, sqltime, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	playercount = 0
	M = null
	foreach (_ in ::player_list ) {
		M = _
		if ( M.client ) {
			playercount += 1
		}
	}
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during player polling. Failed to connect." )
	} else {
		sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
		query = ::dbcon.NewQuery( "INSERT INTO " + ::format_table_name( "legacy_population" ) + " (playercount, time) VALUES (" + playercount + ", '" + sqltime + "')" )
		if ( !query.Execute() ) {
			err = query.$ErrorMsg()
			::log_game( "SQL ERROR during player polling. Error : [" + err + "]\n" )
		}
	}
}

function sql_report_cyborg_death( H =null ) {
	local T, placeofdeath, podname, sqlname, sqlkey, sqlpod, sqlspecial, sqljob, laname, lakey, sqltime, coord, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	if ( !H ) {
		return
	}
	if ( !H.key || !H.mind ) {
		return
	}
	T = H.loc
	placeofdeath = ::get_area( T.loc )
	podname = placeofdeath.name
	sqlname = ::sanitizeSQL( H.real_name )
	sqlkey = ::sanitizeSQL( H.key )
	sqlpod = ::sanitizeSQL( podname )
	sqlspecial = ::sanitizeSQL( H.mind.special_role )
	sqljob = ::sanitizeSQL( H.mind.assigned_role )
	if ( H.lastattacker ) {
		laname = ::sanitizeSQL( H.lastattacker.real_name )
		lakey = ::sanitizeSQL( H.lastattacker.key )
	}
	sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
	coord = "" + H.x + ", " + H.y + ", " + H.z
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during death reporting. Failed to connect." )
	} else {
		query = ::dbcon.NewQuery( "INSERT INTO " + ::format_table_name( "death" ) + " (name, byondkey, job, special, pod, tod, laname, lakey, gender, bruteloss, fireloss, brainloss, oxyloss, coord) VALUES ('" + sqlname + "', '" + sqlkey + "', '" + sqljob + "', '" + sqlspecial + "', '" + sqlpod + "', '" + sqltime + "', '" + laname + "', '" + lakey + "', '" + H.gender + "', " + H.$getBruteLoss() + ", " + H.$getFireLoss() + ", " + H.brainloss + ", " + H.$getOxyLoss() + ", '" + coord + "')" )
		if ( !query.Execute() ) {
			err = query.$ErrorMsg()
			::log_game( "SQL ERROR during death reporting. Error : [" + err + "]\n" )
		}
	}
}

function sql_report_death( H =null ) {
	local T, placeofdeath, podname, sqlname, sqlkey, sqlpod, sqlspecial, sqljob, laname, lakey, sqltime, coord, query, err
	if ( !::config.sql_enabled ) {
		return
	}
	if ( !H ) {
		return
	}
	if ( !H.key || !H.mind ) {
		return
	}
	T = H.loc
	placeofdeath = ::get_area( T.loc )
	podname = placeofdeath.name
	sqlname = ::sanitizeSQL( H.real_name )
	sqlkey = ::sanitizeSQL( H.key )
	sqlpod = ::sanitizeSQL( podname )
	sqlspecial = ::sanitizeSQL( H.mind.special_role )
	sqljob = ::sanitizeSQL( H.mind.assigned_role )
	if ( H.lastattacker ) {
		laname = ::sanitizeSQL( H.lastattacker.real_name )
		lakey = ::sanitizeSQL( H.lastattacker.key )
	}
	sqltime = ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
	coord = "" + H.x + ", " + H.y + ", " + H.z
	::establish_db_connection()
	if ( !::dbcon.IsConnected() ) {
		::log_game( "SQL ERROR during death reporting. Failed to connect." )
	} else {
		query = ::dbcon.NewQuery( "INSERT INTO " + ::format_table_name( "death" ) + " (name, byondkey, job, special, pod, tod, laname, lakey, gender, bruteloss, fireloss, brainloss, oxyloss, coord) VALUES ('" + sqlname + "', '" + sqlkey + "', '" + sqljob + "', '" + sqlspecial + "', '" + sqlpod + "', '" + sqltime + "', '" + laname + "', '" + lakey + "', '" + H.gender + "', " + H.$getBruteLoss() + ", " + H.$getFireLoss() + ", " + H.brainloss + ", " + H.$getOxyLoss() + ", '" + coord + "')" )
		if ( !query.Execute() ) {
			err = query.$ErrorMsg()
			::log_game( "SQL ERROR during death reporting. Error : [" + err + "]\n" )
		}
	}
}

function SQLtime(  ) {
	return ::time2text( "YYYY-MM-DD hh:mm:ss", ::game.realtime )
}

function stars( n =null, pr =null ) {
	local te, t, p
	n = ::html_encode( n )
	if ( pr == null ) {
		pr = 25
	}
	if ( pr <= 0 ) {
		return
	} else if ( pr >= 100 ) {
		return n
	}
	te = n
	t = ""
	n = ::length( n )
	p = null
	p = 1
	while (p <= n) {
		if ( ::copytext( te, p, p + 1 ) == " " || ::random.chance( pr ) ) {
			t = "" + t + ::copytext( te, p, p + 1 )
		} else {
			t = "" + t + "*"
		}
		p++
	}
	return ::sanitize( t )
}

function stickyban2list( ban =null ) {
	if ( !ban ) {
		return
	}
	_default = ::params2list( ban )
	_default.keys = ::text2list( _default.keys, "," )
	_default.type = ::text2list( _default.type, "," )
	_default.IP = ::text2list( _default.IP, "," )
	_default.computer_id = ::text2list( _default.computer_id, "," )
	return _default
}

function string2listofvars( t_string =null, var_source =null ) {
	local var_found, list_value, intermediate_stage, value, A, _default
	if ( !t_string || !var_source ) {
		return ::List()
	}
	_default = ::List()
	var_found = ::findtext( t_string, "[", 1, null )
	if ( var_found ) {
		t_string = ::replacetext( t_string, "[", "[ " )
		list_value = ::text2list( t_string, "[" )
		intermediate_stage = ::list2text( list_value )
		list_value = ::text2list( intermediate_stage, " " )
		value = null
		foreach (_ in list_value ) {
			value = _
			if ( ::findtext( value, "]", 1, null ) ) {
				value = ::text2list( value, "]" )
				A = null
				foreach (_ in value ) {
					A = _
					if ( var_source.vars.Find( A ) ) {
						_default += A
					}
				}
			}
		}
	}
	return _default
}

function strings( filename =null, key =null ) {
	local fileList, stringsList, s
	if ( !::string_cache ) {
		::string_cache = ::List()
	}
	if ( !( filename in ::string_cache ) ) {
		if ( ::file.exists( "strings/" + filename ) ) {
			::string_cache[filename] = ::List()
			stringsList = ::List()
			fileList = ::file2list( "strings/" + filename )
			s = null
			foreach (_ in fileList ) {
				s = _
				stringsList = ::text2list( s, "@=" )
				if ( stringsList.len != 2 ) {
					::crash( "Invalid string list in strings/" + filename )
				}
				if ( ::findtext( stringsList[2], "@,", 1, null ) ) {
					::string_cache[filename][stringsList[1]] = ::text2list( stringsList[2], "@," )
				} else {
					::string_cache[filename][stringsList[1]] = stringsList[2]
				}
			}
		} else {
			::crash( "file not found: strings/" + filename )
		}
	}
	if ( filename in ::string_cache && key in ::string_cache[filename] ) {
		return ::string_cache[filename][key]
	} else {
		::crash( "strings list not found: strings/" + filename + ", index=" + key )
	}
}

function strip_html_simple( t =null, limit =null ) {
	local strip_chars, char, index
	if ( limit == null ) {
		limit = 1024
	}
	strip_chars = ::List([ "<", ">" ])
	t = ::copytext( t, 1, limit )
	char = null
	foreach (_ in strip_chars ) {
		char = _
		index = ::findtext( t, char, 1, null )
		while (index) {
			t = ::copytext( t, 1, index ) + ::copytext( t, index + 1, null )
			index = ::findtext( t, char, 1, null )
		}
	}
	return t
}

function stripped_input( user =null, message =null, title =null, __default =null, max_length =null ) {
	local name
	if ( message == null ) {
		message = ""
	}
	if ( title == null ) {
		title = ""
	}
	if ( __default == null ) {
		__default = ""
	}
	if ( max_length == null ) {
		max_length = 1024
	}
	name = ::input( user, message, title, __default, null, 132 )
	return ::trim( ::html_encode( name ), max_length )
}

function stutter( n =null ) {
	local te, t, p, n_letter
	te = ::html_decode( n )
	t = ""
	n = ::length( n )
	p = null
	p = 1
	while (p <= n) {
		n_letter = ::copytext( te, p, p + 1 )
		if ( ::random.chance( 80 ) && ::ckey( n_letter ) in ::List([ "b", "c", "d", "f", "g", "h", "j", "k", "l", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z" ]) ) {
			if ( ::random.chance( 10 ) ) {
				n_letter = "" + n_letter + "-" + n_letter + "-" + n_letter + "-" + n_letter
			} else if ( ::random.chance( 20 ) ) {
				n_letter = "" + n_letter + "-" + n_letter + "-" + n_letter
			} else if ( ::random.chance( 5 ) ) {
				n_letter = null
			} else {
				n_letter = "" + n_letter + "-" + n_letter
			}
		}
		t = "" + t + n_letter
		p++
	}
	return ::copytext( ::sanitize( t ), 1, 1024 )
}

function summonevents(  ) {
	if ( !::SSevent.wizardmode ) {
		::SSevent.frequency_lower = 600
		::SSevent.frequency_upper = 3000
		::SSevent.toggleWizardmode()
		::SSevent.$reschedule()
	} else {
		::SSevent.frequency_upper -= 600
		if ( ::SSevent.frequency_upper < ::SSevent.frequency_lower ) {
			::SSevent.frequency_upper = ::SSevent.frequency_lower
		}
		::SSevent.reschedule()
		::message_admins( "Summon Events intensifies, events will now occur every " + ::SSevent.frequency_lower / 600 + " to " + ::SSevent.frequency_upper / 600 + " minutes." )
		::log_game( "Summon Events was increased!" )
	}
}

function testing( msg =null ) {
	
}

function text2dir_extended( direction =null ) {
	local _ = ::uppertext( direction ) // Was a switch-case, sorry for the mess.
	if ( _=="NORTH" || _=="N" ) {
		return 1
	} else if ( _=="SOUTH" || _=="S" ) {
		return 2
	} else if ( _=="EAST" || _=="E" ) {
		return 4
	} else if ( _=="WEST" || _=="W" ) {
		return 8
	} else if ( _=="NORTHEAST" || _=="NE" ) {
		return 5
	} else if ( _=="NORTHWEST" || _=="NW" ) {
		return 9
	} else if ( _=="SOUTHEAST" || _=="SE" ) {
		return 6
	} else if ( _=="SOUTHWEST" || _=="SW" ) {
		return 10
	}
	return 0
}

function text2list( text =null, delimiter =null ) {
	local delim_len, last_found, found, _default
	if ( delimiter == null ) {
		delimiter = "\n"
	}
	delim_len = ::length( delimiter )
	if ( delim_len < 1 ) {
		return ::List([ text ])
	}
	_default = ::List()
	last_found = 1
	while (1) { // Was a do-while, sorry for the mess.
		found = ::findtext( text, delimiter, last_found, 0 )
		_default += ::copytext( text, last_found, found )
		last_found = found + delim_len
		if (!( found )) break;
	}
	return _default
}

function time_stamp( format =null ) {
	if ( format == null ) {
		format = "hh:mm:ss"
	}
	return ::time2text( format, ::game.timeofday )
}

function tkMaxRangeCheck( user =null, target =null, focus =null ) {
	local d
	d = ::get_dist( user, target )
	if ( focus ) {
		d = ::math.max( d, ::get_dist( user, focus ) )
	}
	if ( d > ::tk_maxrange ) {
		user.write( "<span class ='warning'>Your mind won't reach that far.</span>" )
		return 0
	}
	return 1
}

function toggle_ooc( toggle =null ) {
	if ( toggle == null ) {
		toggle = null
	}
	if ( toggle != null ) {
		if ( toggle != ::ooc_allowed ) {
			::ooc_allowed = toggle
		} else {
			return
		}
	} else {
		::ooc_allowed = !::ooc_allowed
	}
	::game.write( "<B>The OOC channel has been globally " + ( ::ooc_allowed ? "enabled" : "disabled" ) + ".</B>" )
}

function togglebuildmode( M =null ) {
	local H, A, B, C, D
	if ( M.client ) {
		if ( M.client.buildmode ) {
			::log_admin( "" + ::key_name( ::thread.user ) + " has left build mode." )
			M.client.buildmode = 0
			M.client.show_popup_menus = 1
			H = null
			foreach (_ in ::game ) {
				H = _
				if ( !( H instanceof ::Ent_Effect_Bmode_Buildholder ) ) {
					continue
				}
				if ( H.cl == M.client ) {
					::qdel( H )
				}
			}
		} else {
			::message_admins( "" + ::key_name( ::thread.user ) + " has entered build mode." )
			::log_admin( "" + ::key_name( ::thread.user ) + " has entered build mode." )
			M.client.buildmode = 1
			M.client.show_popup_menus = 0
			H = ::Ent_Effect_Bmode_Buildholder()
			A = ::Ent_Effect_Bmode_Builddir( H )
			A.master = H
			B = ::Ent_Effect_Bmode_Buildhelp( H )
			B.master = H
			C = ::Ent_Effect_Bmode_Buildmode( H )
			C.master = H
			D = ::Ent_Effect_Bmode_Buildquit( H )
			D.master = H
			H.builddir = A
			H.buildhelp = B
			H.buildmode = C
			H.buildquit = D
			M.client.screen += A
			M.client.screen += B
			M.client.screen += C
			M.client.screen += D
			H.cl = M.client
		}
	}
}

function trange( Dist =null, Center =null ) {
	local x1y1, x2y2
	if ( Dist == null ) {
		Dist = 0
	}
	if ( Center == null ) {
		Center = null
	}
	if ( Center == null ) {
		return
	}
	x1y1 = ::locate3( Center.x - Dist < 1 ? 1 : Center.x - Dist, Center.y - Dist < 1 ? 1 : Center.y - Dist, Center.z )
	x2y2 = ::locate3( Center.x + Dist > ::game.maxx ? ::game.maxx : Center.x + Dist, Center.y + Dist > ::game.maxy ? ::game.maxy : Center.y + Dist, Center.z )
	return ::block( x1y1, x2y2 )
}

function transform_dir( direction =null ) {
	local _ = direction // Was a switch-case, sorry for the mess.
	if ( _==1 || _==2 || _==4 || _==8 ) {
		return direction
	} else if ( _==5 ) {
		return 16
	} else if ( _==9 ) {
		return 32
	} else if ( _==6 ) {
		return 64
	} else if ( _==10 ) {
		return 128
	}
}

function trim( text =null, max_length =null ) {
	if ( max_length ) {
		text = ::copytext( text, 1, max_length )
	}
	return ::trim_left( ::trim_right( text ) )
}

function trim_left( text =null ) {
	local i
	i = null
	foreach (_ in ::gen_range( 1, ::length( text ) ) ) {
		i = _
		if ( ::text2ascii( text, i ) > 32 ) {
			return ::copytext( text, i, null )
		}
	}
	return ""
}

function trim_right( text =null ) {
	local i
	i = null
	i = ::length( text )
	while (i > 0) {
		if ( ::text2ascii( text, i ) > 32 ) {
			return ::copytext( text, 1, i + 1 )
		}
		i--
	}
	return ""
}

function try_move_adjacent( AM =null ) {
	local T, direction
	T = ::get_turf( AM )
	direction = null
	foreach (_ in ::cardinal ) {
		direction = _
		if ( AM.Move( ::get_step( T, direction ) ) ) {
			break
		}
	}
}

function ui_style2icon( ui_style =null ) {
	local _ = ui_style // Was a switch-case, sorry for the mess.
	if ( _=="Retro" ) {
		return ::Rsc(12)
	} else if ( _=="Plasmafire" ) {
		return ::Rsc(13)
	} else {
		return ::Rsc(14)
	}
}

function ultra_range( dist =null, center =null, orange =null ) {
	local t_center, L, T, y, x, c_dist
	if ( dist == null ) {
		dist = 0
	}
	if ( center == null ) {
		center = ::thread.user
	}
	if ( orange == null ) {
		orange = 0
	}
	if ( !dist ) {
		if ( !orange ) {
			return ::List([ center ])
		} else {
			return ::List()
		}
	}
	t_center = ::get_turf( center )
	if ( !t_center ) {
		return ::List()
	}
	L = ::List()
	c_dist = 1
	if ( !orange ) {
		L += t_center
		L += t_center.contents
	}
	while (c_dist <= dist) {
		y = t_center.y + c_dist
		x = t_center.x - c_dist + 1
		foreach (_ in ::gen_range( x, t_center.x + c_dist ) ) {
			x = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y + c_dist - 1
		x = t_center.x + c_dist
		foreach (_ in ::gen_range( t_center.y - c_dist, y ) ) {
			y = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y - c_dist
		x = t_center.x + c_dist - 1
		foreach (_ in ::gen_range( t_center.x - c_dist, x ) ) {
			x = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		y = t_center.y - c_dist + 1
		x = t_center.x - c_dist
		foreach (_ in ::gen_range( y, t_center.y + c_dist ) ) {
			y = _
			T = ::locate3( x, y, t_center.z )
			if ( T ) {
				L += T
				L += T.contents
			}
		}
		c_dist++
	}
	return L
}

function unix2date( timestamp =null, seperator =null ) {
	local year, dayInSeconds, daysInYear, daysInLYear, days, tmpDays, monthsInDays, month, day, mDays, monthIndex, m
	if ( seperator == null ) {
		seperator = "-"
	}
	if ( timestamp < 0 ) {
		return 0
	}
	year = 1970
	dayInSeconds = 86400
	daysInYear = 365
	daysInLYear = daysInYear + 1
	days = ::math.round( timestamp / dayInSeconds )
	tmpDays = days + 1
	monthsInDays = ::List()
	month = 1
	while (tmpDays > daysInYear) {
		year++
		if ( ::isLeap( year ) ) {
			tmpDays -= daysInLYear
		} else {
			tmpDays -= daysInYear
		}
	}
	if ( ::isLeap( year ) ) {
		monthsInDays = ::List([ -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ])
	} else {
		monthsInDays = ::List([ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ])
	}
	mDays = 0
	monthIndex = 0
	m = null
	foreach (_ in monthsInDays ) {
		m = _
		monthIndex++
		if ( tmpDays > m ) {
			mDays = m
			month = monthIndex
		}
	}
	day = tmpDays - mDays
	return "" + year + seperator + ( month < 10 ? "0" + month : month ) + seperator + ( day < 10 ? "0" + day : day )
}

function updateallghostimages(  ) {
	local O
	O = null
	foreach (_ in ::player_list ) {
		O = _
		if ( !( O instanceof ::Mob_Dead_Observer ) ) {
			continue
		}
		O.updateghostimages()
	}
}

function UpdateTime(  ) {
	::CMinutes = ::game.realtime / 10 / 60
	return 1
}

function view_or_range( distance =null, center =null, type =null ) {
	if ( distance == null ) {
		distance = ::game.view
	}
	if ( center == null ) {
		center = ::thread.user
	}
	local _ = type // Was a switch-case, sorry for the mess.
	if ( _=="view" ) {
		_default = ::view( distance, center )
	} else if ( _=="range" ) {
		_default = ::range( distance, center )
	}
	return
	return _default
}

function vol_by_throwforce_and_or_w_class( I =null ) {
	if ( !I ) {
		return 0
	}
	if ( I.throwforce && I.w_class ) {
		return ::Clamp( ( I.throwforce + I.w_class ) * 5, 30, 100 )
	} else if ( I.w_class ) {
		return ::Clamp( I.w_class * 8, 20, 100 )
	} else {
		return 0
	}
}

function warning( msg =null ) {
	::game.log.write( "## WARNING: " + msg )
}

function wear_female_version( t_color =null, icon =null, layer =null, type =null ) {
	local index, female_clothing_icon, standing
	index = t_color
	female_clothing_icon = ::female_clothing_icons[index]
	if ( !female_clothing_icon ) {
		::generate_female_clothing( index, t_color, icon, type )
	}
	standing = ::Image.lcall( ::List({ ["layer"]= -layer, ["icon"]= ::female_clothing_icons["" + t_color] }) )
	return standing
}

function worldtime2text(  ) {
	return ::gameTimestamp( "hh:mm" )
}

function Wrap( val =null, min =null, max =null ) {
	local d, t
	d = max - min
	t = ::math.round( ( val - min ) / d )
	return val - t * d
}

function xgibs( location =null, viruses =null ) {
	::Ent_Effect_Gibspawner_Xeno( location, viruses )
}

